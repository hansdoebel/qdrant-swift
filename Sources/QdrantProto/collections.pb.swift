// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: collections.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Qdrant_Datatype: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case `default` // = 0
  case float32 // = 1
  case uint8 // = 2
  case float16 // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .float32
    case 2: self = .uint8
    case 3: self = .float16
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .float32: return 1
    case .uint8: return 2
    case .float16: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_Datatype] = [
    .default,
    .float32,
    .uint8,
    .float16,
  ]

}

public enum Qdrant_Modifier: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0

  /// Apply Inverse Document Frequency
  case idf // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .idf
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .idf: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_Modifier] = [
    .none,
    .idf,
  ]

}

public enum Qdrant_MultiVectorComparator: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case maxSim // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .maxSim
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .maxSim
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .maxSim: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_MultiVectorComparator] = [
    .maxSim,
  ]

}

public enum Qdrant_Distance: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownDistance // = 0
  case cosine // = 1
  case euclid // = 2
  case dot // = 3
  case manhattan // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownDistance
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDistance
    case 1: self = .cosine
    case 2: self = .euclid
    case 3: self = .dot
    case 4: self = .manhattan
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownDistance: return 0
    case .cosine: return 1
    case .euclid: return 2
    case .dot: return 3
    case .manhattan: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_Distance] = [
    .unknownDistance,
    .cosine,
    .euclid,
    .dot,
    .manhattan,
  ]

}

public enum Qdrant_CollectionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownCollectionStatus // = 0

  /// All segments are ready
  case green // = 1

  /// Optimization in process
  case yellow // = 2

  /// Something went wrong
  case red // = 3

  /// Optimization is pending
  case grey // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownCollectionStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownCollectionStatus
    case 1: self = .green
    case 2: self = .yellow
    case 3: self = .red
    case 4: self = .grey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownCollectionStatus: return 0
    case .green: return 1
    case .yellow: return 2
    case .red: return 3
    case .grey: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_CollectionStatus] = [
    .unknownCollectionStatus,
    .green,
    .yellow,
    .red,
    .grey,
  ]

}

public enum Qdrant_PayloadSchemaType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownType // = 0
  case keyword // = 1
  case integer // = 2
  case float // = 3
  case geo // = 4
  case text // = 5
  case bool // = 6
  case datetime // = 7
  case uuid // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownType
    case 1: self = .keyword
    case 2: self = .integer
    case 3: self = .float
    case 4: self = .geo
    case 5: self = .text
    case 6: self = .bool
    case 7: self = .datetime
    case 8: self = .uuid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownType: return 0
    case .keyword: return 1
    case .integer: return 2
    case .float: return 3
    case .geo: return 4
    case .text: return 5
    case .bool: return 6
    case .datetime: return 7
    case .uuid: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_PayloadSchemaType] = [
    .unknownType,
    .keyword,
    .integer,
    .float,
    .geo,
    .text,
    .bool,
    .datetime,
    .uuid,
  ]

}

public enum Qdrant_QuantizationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownQuantization // = 0
  case int8 // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownQuantization
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownQuantization
    case 1: self = .int8
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownQuantization: return 0
    case .int8: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_QuantizationType] = [
    .unknownQuantization,
    .int8,
  ]

}

public enum Qdrant_CompressionRatio: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case x4 // = 0
  case x8 // = 1
  case x16 // = 2
  case x32 // = 3
  case x64 // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .x4
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .x4
    case 1: self = .x8
    case 2: self = .x16
    case 3: self = .x32
    case 4: self = .x64
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .x4: return 0
    case .x8: return 1
    case .x16: return 2
    case .x32: return 3
    case .x64: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_CompressionRatio] = [
    .x4,
    .x8,
    .x16,
    .x32,
    .x64,
  ]

}

public enum Qdrant_BinaryQuantizationEncoding: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case oneBit // = 0
  case twoBits // = 1
  case oneAndHalfBits // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .oneBit
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .oneBit
    case 1: self = .twoBits
    case 2: self = .oneAndHalfBits
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .oneBit: return 0
    case .twoBits: return 1
    case .oneAndHalfBits: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_BinaryQuantizationEncoding] = [
    .oneBit,
    .twoBits,
    .oneAndHalfBits,
  ]

}

public enum Qdrant_ShardingMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Auto-sharding based on record ids
  case auto // = 0

  /// Shard by user-defined key
  case custom // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .auto
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .auto
    case 1: self = .custom
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .auto: return 0
    case .custom: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_ShardingMethod] = [
    .auto,
    .custom,
  ]

}

public enum Qdrant_TokenizerType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case prefix // = 1
  case whitespace // = 2
  case word // = 3
  case multilingual // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .prefix
    case 2: self = .whitespace
    case 3: self = .word
    case 4: self = .multilingual
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .prefix: return 1
    case .whitespace: return 2
    case .word: return 3
    case .multilingual: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_TokenizerType] = [
    .unknown,
    .prefix,
    .whitespace,
    .word,
    .multilingual,
  ]

}

public enum Qdrant_ReplicaState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Active and sound
  case active // = 0

  /// Failed for some reason
  case dead // = 1

  /// The shard is partially loaded and is currently receiving data from other shards
  case partial // = 2

  /// Collection is being created
  case initializing // = 3

  /// A shard which receives data, but is not used for search.
  /// Useful for backup shards.
  case listener // = 4

  /// Deprecated: snapshot shard transfer is in progress.
  /// Updates should not be sent to (and are ignored by) the shard.
  case partialSnapshot // = 5

  /// Shard is undergoing recovery by an external node.
  /// Normally rejects updates, accepts updates if force is true.
  case recovery // = 6

  /// Points are being migrated to this shard as part of scale-up resharding
  case resharding // = 7

  /// Points are being migrated to this shard as part of scale-down resharding
  case reshardingScaleDown // = 8

  /// Active for readers, Partial for writers
  case activeRead // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .active
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .active
    case 1: self = .dead
    case 2: self = .partial
    case 3: self = .initializing
    case 4: self = .listener
    case 5: self = .partialSnapshot
    case 6: self = .recovery
    case 7: self = .resharding
    case 8: self = .reshardingScaleDown
    case 9: self = .activeRead
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .active: return 0
    case .dead: return 1
    case .partial: return 2
    case .initializing: return 3
    case .listener: return 4
    case .partialSnapshot: return 5
    case .recovery: return 6
    case .resharding: return 7
    case .reshardingScaleDown: return 8
    case .activeRead: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_ReplicaState] = [
    .active,
    .dead,
    .partial,
    .initializing,
    .listener,
    .partialSnapshot,
    .recovery,
    .resharding,
    .reshardingScaleDown,
    .activeRead,
  ]

}

/// Resharding direction, scale up or down in number of shards
public enum Qdrant_ReshardingDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Scale up, add a new shard
  case up // = 0

  /// Scale down, remove a shard
  case down // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .up
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .up
    case 1: self = .down
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .up: return 0
    case .down: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_ReshardingDirection] = [
    .up,
    .down,
  ]

}

public enum Qdrant_ShardTransferMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Stream shard records in batches
  case streamRecords // = 0

  /// Snapshot the shard and recover it on the target peer
  case snapshot // = 1

  /// Resolve WAL delta between peers and transfer the difference
  case walDelta // = 2

  /// Stream shard records in batches for resharding
  case reshardingStreamRecords // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .streamRecords
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .streamRecords
    case 1: self = .snapshot
    case 2: self = .walDelta
    case 3: self = .reshardingStreamRecords
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .streamRecords: return 0
    case .snapshot: return 1
    case .walDelta: return 2
    case .reshardingStreamRecords: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_ShardTransferMethod] = [
    .streamRecords,
    .snapshot,
    .walDelta,
    .reshardingStreamRecords,
  ]

}

public struct Qdrant_VectorParams: Sendable {

  /// Size of the vectors
  public var size: UInt64 = 0

  /// Distance function used for comparing vectors
  public var distance: Qdrant_Distance = .unknownDistance

  /// Configuration of vector HNSW graph.
  /// If omitted - the collection configuration will be used
  public var hnswConfig: Qdrant_HnswConfigDiff {
    get {return _hnswConfig ?? Qdrant_HnswConfigDiff()}
    set {_hnswConfig = newValue}
  }
  public var hasHnswConfig: Bool {return self._hnswConfig != nil}
  public mutating func clearHnswConfig() {self._hnswConfig = nil}

  /// Configuration of vector quantization config.
  /// If omitted - the collection configuration will be used
  public var quantizationConfig: Qdrant_QuantizationConfig {
    get {return _quantizationConfig ?? Qdrant_QuantizationConfig()}
    set {_quantizationConfig = newValue}
  }
  public var hasQuantizationConfig: Bool {return self._quantizationConfig != nil}
  public mutating func clearQuantizationConfig() {self._quantizationConfig = nil}

  /// If true - serve vectors from disk.
  /// If set to false, the vectors will be loaded in RAM.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  /// Data type of the vectors
  public var datatype: Qdrant_Datatype {
    get {return _datatype ?? .default}
    set {_datatype = newValue}
  }
  public var hasDatatype: Bool {return self._datatype != nil}
  public mutating func clearDatatype() {self._datatype = nil}

  /// Configuration for multi-vector search
  public var multivectorConfig: Qdrant_MultiVectorConfig {
    get {return _multivectorConfig ?? Qdrant_MultiVectorConfig()}
    set {_multivectorConfig = newValue}
  }
  public var hasMultivectorConfig: Bool {return self._multivectorConfig != nil}
  public mutating func clearMultivectorConfig() {self._multivectorConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hnswConfig: Qdrant_HnswConfigDiff? = nil
  fileprivate var _quantizationConfig: Qdrant_QuantizationConfig? = nil
  fileprivate var _onDisk: Bool? = nil
  fileprivate var _datatype: Qdrant_Datatype? = nil
  fileprivate var _multivectorConfig: Qdrant_MultiVectorConfig? = nil
}

public struct Qdrant_VectorParamsDiff: Sendable {

  /// Update params for HNSW index.
  /// If empty object - it will be unset
  public var hnswConfig: Qdrant_HnswConfigDiff {
    get {return _hnswConfig ?? Qdrant_HnswConfigDiff()}
    set {_hnswConfig = newValue}
  }
  public var hasHnswConfig: Bool {return self._hnswConfig != nil}
  public mutating func clearHnswConfig() {self._hnswConfig = nil}

  /// Update quantization params. If none - it is left unchanged.
  public var quantizationConfig: Qdrant_QuantizationConfigDiff {
    get {return _quantizationConfig ?? Qdrant_QuantizationConfigDiff()}
    set {_quantizationConfig = newValue}
  }
  public var hasQuantizationConfig: Bool {return self._quantizationConfig != nil}
  public mutating func clearQuantizationConfig() {self._quantizationConfig = nil}

  /// If true - serve vectors from disk.
  /// If set to false, the vectors will be loaded in RAM.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hnswConfig: Qdrant_HnswConfigDiff? = nil
  fileprivate var _quantizationConfig: Qdrant_QuantizationConfigDiff? = nil
  fileprivate var _onDisk: Bool? = nil
}

public struct Qdrant_VectorParamsMap: Sendable {

  public var map: Dictionary<String,Qdrant_VectorParams> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_VectorParamsDiffMap: Sendable {

  public var map: Dictionary<String,Qdrant_VectorParamsDiff> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_VectorsConfig: Sendable {

  public var config: Qdrant_VectorsConfig.OneOf_Config? = nil

  public var params: Qdrant_VectorParams {
    get {
      if case .params(let v)? = config {return v}
      return Qdrant_VectorParams()
    }
    set {config = .params(newValue)}
  }

  public var paramsMap: Qdrant_VectorParamsMap {
    get {
      if case .paramsMap(let v)? = config {return v}
      return Qdrant_VectorParamsMap()
    }
    set {config = .paramsMap(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Config: Equatable, Sendable {
    case params(Qdrant_VectorParams)
    case paramsMap(Qdrant_VectorParamsMap)

  }

  public init() {}
}

public struct Qdrant_VectorsConfigDiff: Sendable {

  public var config: Qdrant_VectorsConfigDiff.OneOf_Config? = nil

  public var params: Qdrant_VectorParamsDiff {
    get {
      if case .params(let v)? = config {return v}
      return Qdrant_VectorParamsDiff()
    }
    set {config = .params(newValue)}
  }

  public var paramsMap: Qdrant_VectorParamsDiffMap {
    get {
      if case .paramsMap(let v)? = config {return v}
      return Qdrant_VectorParamsDiffMap()
    }
    set {config = .paramsMap(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Config: Equatable, Sendable {
    case params(Qdrant_VectorParamsDiff)
    case paramsMap(Qdrant_VectorParamsDiffMap)

  }

  public init() {}
}

public struct Qdrant_SparseVectorParams: Sendable {

  /// Configuration of sparse index
  public var index: Qdrant_SparseIndexConfig {
    get {return _index ?? Qdrant_SparseIndexConfig()}
    set {_index = newValue}
  }
  public var hasIndex: Bool {return self._index != nil}
  public mutating func clearIndex() {self._index = nil}

  /// If set - apply modifier to the vector values
  public var modifier: Qdrant_Modifier {
    get {return _modifier ?? .none}
    set {_modifier = newValue}
  }
  public var hasModifier: Bool {return self._modifier != nil}
  public mutating func clearModifier() {self._modifier = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _index: Qdrant_SparseIndexConfig? = nil
  fileprivate var _modifier: Qdrant_Modifier? = nil
}

public struct Qdrant_SparseVectorConfig: Sendable {

  public var map: Dictionary<String,Qdrant_SparseVectorParams> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_MultiVectorConfig: Sendable {

  /// Comparator for multi-vector search
  public var comparator: Qdrant_MultiVectorComparator = .maxSim

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_GetCollectionInfoRequest: Sendable {

  /// Name of the collection
  public var collectionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CollectionExistsRequest: Sendable {

  public var collectionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CollectionExists: Sendable {

  public var exists: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CollectionExistsResponse: Sendable {

  public var result: Qdrant_CollectionExists {
    get {return _result ?? Qdrant_CollectionExists()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_CollectionExists? = nil
}

public struct Qdrant_ListCollectionsRequest: Sendable {

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CollectionDescription: Sendable {

  /// Name of the collection
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_GetCollectionInfoResponse: Sendable {

  public var result: Qdrant_CollectionInfo {
    get {return _result ?? Qdrant_CollectionInfo()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_CollectionInfo? = nil
}

public struct Qdrant_ListCollectionsResponse: Sendable {
  public var collections: [Qdrant_CollectionDescription] = []

  /// Time spent to process
  public var time: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_MaxOptimizationThreads: Sendable {
  public var variant: Qdrant_MaxOptimizationThreads.OneOf_Variant? = nil

  public var value: UInt64 {
    get {
      if case .value(let v)? = variant {return v}
      return 0
    }
    set {variant = .value(newValue)}
  }

  public var setting: Qdrant_MaxOptimizationThreads.Setting {
    get {
      if case .setting(let v)? = variant {return v}
      return .auto
    }
    set {variant = .setting(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable, Sendable {
    case value(UInt64)
    case setting(Qdrant_MaxOptimizationThreads.Setting)

  }

  public enum Setting: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case auto // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .auto
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .auto
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .auto: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

      public static let allCases: [Qdrant_MaxOptimizationThreads.Setting] = [
      .auto,
    ]

  }

  public init() {}
}

public struct Qdrant_OptimizerStatus: Sendable {
  public var ok: Bool = false

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CollectionWarning: Sendable {
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_HnswConfigDiff: Sendable {
  /// Number of edges per node in the index graph.
  /// Larger the value - more accurate the search, more space required.
  public var m: UInt64 {
    get {return _m ?? 0}
    set {_m = newValue}
  }
  public var hasM: Bool {return self._m != nil}
  public mutating func clearM() {self._m = nil}

  /// Number of neighbours to consider during the index building.
  /// Larger the value - more accurate the search, more time required to build the index.
  public var efConstruct: UInt64 {
    get {return _efConstruct ?? 0}
    set {_efConstruct = newValue}
  }
  public var hasEfConstruct: Bool {return self._efConstruct != nil}
  public mutating func clearEfConstruct() {self._efConstruct = nil}

  /// Minimal size threshold (in KiloBytes) below which full-scan is preferred over HNSW search.
  /// This measures the total size of vectors being queried against.
  /// When the maximum estimated amount of points that a condition satisfies is smaller than
  /// `full_scan_threshold`, the query planner will use full-scan search instead of HNSW index
  /// traversal for better performance.
  /// Note: 1Kb = 1 vector of size 256
  public var fullScanThreshold: UInt64 {
    get {return _fullScanThreshold ?? 0}
    set {_fullScanThreshold = newValue}
  }
  public var hasFullScanThreshold: Bool {return self._fullScanThreshold != nil}
  public mutating func clearFullScanThreshold() {self._fullScanThreshold = nil}

  /// Number of parallel threads used for background index building.
  /// If 0 - automatically select from 8 to 16.
  /// Best to keep between 8 and 16 to prevent likelihood of building broken/inefficient HNSW graphs.
  /// On small CPUs, less threads are used.
  public var maxIndexingThreads: UInt64 {
    get {return _maxIndexingThreads ?? 0}
    set {_maxIndexingThreads = newValue}
  }
  public var hasMaxIndexingThreads: Bool {return self._maxIndexingThreads != nil}
  public mutating func clearMaxIndexingThreads() {self._maxIndexingThreads = nil}

  /// Store HNSW index on disk. If set to false, the index will be stored in RAM.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  /// Number of additional payload-aware links per node in the index graph.
  /// If not set - regular M parameter will be used.
  public var payloadM: UInt64 {
    get {return _payloadM ?? 0}
    set {_payloadM = newValue}
  }
  public var hasPayloadM: Bool {return self._payloadM != nil}
  public mutating func clearPayloadM() {self._payloadM = nil}

  /// Store copies of original and quantized vectors within the HNSW index file. Default: false.
  /// Enabling this option will trade the search speed for disk usage by reducing amount of
  /// random seeks during the search.
  /// Requires quantized vectors to be enabled. Multi-vectors are not supported.
  public var inlineStorage: Bool {
    get {return _inlineStorage ?? false}
    set {_inlineStorage = newValue}
  }
  public var hasInlineStorage: Bool {return self._inlineStorage != nil}
  public mutating func clearInlineStorage() {self._inlineStorage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _m: UInt64? = nil
  fileprivate var _efConstruct: UInt64? = nil
  fileprivate var _fullScanThreshold: UInt64? = nil
  fileprivate var _maxIndexingThreads: UInt64? = nil
  fileprivate var _onDisk: Bool? = nil
  fileprivate var _payloadM: UInt64? = nil
  fileprivate var _inlineStorage: Bool? = nil
}

public struct Qdrant_SparseIndexConfig: Sendable {
  /// Prefer a full scan search upto (excluding) this number of vectors.
  /// Note: this is number of vectors, not KiloBytes.
  public var fullScanThreshold: UInt64 {
    get {return _fullScanThreshold ?? 0}
    set {_fullScanThreshold = newValue}
  }
  public var hasFullScanThreshold: Bool {return self._fullScanThreshold != nil}
  public mutating func clearFullScanThreshold() {self._fullScanThreshold = nil}

  /// Store inverted index on disk. If set to false, the index will be stored in RAM.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  /// Datatype used to store weights in the index.
  public var datatype: Qdrant_Datatype {
    get {return _datatype ?? .default}
    set {_datatype = newValue}
  }
  public var hasDatatype: Bool {return self._datatype != nil}
  public mutating func clearDatatype() {self._datatype = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fullScanThreshold: UInt64? = nil
  fileprivate var _onDisk: Bool? = nil
  fileprivate var _datatype: Qdrant_Datatype? = nil
}

public struct Qdrant_WalConfigDiff: Sendable {
  /// Size of a single WAL block file
  public var walCapacityMb: UInt64 {
    get {return _walCapacityMb ?? 0}
    set {_walCapacityMb = newValue}
  }
  public var hasWalCapacityMb: Bool {return self._walCapacityMb != nil}
  public mutating func clearWalCapacityMb() {self._walCapacityMb = nil}

  /// Number of segments to create in advance
  public var walSegmentsAhead: UInt64 {
    get {return _walSegmentsAhead ?? 0}
    set {_walSegmentsAhead = newValue}
  }
  public var hasWalSegmentsAhead: Bool {return self._walSegmentsAhead != nil}
  public mutating func clearWalSegmentsAhead() {self._walSegmentsAhead = nil}

  /// Number of closed segments to retain
  public var walRetainClosed: UInt64 {
    get {return _walRetainClosed ?? 0}
    set {_walRetainClosed = newValue}
  }
  public var hasWalRetainClosed: Bool {return self._walRetainClosed != nil}
  public mutating func clearWalRetainClosed() {self._walRetainClosed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _walCapacityMb: UInt64? = nil
  fileprivate var _walSegmentsAhead: UInt64? = nil
  fileprivate var _walRetainClosed: UInt64? = nil
}

public struct Qdrant_OptimizersConfigDiff: Sendable {
  /// The minimal fraction of deleted vectors in a segment, required to perform
  /// segment optimization
  public var deletedThreshold: Double {
    get {return _deletedThreshold ?? 0}
    set {_deletedThreshold = newValue}
  }
  public var hasDeletedThreshold: Bool {return self._deletedThreshold != nil}
  public mutating func clearDeletedThreshold() {self._deletedThreshold = nil}

  /// The minimal number of vectors in a segment, required to perform segment
  /// optimization
  public var vacuumMinVectorNumber: UInt64 {
    get {return _vacuumMinVectorNumber ?? 0}
    set {_vacuumMinVectorNumber = newValue}
  }
  public var hasVacuumMinVectorNumber: Bool {return self._vacuumMinVectorNumber != nil}
  public mutating func clearVacuumMinVectorNumber() {self._vacuumMinVectorNumber = nil}

  /// Target amount of segments the optimizer will try to keep.
  /// Real amount of segments may vary depending on multiple parameters:
  ///
  /// - Amount of stored points.
  /// - Current write RPS.
  ///
  /// It is recommended to select the default number of segments as a factor of the number of search threads,
  /// so that each segment would be handled evenly by one of the threads.
  public var defaultSegmentNumber: UInt64 {
    get {return _defaultSegmentNumber ?? 0}
    set {_defaultSegmentNumber = newValue}
  }
  public var hasDefaultSegmentNumber: Bool {return self._defaultSegmentNumber != nil}
  public mutating func clearDefaultSegmentNumber() {self._defaultSegmentNumber = nil}

  /// Deprecated:
  ///
  /// Do not create segments larger this size (in kilobytes).
  /// Large segments might require disproportionately long indexation times,
  /// therefore it makes sense to limit the size of segments.
  ///
  /// If indexing speed is more important - make this parameter lower.
  /// If search speed is more important - make this parameter higher.
  /// Note: 1Kb = 1 vector of size 256
  /// If not set, will be automatically selected considering the number of available CPUs.
  public var maxSegmentSize: UInt64 {
    get {return _maxSegmentSize ?? 0}
    set {_maxSegmentSize = newValue}
  }
  public var hasMaxSegmentSize: Bool {return self._maxSegmentSize != nil}
  public mutating func clearMaxSegmentSize() {self._maxSegmentSize = nil}

  /// Maximum size (in kilobytes) of vectors to store in-memory per segment.
  /// Segments larger than this threshold will be stored as read-only memmapped file.
  ///
  /// Memmap storage is disabled by default, to enable it, set this threshold to a reasonable value.
  ///
  /// To disable memmap storage, set this to `0`.
  ///
  /// Note: 1Kb = 1 vector of size 256
  public var memmapThreshold: UInt64 {
    get {return _memmapThreshold ?? 0}
    set {_memmapThreshold = newValue}
  }
  public var hasMemmapThreshold: Bool {return self._memmapThreshold != nil}
  public mutating func clearMemmapThreshold() {self._memmapThreshold = nil}

  /// Maximum size (in kilobytes) of vectors allowed for plain index, exceeding
  /// this threshold will enable vector indexing
  ///
  /// Default value is 20,000, based on
  /// <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.
  ///
  /// To disable vector indexing, set to `0`.
  ///
  /// Note: 1kB = 1 vector of size 256.
  public var indexingThreshold: UInt64 {
    get {return _indexingThreshold ?? 0}
    set {_indexingThreshold = newValue}
  }
  public var hasIndexingThreshold: Bool {return self._indexingThreshold != nil}
  public mutating func clearIndexingThreshold() {self._indexingThreshold = nil}

  /// Interval between forced flushes.
  public var flushIntervalSec: UInt64 {
    get {return _flushIntervalSec ?? 0}
    set {_flushIntervalSec = newValue}
  }
  public var hasFlushIntervalSec: Bool {return self._flushIntervalSec != nil}
  public mutating func clearFlushIntervalSec() {self._flushIntervalSec = nil}

  /// Deprecated in favor of `max_optimization_threads`
  public var deprecatedMaxOptimizationThreads: UInt64 {
    get {return _deprecatedMaxOptimizationThreads ?? 0}
    set {_deprecatedMaxOptimizationThreads = newValue}
  }
  public var hasDeprecatedMaxOptimizationThreads: Bool {return self._deprecatedMaxOptimizationThreads != nil}
  public mutating func clearDeprecatedMaxOptimizationThreads() {self._deprecatedMaxOptimizationThreads = nil}

  /// Max number of threads (jobs) for running optimizations per shard.
  /// Note: each optimization job will also use `max_indexing_threads` threads by itself for index building.
  /// If "auto" - have no limit and choose dynamically to saturate CPU.
  /// If 0 - no optimization threads, optimizations will be disabled.
  public var maxOptimizationThreads: Qdrant_MaxOptimizationThreads {
    get {return _maxOptimizationThreads ?? Qdrant_MaxOptimizationThreads()}
    set {_maxOptimizationThreads = newValue}
  }
  public var hasMaxOptimizationThreads: Bool {return self._maxOptimizationThreads != nil}
  public mutating func clearMaxOptimizationThreads() {self._maxOptimizationThreads = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deletedThreshold: Double? = nil
  fileprivate var _vacuumMinVectorNumber: UInt64? = nil
  fileprivate var _defaultSegmentNumber: UInt64? = nil
  fileprivate var _maxSegmentSize: UInt64? = nil
  fileprivate var _memmapThreshold: UInt64? = nil
  fileprivate var _indexingThreshold: UInt64? = nil
  fileprivate var _flushIntervalSec: UInt64? = nil
  fileprivate var _deprecatedMaxOptimizationThreads: UInt64? = nil
  fileprivate var _maxOptimizationThreads: Qdrant_MaxOptimizationThreads? = nil
}

public struct Qdrant_ScalarQuantization: Sendable {
  /// Type of quantization
  public var type: Qdrant_QuantizationType = .unknownQuantization

  /// Number of bits to use for quantization
  public var quantile: Float {
    get {return _quantile ?? 0}
    set {_quantile = newValue}
  }
  public var hasQuantile: Bool {return self._quantile != nil}
  public mutating func clearQuantile() {self._quantile = nil}

  /// If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
  public var alwaysRam: Bool {
    get {return _alwaysRam ?? false}
    set {_alwaysRam = newValue}
  }
  public var hasAlwaysRam: Bool {return self._alwaysRam != nil}
  public mutating func clearAlwaysRam() {self._alwaysRam = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _quantile: Float? = nil
  fileprivate var _alwaysRam: Bool? = nil
}

public struct Qdrant_ProductQuantization: Sendable {
  /// Compression ratio
  public var compression: Qdrant_CompressionRatio = .x4

  /// If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
  public var alwaysRam: Bool {
    get {return _alwaysRam ?? false}
    set {_alwaysRam = newValue}
  }
  public var hasAlwaysRam: Bool {return self._alwaysRam != nil}
  public mutating func clearAlwaysRam() {self._alwaysRam = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _alwaysRam: Bool? = nil
}

public struct Qdrant_BinaryQuantizationQueryEncoding: Sendable {
  public var variant: Qdrant_BinaryQuantizationQueryEncoding.OneOf_Variant? = nil

  public var setting: Qdrant_BinaryQuantizationQueryEncoding.Setting {
    get {
      if case .setting(let v)? = variant {return v}
      return .default
    }
    set {variant = .setting(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable, Sendable {
    case setting(Qdrant_BinaryQuantizationQueryEncoding.Setting)

  }

  public enum Setting: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case `default` // = 0
    case binary // = 1
    case scalar4Bits // = 2
    case scalar8Bits // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .binary
      case 2: self = .scalar4Bits
      case 3: self = .scalar8Bits
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .binary: return 1
      case .scalar4Bits: return 2
      case .scalar8Bits: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

      public static let allCases: [Qdrant_BinaryQuantizationQueryEncoding.Setting] = [
      .default,
      .binary,
      .scalar4Bits,
      .scalar8Bits,
    ]

  }

  public init() {}
}

public struct Qdrant_BinaryQuantization: Sendable {
  /// If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
  public var alwaysRam: Bool {
    get {return _alwaysRam ?? false}
    set {_alwaysRam = newValue}
  }
  public var hasAlwaysRam: Bool {return self._alwaysRam != nil}
  public mutating func clearAlwaysRam() {self._alwaysRam = nil}

  /// Binary quantization encoding method
  public var encoding: Qdrant_BinaryQuantizationEncoding {
    get {return _encoding ?? .oneBit}
    set {_encoding = newValue}
  }
  public var hasEncoding: Bool {return self._encoding != nil}
  public mutating func clearEncoding() {self._encoding = nil}

  /// Asymmetric quantization configuration allows a query to have different
  /// quantization than stored vectors.
  /// It can increase the accuracy of search at the cost of performance.
  public var queryEncoding: Qdrant_BinaryQuantizationQueryEncoding {
    get {return _queryEncoding ?? Qdrant_BinaryQuantizationQueryEncoding()}
    set {_queryEncoding = newValue}
  }
  public var hasQueryEncoding: Bool {return self._queryEncoding != nil}
  public mutating func clearQueryEncoding() {self._queryEncoding = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _alwaysRam: Bool? = nil
  fileprivate var _encoding: Qdrant_BinaryQuantizationEncoding? = nil
  fileprivate var _queryEncoding: Qdrant_BinaryQuantizationQueryEncoding? = nil
}

public struct Qdrant_QuantizationConfig: Sendable {
  public var quantization: Qdrant_QuantizationConfig.OneOf_Quantization? = nil

  public var scalar: Qdrant_ScalarQuantization {
    get {
      if case .scalar(let v)? = quantization {return v}
      return Qdrant_ScalarQuantization()
    }
    set {quantization = .scalar(newValue)}
  }

  public var product: Qdrant_ProductQuantization {
    get {
      if case .product(let v)? = quantization {return v}
      return Qdrant_ProductQuantization()
    }
    set {quantization = .product(newValue)}
  }

  public var binary: Qdrant_BinaryQuantization {
    get {
      if case .binary(let v)? = quantization {return v}
      return Qdrant_BinaryQuantization()
    }
    set {quantization = .binary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Quantization: Equatable, Sendable {
    case scalar(Qdrant_ScalarQuantization)
    case product(Qdrant_ProductQuantization)
    case binary(Qdrant_BinaryQuantization)

  }

  public init() {}
}

public struct Qdrant_Disabled: Sendable {
  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_QuantizationConfigDiff: Sendable {
  public var quantization: Qdrant_QuantizationConfigDiff.OneOf_Quantization? = nil

  public var scalar: Qdrant_ScalarQuantization {
    get {
      if case .scalar(let v)? = quantization {return v}
      return Qdrant_ScalarQuantization()
    }
    set {quantization = .scalar(newValue)}
  }

  public var product: Qdrant_ProductQuantization {
    get {
      if case .product(let v)? = quantization {return v}
      return Qdrant_ProductQuantization()
    }
    set {quantization = .product(newValue)}
  }

  public var disabled: Qdrant_Disabled {
    get {
      if case .disabled(let v)? = quantization {return v}
      return Qdrant_Disabled()
    }
    set {quantization = .disabled(newValue)}
  }

  public var binary: Qdrant_BinaryQuantization {
    get {
      if case .binary(let v)? = quantization {return v}
      return Qdrant_BinaryQuantization()
    }
    set {quantization = .binary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Quantization: Equatable, Sendable {
    case scalar(Qdrant_ScalarQuantization)
    case product(Qdrant_ProductQuantization)
    case disabled(Qdrant_Disabled)
    case binary(Qdrant_BinaryQuantization)

  }

  public init() {}
}

public struct Qdrant_StrictModeConfig: @unchecked Sendable {
  /// Whether strict mode is enabled for a collection or not.
  public var enabled: Bool {
    get {return _storage._enabled ?? false}
    set {_uniqueStorage()._enabled = newValue}
  }
  public var hasEnabled: Bool {return _storage._enabled != nil}
  public mutating func clearEnabled() {_uniqueStorage()._enabled = nil}

  /// Max allowed `limit` parameter for all APIs that don't have their own max limit.
  public var maxQueryLimit: UInt32 {
    get {return _storage._maxQueryLimit ?? 0}
    set {_uniqueStorage()._maxQueryLimit = newValue}
  }
  public var hasMaxQueryLimit: Bool {return _storage._maxQueryLimit != nil}
  public mutating func clearMaxQueryLimit() {_uniqueStorage()._maxQueryLimit = nil}

  /// Max allowed `timeout` parameter.
  public var maxTimeout: UInt32 {
    get {return _storage._maxTimeout ?? 0}
    set {_uniqueStorage()._maxTimeout = newValue}
  }
  public var hasMaxTimeout: Bool {return _storage._maxTimeout != nil}
  public mutating func clearMaxTimeout() {_uniqueStorage()._maxTimeout = nil}

  /// Allow usage of unindexed fields in retrieval based (e.g. search) filters.
  public var unindexedFilteringRetrieve: Bool {
    get {return _storage._unindexedFilteringRetrieve ?? false}
    set {_uniqueStorage()._unindexedFilteringRetrieve = newValue}
  }
  public var hasUnindexedFilteringRetrieve: Bool {return _storage._unindexedFilteringRetrieve != nil}
  public mutating func clearUnindexedFilteringRetrieve() {_uniqueStorage()._unindexedFilteringRetrieve = nil}

  /// Allow usage of unindexed fields in filtered updates (e.g. delete by payload).
  public var unindexedFilteringUpdate: Bool {
    get {return _storage._unindexedFilteringUpdate ?? false}
    set {_uniqueStorage()._unindexedFilteringUpdate = newValue}
  }
  public var hasUnindexedFilteringUpdate: Bool {return _storage._unindexedFilteringUpdate != nil}
  public mutating func clearUnindexedFilteringUpdate() {_uniqueStorage()._unindexedFilteringUpdate = nil}

  /// Max HNSW ef value allowed in search parameters.
  public var searchMaxHnswEf: UInt32 {
    get {return _storage._searchMaxHnswEf ?? 0}
    set {_uniqueStorage()._searchMaxHnswEf = newValue}
  }
  public var hasSearchMaxHnswEf: Bool {return _storage._searchMaxHnswEf != nil}
  public mutating func clearSearchMaxHnswEf() {_uniqueStorage()._searchMaxHnswEf = nil}

  /// Whether exact search is allowed.
  public var searchAllowExact: Bool {
    get {return _storage._searchAllowExact ?? false}
    set {_uniqueStorage()._searchAllowExact = newValue}
  }
  public var hasSearchAllowExact: Bool {return _storage._searchAllowExact != nil}
  public mutating func clearSearchAllowExact() {_uniqueStorage()._searchAllowExact = nil}

  /// Max oversampling value allowed in search
  public var searchMaxOversampling: Float {
    get {return _storage._searchMaxOversampling ?? 0}
    set {_uniqueStorage()._searchMaxOversampling = newValue}
  }
  public var hasSearchMaxOversampling: Bool {return _storage._searchMaxOversampling != nil}
  public mutating func clearSearchMaxOversampling() {_uniqueStorage()._searchMaxOversampling = nil}

  /// Max batchsize when upserting
  public var upsertMaxBatchsize: UInt64 {
    get {return _storage._upsertMaxBatchsize ?? 0}
    set {_uniqueStorage()._upsertMaxBatchsize = newValue}
  }
  public var hasUpsertMaxBatchsize: Bool {return _storage._upsertMaxBatchsize != nil}
  public mutating func clearUpsertMaxBatchsize() {_uniqueStorage()._upsertMaxBatchsize = nil}

  /// Max size of a collections vector storage in bytes, ignoring replicas.
  public var maxCollectionVectorSizeBytes: UInt64 {
    get {return _storage._maxCollectionVectorSizeBytes ?? 0}
    set {_uniqueStorage()._maxCollectionVectorSizeBytes = newValue}
  }
  public var hasMaxCollectionVectorSizeBytes: Bool {return _storage._maxCollectionVectorSizeBytes != nil}
  public mutating func clearMaxCollectionVectorSizeBytes() {_uniqueStorage()._maxCollectionVectorSizeBytes = nil}

  /// Max number of read operations per minute per replica
  public var readRateLimit: UInt32 {
    get {return _storage._readRateLimit ?? 0}
    set {_uniqueStorage()._readRateLimit = newValue}
  }
  public var hasReadRateLimit: Bool {return _storage._readRateLimit != nil}
  public mutating func clearReadRateLimit() {_uniqueStorage()._readRateLimit = nil}

  /// Max number of write operations per minute per replica
  public var writeRateLimit: UInt32 {
    get {return _storage._writeRateLimit ?? 0}
    set {_uniqueStorage()._writeRateLimit = newValue}
  }
  public var hasWriteRateLimit: Bool {return _storage._writeRateLimit != nil}
  public mutating func clearWriteRateLimit() {_uniqueStorage()._writeRateLimit = nil}

  /// Max size of a collections payload storage in bytes, ignoring replicas.
  public var maxCollectionPayloadSizeBytes: UInt64 {
    get {return _storage._maxCollectionPayloadSizeBytes ?? 0}
    set {_uniqueStorage()._maxCollectionPayloadSizeBytes = newValue}
  }
  public var hasMaxCollectionPayloadSizeBytes: Bool {return _storage._maxCollectionPayloadSizeBytes != nil}
  public mutating func clearMaxCollectionPayloadSizeBytes() {_uniqueStorage()._maxCollectionPayloadSizeBytes = nil}

  /// Max conditions a filter can have.
  public var filterMaxConditions: UInt64 {
    get {return _storage._filterMaxConditions ?? 0}
    set {_uniqueStorage()._filterMaxConditions = newValue}
  }
  public var hasFilterMaxConditions: Bool {return _storage._filterMaxConditions != nil}
  public mutating func clearFilterMaxConditions() {_uniqueStorage()._filterMaxConditions = nil}

  /// Max size of a condition, eg. items in `MatchAny`.
  public var conditionMaxSize: UInt64 {
    get {return _storage._conditionMaxSize ?? 0}
    set {_uniqueStorage()._conditionMaxSize = newValue}
  }
  public var hasConditionMaxSize: Bool {return _storage._conditionMaxSize != nil}
  public mutating func clearConditionMaxSize() {_uniqueStorage()._conditionMaxSize = nil}

  /// Multivector strict mode configuration
  public var multivectorConfig: Qdrant_StrictModeMultivectorConfig {
    get {return _storage._multivectorConfig ?? Qdrant_StrictModeMultivectorConfig()}
    set {_uniqueStorage()._multivectorConfig = newValue}
  }
  public var hasMultivectorConfig: Bool {return _storage._multivectorConfig != nil}
  public mutating func clearMultivectorConfig() {_uniqueStorage()._multivectorConfig = nil}

  /// Sparse vector strict mode configuration
  public var sparseConfig: Qdrant_StrictModeSparseConfig {
    get {return _storage._sparseConfig ?? Qdrant_StrictModeSparseConfig()}
    set {_uniqueStorage()._sparseConfig = newValue}
  }
  public var hasSparseConfig: Bool {return _storage._sparseConfig != nil}
  public mutating func clearSparseConfig() {_uniqueStorage()._sparseConfig = nil}

  /// Max number of points estimated in a collection
  public var maxPointsCount: UInt64 {
    get {return _storage._maxPointsCount ?? 0}
    set {_uniqueStorage()._maxPointsCount = newValue}
  }
  public var hasMaxPointsCount: Bool {return _storage._maxPointsCount != nil}
  public mutating func clearMaxPointsCount() {_uniqueStorage()._maxPointsCount = nil}

  /// Max number of payload indexes in a collection
  public var maxPayloadIndexCount: UInt64 {
    get {return _storage._maxPayloadIndexCount ?? 0}
    set {_uniqueStorage()._maxPayloadIndexCount = newValue}
  }
  public var hasMaxPayloadIndexCount: Bool {return _storage._maxPayloadIndexCount != nil}
  public mutating func clearMaxPayloadIndexCount() {_uniqueStorage()._maxPayloadIndexCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_StrictModeSparseConfig: Sendable {
  public var sparseConfig: Dictionary<String,Qdrant_StrictModeSparse> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_StrictModeSparse: Sendable {
  /// Max length of sparse vector
  public var maxLength: UInt64 {
    get {return _maxLength ?? 0}
    set {_maxLength = newValue}
  }
  public var hasMaxLength: Bool {return self._maxLength != nil}
  public mutating func clearMaxLength() {self._maxLength = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxLength: UInt64? = nil
}

public struct Qdrant_StrictModeMultivectorConfig: Sendable {
  public var multivectorConfig: Dictionary<String,Qdrant_StrictModeMultivector> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_StrictModeMultivector: Sendable {
  /// Max number of vectors in a multivector
  public var maxVectors: UInt64 {
    get {return _maxVectors ?? 0}
    set {_maxVectors = newValue}
  }
  public var hasMaxVectors: Bool {return self._maxVectors != nil}
  public mutating func clearMaxVectors() {self._maxVectors = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxVectors: UInt64? = nil
}

public struct Qdrant_CreateCollection: @unchecked Sendable {
  /// Name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// Configuration of vector index
  public var hnswConfig: Qdrant_HnswConfigDiff {
    get {return _storage._hnswConfig ?? Qdrant_HnswConfigDiff()}
    set {_uniqueStorage()._hnswConfig = newValue}
  }
  public var hasHnswConfig: Bool {return _storage._hnswConfig != nil}
  public mutating func clearHnswConfig() {_uniqueStorage()._hnswConfig = nil}

  /// Configuration of the Write-Ahead-Log
  public var walConfig: Qdrant_WalConfigDiff {
    get {return _storage._walConfig ?? Qdrant_WalConfigDiff()}
    set {_uniqueStorage()._walConfig = newValue}
  }
  public var hasWalConfig: Bool {return _storage._walConfig != nil}
  public mutating func clearWalConfig() {_uniqueStorage()._walConfig = nil}

  /// Configuration of the optimizers
  public var optimizersConfig: Qdrant_OptimizersConfigDiff {
    get {return _storage._optimizersConfig ?? Qdrant_OptimizersConfigDiff()}
    set {_uniqueStorage()._optimizersConfig = newValue}
  }
  public var hasOptimizersConfig: Bool {return _storage._optimizersConfig != nil}
  public mutating func clearOptimizersConfig() {_uniqueStorage()._optimizersConfig = nil}

  /// Number of shards in the collection, default is 1 for standalone, otherwise
  /// equal to the number of nodes. Minimum is 1
  public var shardNumber: UInt32 {
    get {return _storage._shardNumber ?? 0}
    set {_uniqueStorage()._shardNumber = newValue}
  }
  public var hasShardNumber: Bool {return _storage._shardNumber != nil}
  public mutating func clearShardNumber() {_uniqueStorage()._shardNumber = nil}

  /// If true - point's payload will not be stored in memory
  public var onDiskPayload: Bool {
    get {return _storage._onDiskPayload ?? false}
    set {_uniqueStorage()._onDiskPayload = newValue}
  }
  public var hasOnDiskPayload: Bool {return _storage._onDiskPayload != nil}
  public mutating func clearOnDiskPayload() {_uniqueStorage()._onDiskPayload = nil}

  /// Wait timeout for operation commit in seconds, if not specified - default
  /// value will be supplied
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Configuration for vectors
  public var vectorsConfig: Qdrant_VectorsConfig {
    get {return _storage._vectorsConfig ?? Qdrant_VectorsConfig()}
    set {_uniqueStorage()._vectorsConfig = newValue}
  }
  public var hasVectorsConfig: Bool {return _storage._vectorsConfig != nil}
  public mutating func clearVectorsConfig() {_uniqueStorage()._vectorsConfig = nil}

  /// Number of replicas of each shard that network tries to maintain, default = 1
  public var replicationFactor: UInt32 {
    get {return _storage._replicationFactor ?? 0}
    set {_uniqueStorage()._replicationFactor = newValue}
  }
  public var hasReplicationFactor: Bool {return _storage._replicationFactor != nil}
  public mutating func clearReplicationFactor() {_uniqueStorage()._replicationFactor = nil}

  /// How many replicas should apply the operation for us to consider it successful, default = 1
  public var writeConsistencyFactor: UInt32 {
    get {return _storage._writeConsistencyFactor ?? 0}
    set {_uniqueStorage()._writeConsistencyFactor = newValue}
  }
  public var hasWriteConsistencyFactor: Bool {return _storage._writeConsistencyFactor != nil}
  public mutating func clearWriteConsistencyFactor() {_uniqueStorage()._writeConsistencyFactor = nil}

  /// Quantization configuration of vector
  public var quantizationConfig: Qdrant_QuantizationConfig {
    get {return _storage._quantizationConfig ?? Qdrant_QuantizationConfig()}
    set {_uniqueStorage()._quantizationConfig = newValue}
  }
  public var hasQuantizationConfig: Bool {return _storage._quantizationConfig != nil}
  public mutating func clearQuantizationConfig() {_uniqueStorage()._quantizationConfig = nil}

  /// Sharding method
  public var shardingMethod: Qdrant_ShardingMethod {
    get {return _storage._shardingMethod ?? .auto}
    set {_uniqueStorage()._shardingMethod = newValue}
  }
  public var hasShardingMethod: Bool {return _storage._shardingMethod != nil}
  public mutating func clearShardingMethod() {_uniqueStorage()._shardingMethod = nil}

  /// Configuration for sparse vectors
  public var sparseVectorsConfig: Qdrant_SparseVectorConfig {
    get {return _storage._sparseVectorsConfig ?? Qdrant_SparseVectorConfig()}
    set {_uniqueStorage()._sparseVectorsConfig = newValue}
  }
  public var hasSparseVectorsConfig: Bool {return _storage._sparseVectorsConfig != nil}
  public mutating func clearSparseVectorsConfig() {_uniqueStorage()._sparseVectorsConfig = nil}

  /// Configuration for strict mode
  public var strictModeConfig: Qdrant_StrictModeConfig {
    get {return _storage._strictModeConfig ?? Qdrant_StrictModeConfig()}
    set {_uniqueStorage()._strictModeConfig = newValue}
  }
  public var hasStrictModeConfig: Bool {return _storage._strictModeConfig != nil}
  public mutating func clearStrictModeConfig() {_uniqueStorage()._strictModeConfig = nil}

  /// Arbitrary JSON metadata for the collection
  public var metadata: Dictionary<String,Qdrant_Value> {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_UpdateCollection: @unchecked Sendable {
  /// Name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// New configuration parameters for the collection.
  /// This operation is blocking, it will only proceed once all current
  /// optimizations are complete
  public var optimizersConfig: Qdrant_OptimizersConfigDiff {
    get {return _storage._optimizersConfig ?? Qdrant_OptimizersConfigDiff()}
    set {_uniqueStorage()._optimizersConfig = newValue}
  }
  public var hasOptimizersConfig: Bool {return _storage._optimizersConfig != nil}
  public mutating func clearOptimizersConfig() {_uniqueStorage()._optimizersConfig = nil}

  /// Wait timeout for operation commit in seconds if blocking.
  /// If not specified - default value will be supplied.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// New configuration parameters for the collection
  public var params: Qdrant_CollectionParamsDiff {
    get {return _storage._params ?? Qdrant_CollectionParamsDiff()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// New HNSW parameters for the collection index
  public var hnswConfig: Qdrant_HnswConfigDiff {
    get {return _storage._hnswConfig ?? Qdrant_HnswConfigDiff()}
    set {_uniqueStorage()._hnswConfig = newValue}
  }
  public var hasHnswConfig: Bool {return _storage._hnswConfig != nil}
  public mutating func clearHnswConfig() {_uniqueStorage()._hnswConfig = nil}

  /// New vector parameters
  public var vectorsConfig: Qdrant_VectorsConfigDiff {
    get {return _storage._vectorsConfig ?? Qdrant_VectorsConfigDiff()}
    set {_uniqueStorage()._vectorsConfig = newValue}
  }
  public var hasVectorsConfig: Bool {return _storage._vectorsConfig != nil}
  public mutating func clearVectorsConfig() {_uniqueStorage()._vectorsConfig = nil}

  /// Quantization configuration of vector
  public var quantizationConfig: Qdrant_QuantizationConfigDiff {
    get {return _storage._quantizationConfig ?? Qdrant_QuantizationConfigDiff()}
    set {_uniqueStorage()._quantizationConfig = newValue}
  }
  public var hasQuantizationConfig: Bool {return _storage._quantizationConfig != nil}
  public mutating func clearQuantizationConfig() {_uniqueStorage()._quantizationConfig = nil}

  /// New sparse vector parameters
  public var sparseVectorsConfig: Qdrant_SparseVectorConfig {
    get {return _storage._sparseVectorsConfig ?? Qdrant_SparseVectorConfig()}
    set {_uniqueStorage()._sparseVectorsConfig = newValue}
  }
  public var hasSparseVectorsConfig: Bool {return _storage._sparseVectorsConfig != nil}
  public mutating func clearSparseVectorsConfig() {_uniqueStorage()._sparseVectorsConfig = nil}

  /// New strict mode configuration
  public var strictModeConfig: Qdrant_StrictModeConfig {
    get {return _storage._strictModeConfig ?? Qdrant_StrictModeConfig()}
    set {_uniqueStorage()._strictModeConfig = newValue}
  }
  public var hasStrictModeConfig: Bool {return _storage._strictModeConfig != nil}
  public mutating func clearStrictModeConfig() {_uniqueStorage()._strictModeConfig = nil}

  /// Arbitrary JSON-like metadata for the collection, will be merged with
  /// already stored metadata
  public var metadata: Dictionary<String,Qdrant_Value> {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_DeleteCollection: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  /// Wait timeout for operation commit in seconds.
  /// If not specified - default value will be supplied.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_CollectionOperationResponse: Sendable {
  /// if operation made changes
  public var result: Bool = false

  /// Time spent to process
  public var time: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CollectionParams: @unchecked Sendable {
  /// Number of shards in collection
  public var shardNumber: UInt32 {
    get {return _storage._shardNumber}
    set {_uniqueStorage()._shardNumber = newValue}
  }

  /// If true - point's payload will not be stored in memory
  public var onDiskPayload: Bool {
    get {return _storage._onDiskPayload}
    set {_uniqueStorage()._onDiskPayload = newValue}
  }

  /// Configuration for vectors
  public var vectorsConfig: Qdrant_VectorsConfig {
    get {return _storage._vectorsConfig ?? Qdrant_VectorsConfig()}
    set {_uniqueStorage()._vectorsConfig = newValue}
  }
  public var hasVectorsConfig: Bool {return _storage._vectorsConfig != nil}
  public mutating func clearVectorsConfig() {_uniqueStorage()._vectorsConfig = nil}

  /// Number of replicas of each shard that network tries to maintain
  public var replicationFactor: UInt32 {
    get {return _storage._replicationFactor ?? 0}
    set {_uniqueStorage()._replicationFactor = newValue}
  }
  public var hasReplicationFactor: Bool {return _storage._replicationFactor != nil}
  public mutating func clearReplicationFactor() {_uniqueStorage()._replicationFactor = nil}

  /// How many replicas should apply the operation for us to consider it successful
  public var writeConsistencyFactor: UInt32 {
    get {return _storage._writeConsistencyFactor ?? 0}
    set {_uniqueStorage()._writeConsistencyFactor = newValue}
  }
  public var hasWriteConsistencyFactor: Bool {return _storage._writeConsistencyFactor != nil}
  public mutating func clearWriteConsistencyFactor() {_uniqueStorage()._writeConsistencyFactor = nil}

  /// Fan-out every read request to these many additional remote nodes (and return first available response)
  public var readFanOutFactor: UInt32 {
    get {return _storage._readFanOutFactor ?? 0}
    set {_uniqueStorage()._readFanOutFactor = newValue}
  }
  public var hasReadFanOutFactor: Bool {return _storage._readFanOutFactor != nil}
  public mutating func clearReadFanOutFactor() {_uniqueStorage()._readFanOutFactor = nil}

  /// Sharding method
  public var shardingMethod: Qdrant_ShardingMethod {
    get {return _storage._shardingMethod ?? .auto}
    set {_uniqueStorage()._shardingMethod = newValue}
  }
  public var hasShardingMethod: Bool {return _storage._shardingMethod != nil}
  public mutating func clearShardingMethod() {_uniqueStorage()._shardingMethod = nil}

  /// Configuration for sparse vectors
  public var sparseVectorsConfig: Qdrant_SparseVectorConfig {
    get {return _storage._sparseVectorsConfig ?? Qdrant_SparseVectorConfig()}
    set {_uniqueStorage()._sparseVectorsConfig = newValue}
  }
  public var hasSparseVectorsConfig: Bool {return _storage._sparseVectorsConfig != nil}
  public mutating func clearSparseVectorsConfig() {_uniqueStorage()._sparseVectorsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_CollectionParamsDiff: Sendable {
  /// Number of replicas of each shard that network tries to maintain
  public var replicationFactor: UInt32 {
    get {return _replicationFactor ?? 0}
    set {_replicationFactor = newValue}
  }
  public var hasReplicationFactor: Bool {return self._replicationFactor != nil}
  public mutating func clearReplicationFactor() {self._replicationFactor = nil}

  /// How many replicas should apply the operation for us to consider it successful
  public var writeConsistencyFactor: UInt32 {
    get {return _writeConsistencyFactor ?? 0}
    set {_writeConsistencyFactor = newValue}
  }
  public var hasWriteConsistencyFactor: Bool {return self._writeConsistencyFactor != nil}
  public mutating func clearWriteConsistencyFactor() {self._writeConsistencyFactor = nil}

  /// If true - point's payload will not be stored in memory
  public var onDiskPayload: Bool {
    get {return _onDiskPayload ?? false}
    set {_onDiskPayload = newValue}
  }
  public var hasOnDiskPayload: Bool {return self._onDiskPayload != nil}
  public mutating func clearOnDiskPayload() {self._onDiskPayload = nil}

  /// Fan-out every read request to these many additional remote nodes (and return first available response)
  public var readFanOutFactor: UInt32 {
    get {return _readFanOutFactor ?? 0}
    set {_readFanOutFactor = newValue}
  }
  public var hasReadFanOutFactor: Bool {return self._readFanOutFactor != nil}
  public mutating func clearReadFanOutFactor() {self._readFanOutFactor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _replicationFactor: UInt32? = nil
  fileprivate var _writeConsistencyFactor: UInt32? = nil
  fileprivate var _onDiskPayload: Bool? = nil
  fileprivate var _readFanOutFactor: UInt32? = nil
}

public struct Qdrant_CollectionConfig: @unchecked Sendable {
  /// Collection parameters
  public var params: Qdrant_CollectionParams {
    get {return _storage._params ?? Qdrant_CollectionParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// Configuration of vector index
  public var hnswConfig: Qdrant_HnswConfigDiff {
    get {return _storage._hnswConfig ?? Qdrant_HnswConfigDiff()}
    set {_uniqueStorage()._hnswConfig = newValue}
  }
  public var hasHnswConfig: Bool {return _storage._hnswConfig != nil}
  public mutating func clearHnswConfig() {_uniqueStorage()._hnswConfig = nil}

  /// Configuration of the optimizers
  public var optimizerConfig: Qdrant_OptimizersConfigDiff {
    get {return _storage._optimizerConfig ?? Qdrant_OptimizersConfigDiff()}
    set {_uniqueStorage()._optimizerConfig = newValue}
  }
  public var hasOptimizerConfig: Bool {return _storage._optimizerConfig != nil}
  public mutating func clearOptimizerConfig() {_uniqueStorage()._optimizerConfig = nil}

  /// Configuration of the Write-Ahead-Log
  public var walConfig: Qdrant_WalConfigDiff {
    get {return _storage._walConfig ?? Qdrant_WalConfigDiff()}
    set {_uniqueStorage()._walConfig = newValue}
  }
  public var hasWalConfig: Bool {return _storage._walConfig != nil}
  public mutating func clearWalConfig() {_uniqueStorage()._walConfig = nil}

  /// Configuration of the vector quantization
  public var quantizationConfig: Qdrant_QuantizationConfig {
    get {return _storage._quantizationConfig ?? Qdrant_QuantizationConfig()}
    set {_uniqueStorage()._quantizationConfig = newValue}
  }
  public var hasQuantizationConfig: Bool {return _storage._quantizationConfig != nil}
  public mutating func clearQuantizationConfig() {_uniqueStorage()._quantizationConfig = nil}

  /// Configuration of strict mode.
  public var strictModeConfig: Qdrant_StrictModeConfig {
    get {return _storage._strictModeConfig ?? Qdrant_StrictModeConfig()}
    set {_uniqueStorage()._strictModeConfig = newValue}
  }
  public var hasStrictModeConfig: Bool {return _storage._strictModeConfig != nil}
  public mutating func clearStrictModeConfig() {_uniqueStorage()._strictModeConfig = nil}

  /// Arbitrary JSON metadata for the collection
  public var metadata: Dictionary<String,Qdrant_Value> {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_KeywordIndexParams: Sendable {
  /// If true - used for tenant optimization.
  public var isTenant: Bool {
    get {return _isTenant ?? false}
    set {_isTenant = newValue}
  }
  public var hasIsTenant: Bool {return self._isTenant != nil}
  public mutating func clearIsTenant() {self._isTenant = nil}

  /// If true - store index on disk.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _isTenant: Bool? = nil
  fileprivate var _onDisk: Bool? = nil
}

public struct Qdrant_IntegerIndexParams: Sendable {
  /// If true - support direct lookups. Default is true.
  public var lookup: Bool {
    get {return _lookup ?? false}
    set {_lookup = newValue}
  }
  public var hasLookup: Bool {return self._lookup != nil}
  public mutating func clearLookup() {self._lookup = nil}

  /// If true - support ranges filters. Default is true.
  public var range: Bool {
    get {return _range ?? false}
    set {_range = newValue}
  }
  public var hasRange: Bool {return self._range != nil}
  public mutating func clearRange() {self._range = nil}

  /// If true - use this key to organize storage of the collection data.
  /// This option assumes that this key will be used in majority of filtered requests.
  /// Default is false.
  public var isPrincipal: Bool {
    get {return _isPrincipal ?? false}
    set {_isPrincipal = newValue}
  }
  public var hasIsPrincipal: Bool {return self._isPrincipal != nil}
  public mutating func clearIsPrincipal() {self._isPrincipal = nil}

  /// If true - store index on disk. Default is false.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lookup: Bool? = nil
  fileprivate var _range: Bool? = nil
  fileprivate var _isPrincipal: Bool? = nil
  fileprivate var _onDisk: Bool? = nil
}

public struct Qdrant_FloatIndexParams: Sendable {
  /// If true - store index on disk.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  /// If true - use this key to organize storage of the collection data.
  /// This option assumes that this key will be used in majority of filtered requests.
  public var isPrincipal: Bool {
    get {return _isPrincipal ?? false}
    set {_isPrincipal = newValue}
  }
  public var hasIsPrincipal: Bool {return self._isPrincipal != nil}
  public mutating func clearIsPrincipal() {self._isPrincipal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _onDisk: Bool? = nil
  fileprivate var _isPrincipal: Bool? = nil
}

public struct Qdrant_GeoIndexParams: Sendable {
  /// If true - store index on disk.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _onDisk: Bool? = nil
}

public struct Qdrant_StopwordsSet: Sendable {
  /// List of languages to use stopwords from
  public var languages: [String] = []

  /// List of custom stopwords
  public var custom: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_TextIndexParams: Sendable {
  /// Tokenizer type
  public var tokenizer: Qdrant_TokenizerType = .unknown

  /// If true - all tokens will be lowercase
  public var lowercase: Bool {
    get {return _lowercase ?? false}
    set {_lowercase = newValue}
  }
  public var hasLowercase: Bool {return self._lowercase != nil}
  public mutating func clearLowercase() {self._lowercase = nil}

  /// Minimal token length
  public var minTokenLen: UInt64 {
    get {return _minTokenLen ?? 0}
    set {_minTokenLen = newValue}
  }
  public var hasMinTokenLen: Bool {return self._minTokenLen != nil}
  public mutating func clearMinTokenLen() {self._minTokenLen = nil}

  /// Maximal token length
  public var maxTokenLen: UInt64 {
    get {return _maxTokenLen ?? 0}
    set {_maxTokenLen = newValue}
  }
  public var hasMaxTokenLen: Bool {return self._maxTokenLen != nil}
  public mutating func clearMaxTokenLen() {self._maxTokenLen = nil}

  /// If true - store index on disk.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  /// Stopwords for the text index
  public var stopwords: Qdrant_StopwordsSet {
    get {return _stopwords ?? Qdrant_StopwordsSet()}
    set {_stopwords = newValue}
  }
  public var hasStopwords: Bool {return self._stopwords != nil}
  public mutating func clearStopwords() {self._stopwords = nil}

  /// If true - support phrase matching.
  public var phraseMatching: Bool {
    get {return _phraseMatching ?? false}
    set {_phraseMatching = newValue}
  }
  public var hasPhraseMatching: Bool {return self._phraseMatching != nil}
  public mutating func clearPhraseMatching() {self._phraseMatching = nil}

  /// Set an algorithm for stemming.
  public var stemmer: Qdrant_StemmingAlgorithm {
    get {return _stemmer ?? Qdrant_StemmingAlgorithm()}
    set {_stemmer = newValue}
  }
  public var hasStemmer: Bool {return self._stemmer != nil}
  public mutating func clearStemmer() {self._stemmer = nil}

  /// If true, normalize tokens by folding accented characters to ASCII (e.g., "ao" -> "acao").
  /// Default: false.
  public var asciiFolding: Bool {
    get {return _asciiFolding ?? false}
    set {_asciiFolding = newValue}
  }
  public var hasAsciiFolding: Bool {return self._asciiFolding != nil}
  public mutating func clearAsciiFolding() {self._asciiFolding = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lowercase: Bool? = nil
  fileprivate var _minTokenLen: UInt64? = nil
  fileprivate var _maxTokenLen: UInt64? = nil
  fileprivate var _onDisk: Bool? = nil
  fileprivate var _stopwords: Qdrant_StopwordsSet? = nil
  fileprivate var _phraseMatching: Bool? = nil
  fileprivate var _stemmer: Qdrant_StemmingAlgorithm? = nil
  fileprivate var _asciiFolding: Bool? = nil
}

public struct Qdrant_StemmingAlgorithm: Sendable {
  public var stemmingParams: Qdrant_StemmingAlgorithm.OneOf_StemmingParams? = nil

  /// Parameters for snowball stemming
  public var snowball: Qdrant_SnowballParams {
    get {
      if case .snowball(let v)? = stemmingParams {return v}
      return Qdrant_SnowballParams()
    }
    set {stemmingParams = .snowball(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StemmingParams: Equatable, Sendable {
    /// Parameters for snowball stemming
    case snowball(Qdrant_SnowballParams)

  }

  public init() {}
}

public struct Qdrant_SnowballParams: Sendable {
  /// Which language the algorithm should stem.
  public var language: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_BoolIndexParams: Sendable {
  /// If true - store index on disk.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _onDisk: Bool? = nil
}

public struct Qdrant_DatetimeIndexParams: Sendable {
  /// If true - store index on disk.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  /// If true - use this key to organize storage of the collection data.
  /// This option assumes that this key will be used in majority of filtered requests.
  public var isPrincipal: Bool {
    get {return _isPrincipal ?? false}
    set {_isPrincipal = newValue}
  }
  public var hasIsPrincipal: Bool {return self._isPrincipal != nil}
  public mutating func clearIsPrincipal() {self._isPrincipal = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _onDisk: Bool? = nil
  fileprivate var _isPrincipal: Bool? = nil
}

public struct Qdrant_UuidIndexParams: Sendable {
  /// If true - used for tenant optimization.
  public var isTenant: Bool {
    get {return _isTenant ?? false}
    set {_isTenant = newValue}
  }
  public var hasIsTenant: Bool {return self._isTenant != nil}
  public mutating func clearIsTenant() {self._isTenant = nil}

  /// If true - store index on disk.
  public var onDisk: Bool {
    get {return _onDisk ?? false}
    set {_onDisk = newValue}
  }
  public var hasOnDisk: Bool {return self._onDisk != nil}
  public mutating func clearOnDisk() {self._onDisk = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _isTenant: Bool? = nil
  fileprivate var _onDisk: Bool? = nil
}

public struct Qdrant_PayloadIndexParams: Sendable {
  public var indexParams: Qdrant_PayloadIndexParams.OneOf_IndexParams? = nil

  /// Parameters for keyword index
  public var keywordIndexParams: Qdrant_KeywordIndexParams {
    get {
      if case .keywordIndexParams(let v)? = indexParams {return v}
      return Qdrant_KeywordIndexParams()
    }
    set {indexParams = .keywordIndexParams(newValue)}
  }

  /// Parameters for integer index
  public var integerIndexParams: Qdrant_IntegerIndexParams {
    get {
      if case .integerIndexParams(let v)? = indexParams {return v}
      return Qdrant_IntegerIndexParams()
    }
    set {indexParams = .integerIndexParams(newValue)}
  }

  /// Parameters for float index
  public var floatIndexParams: Qdrant_FloatIndexParams {
    get {
      if case .floatIndexParams(let v)? = indexParams {return v}
      return Qdrant_FloatIndexParams()
    }
    set {indexParams = .floatIndexParams(newValue)}
  }

  /// Parameters for geo index
  public var geoIndexParams: Qdrant_GeoIndexParams {
    get {
      if case .geoIndexParams(let v)? = indexParams {return v}
      return Qdrant_GeoIndexParams()
    }
    set {indexParams = .geoIndexParams(newValue)}
  }

  /// Parameters for text index
  public var textIndexParams: Qdrant_TextIndexParams {
    get {
      if case .textIndexParams(let v)? = indexParams {return v}
      return Qdrant_TextIndexParams()
    }
    set {indexParams = .textIndexParams(newValue)}
  }

  /// Parameters for bool index
  public var boolIndexParams: Qdrant_BoolIndexParams {
    get {
      if case .boolIndexParams(let v)? = indexParams {return v}
      return Qdrant_BoolIndexParams()
    }
    set {indexParams = .boolIndexParams(newValue)}
  }

  /// Parameters for datetime index
  public var datetimeIndexParams: Qdrant_DatetimeIndexParams {
    get {
      if case .datetimeIndexParams(let v)? = indexParams {return v}
      return Qdrant_DatetimeIndexParams()
    }
    set {indexParams = .datetimeIndexParams(newValue)}
  }

  /// Parameters for uuid index
  public var uuidIndexParams: Qdrant_UuidIndexParams {
    get {
      if case .uuidIndexParams(let v)? = indexParams {return v}
      return Qdrant_UuidIndexParams()
    }
    set {indexParams = .uuidIndexParams(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_IndexParams: Equatable, Sendable {
    /// Parameters for keyword index
    case keywordIndexParams(Qdrant_KeywordIndexParams)
    /// Parameters for integer index
    case integerIndexParams(Qdrant_IntegerIndexParams)
    /// Parameters for float index
    case floatIndexParams(Qdrant_FloatIndexParams)
    /// Parameters for geo index
    case geoIndexParams(Qdrant_GeoIndexParams)
    /// Parameters for text index
    case textIndexParams(Qdrant_TextIndexParams)
    /// Parameters for bool index
    case boolIndexParams(Qdrant_BoolIndexParams)
    /// Parameters for datetime index
    case datetimeIndexParams(Qdrant_DatetimeIndexParams)
    /// Parameters for uuid index
    case uuidIndexParams(Qdrant_UuidIndexParams)

  }

  public init() {}
}

public struct Qdrant_PayloadSchemaInfo: Sendable {
  /// Field data type
  public var dataType: Qdrant_PayloadSchemaType = .unknownType

  /// Field index parameters
  public var params: Qdrant_PayloadIndexParams {
    get {return _params ?? Qdrant_PayloadIndexParams()}
    set {_params = newValue}
  }
  public var hasParams: Bool {return self._params != nil}
  public mutating func clearParams() {self._params = nil}

  /// Number of points indexed within this field
  public var points: UInt64 {
    get {return _points ?? 0}
    set {_points = newValue}
  }
  public var hasPoints: Bool {return self._points != nil}
  public mutating func clearPoints() {self._points = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: Qdrant_PayloadIndexParams? = nil
  fileprivate var _points: UInt64? = nil
}

public struct Qdrant_CollectionInfo: Sendable {
  /// operating condition of the collection
  public var status: Qdrant_CollectionStatus = .unknownCollectionStatus

  /// status of collection optimizers
  public var optimizerStatus: Qdrant_OptimizerStatus {
    get {return _optimizerStatus ?? Qdrant_OptimizerStatus()}
    set {_optimizerStatus = newValue}
  }
  public var hasOptimizerStatus: Bool {return self._optimizerStatus != nil}
  public mutating func clearOptimizerStatus() {self._optimizerStatus = nil}

  /// Number of independent segments
  public var segmentsCount: UInt64 = 0

  /// Configuration
  public var config: Qdrant_CollectionConfig {
    get {return _config ?? Qdrant_CollectionConfig()}
    set {_config = newValue}
  }
  public var hasConfig: Bool {return self._config != nil}
  public mutating func clearConfig() {self._config = nil}

  /// Collection data types
  public var payloadSchema: Dictionary<String,Qdrant_PayloadSchemaInfo> = [:]

  /// Approximate number of points in the collection
  public var pointsCount: UInt64 {
    get {return _pointsCount ?? 0}
    set {_pointsCount = newValue}
  }
  public var hasPointsCount: Bool {return self._pointsCount != nil}
  public mutating func clearPointsCount() {self._pointsCount = nil}

  /// Approximate number of indexed vectors in the collection.
  public var indexedVectorsCount: UInt64 {
    get {return _indexedVectorsCount ?? 0}
    set {_indexedVectorsCount = newValue}
  }
  public var hasIndexedVectorsCount: Bool {return self._indexedVectorsCount != nil}
  public mutating func clearIndexedVectorsCount() {self._indexedVectorsCount = nil}

  /// Warnings related to the collection
  public var warnings: [Qdrant_CollectionWarning] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _optimizerStatus: Qdrant_OptimizerStatus? = nil
  fileprivate var _config: Qdrant_CollectionConfig? = nil
  fileprivate var _pointsCount: UInt64? = nil
  fileprivate var _indexedVectorsCount: UInt64? = nil
}

public struct Qdrant_ChangeAliases: Sendable {
  /// List of actions
  public var actions: [Qdrant_AliasOperations] = []

  /// Wait timeout for operation commit in seconds.
  /// If not specified - default value will be supplied.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_AliasOperations: Sendable {
  public var action: Qdrant_AliasOperations.OneOf_Action? = nil

  public var createAlias: Qdrant_CreateAlias {
    get {
      if case .createAlias(let v)? = action {return v}
      return Qdrant_CreateAlias()
    }
    set {action = .createAlias(newValue)}
  }

  public var renameAlias: Qdrant_RenameAlias {
    get {
      if case .renameAlias(let v)? = action {return v}
      return Qdrant_RenameAlias()
    }
    set {action = .renameAlias(newValue)}
  }

  public var deleteAlias: Qdrant_DeleteAlias {
    get {
      if case .deleteAlias(let v)? = action {return v}
      return Qdrant_DeleteAlias()
    }
    set {action = .deleteAlias(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable, Sendable {
    case createAlias(Qdrant_CreateAlias)
    case renameAlias(Qdrant_RenameAlias)
    case deleteAlias(Qdrant_DeleteAlias)

  }

  public init() {}
}

public struct Qdrant_CreateAlias: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  /// New name of the alias
  public var aliasName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_RenameAlias: Sendable {
  /// Name of the alias to rename
  public var oldAliasName: String = String()

  /// Name of the alias
  public var newAliasName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_DeleteAlias: Sendable {
  /// Name of the alias
  public var aliasName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_ListAliasesRequest: Sendable {
  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_ListCollectionAliasesRequest: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_AliasDescription: Sendable {
  /// Name of the alias
  public var aliasName: String = String()

  /// Name of the collection
  public var collectionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_ListAliasesResponse: Sendable {
  public var aliases: [Qdrant_AliasDescription] = []

  /// Time spent to process
  public var time: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CollectionClusterInfoRequest: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_ShardKey: Sendable {
  public var key: Qdrant_ShardKey.OneOf_Key? = nil

  /// String key
  public var keyword: String {
    get {
      if case .keyword(let v)? = key {return v}
      return String()
    }
    set {key = .keyword(newValue)}
  }

  /// Number key
  public var number: UInt64 {
    get {
      if case .number(let v)? = key {return v}
      return 0
    }
    set {key = .number(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable, Sendable {
    /// String key
    case keyword(String)
    /// Number key
    case number(UInt64)

  }

  public init() {}
}

public struct Qdrant_LocalShardInfo: Sendable {
  /// Local shard id
  public var shardID: UInt32 = 0

  /// Number of points in the shard
  public var pointsCount: UInt64 = 0

  /// Is replica active
  public var state: Qdrant_ReplicaState = .active

  /// User-defined shard key
  public var shardKey: Qdrant_ShardKey {
    get {return _shardKey ?? Qdrant_ShardKey()}
    set {_shardKey = newValue}
  }
  public var hasShardKey: Bool {return self._shardKey != nil}
  public mutating func clearShardKey() {self._shardKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shardKey: Qdrant_ShardKey? = nil
}

public struct Qdrant_RemoteShardInfo: Sendable {
  /// Local shard id
  public var shardID: UInt32 = 0

  /// Remote peer id
  public var peerID: UInt64 = 0

  /// Is replica active
  public var state: Qdrant_ReplicaState = .active

  /// User-defined shard key
  public var shardKey: Qdrant_ShardKey {
    get {return _shardKey ?? Qdrant_ShardKey()}
    set {_shardKey = newValue}
  }
  public var hasShardKey: Bool {return self._shardKey != nil}
  public mutating func clearShardKey() {self._shardKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shardKey: Qdrant_ShardKey? = nil
}

public struct Qdrant_ShardTransferInfo: Sendable {
  /// Local shard id
  public var shardID: UInt32 = 0

  public var toShardID: UInt32 {
    get {return _toShardID ?? 0}
    set {_toShardID = newValue}
  }
  public var hasToShardID: Bool {return self._toShardID != nil}
  public mutating func clearToShardID() {self._toShardID = nil}

  public var from: UInt64 = 0

  public var to: UInt64 = 0

  /// If `true` transfer is a synchronization of a replicas;
  /// If `false` transfer is a moving of a shard from one peer to another
  public var sync: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _toShardID: UInt32? = nil
}

public struct Qdrant_ReshardingInfo: Sendable {
  public var shardID: UInt32 = 0

  public var peerID: UInt64 = 0

  public var shardKey: Qdrant_ShardKey {
    get {return _shardKey ?? Qdrant_ShardKey()}
    set {_shardKey = newValue}
  }
  public var hasShardKey: Bool {return self._shardKey != nil}
  public mutating func clearShardKey() {self._shardKey = nil}

  public var direction: Qdrant_ReshardingDirection = .up

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shardKey: Qdrant_ShardKey? = nil
}

public struct Qdrant_CollectionClusterInfoResponse: Sendable {
  /// ID of this peer
  public var peerID: UInt64 = 0

  /// Total number of shards
  public var shardCount: UInt64 = 0

  /// Local shards
  public var localShards: [Qdrant_LocalShardInfo] = []

  /// Remote shards
  public var remoteShards: [Qdrant_RemoteShardInfo] = []

  /// Shard transfers
  public var shardTransfers: [Qdrant_ShardTransferInfo] = []

  /// Resharding operations
  public var reshardingOperations: [Qdrant_ReshardingInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_MoveShard: Sendable {
  /// Local shard id
  public var shardID: UInt32 = 0

  public var toShardID: UInt32 {
    get {return _toShardID ?? 0}
    set {_toShardID = newValue}
  }
  public var hasToShardID: Bool {return self._toShardID != nil}
  public mutating func clearToShardID() {self._toShardID = nil}

  public var fromPeerID: UInt64 = 0

  public var toPeerID: UInt64 = 0

  public var method: Qdrant_ShardTransferMethod {
    get {return _method ?? .streamRecords}
    set {_method = newValue}
  }
  public var hasMethod: Bool {return self._method != nil}
  public mutating func clearMethod() {self._method = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _toShardID: UInt32? = nil
  fileprivate var _method: Qdrant_ShardTransferMethod? = nil
}

public struct Qdrant_ReplicateShard: Sendable {
  /// Local shard id
  public var shardID: UInt32 = 0

  public var toShardID: UInt32 {
    get {return _toShardID ?? 0}
    set {_toShardID = newValue}
  }
  public var hasToShardID: Bool {return self._toShardID != nil}
  public mutating func clearToShardID() {self._toShardID = nil}

  public var fromPeerID: UInt64 = 0

  public var toPeerID: UInt64 = 0

  public var method: Qdrant_ShardTransferMethod {
    get {return _method ?? .streamRecords}
    set {_method = newValue}
  }
  public var hasMethod: Bool {return self._method != nil}
  public mutating func clearMethod() {self._method = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _toShardID: UInt32? = nil
  fileprivate var _method: Qdrant_ShardTransferMethod? = nil
}

public struct Qdrant_AbortShardTransfer: Sendable {
  /// Local shard id
  public var shardID: UInt32 = 0

  public var toShardID: UInt32 {
    get {return _toShardID ?? 0}
    set {_toShardID = newValue}
  }
  public var hasToShardID: Bool {return self._toShardID != nil}
  public mutating func clearToShardID() {self._toShardID = nil}

  public var fromPeerID: UInt64 = 0

  public var toPeerID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _toShardID: UInt32? = nil
}

public struct Qdrant_RestartTransfer: Sendable {
  /// Local shard id
  public var shardID: UInt32 = 0

  public var toShardID: UInt32 {
    get {return _toShardID ?? 0}
    set {_toShardID = newValue}
  }
  public var hasToShardID: Bool {return self._toShardID != nil}
  public mutating func clearToShardID() {self._toShardID = nil}

  public var fromPeerID: UInt64 = 0

  public var toPeerID: UInt64 = 0

  public var method: Qdrant_ShardTransferMethod = .streamRecords

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _toShardID: UInt32? = nil
}

public struct Qdrant_ReplicatePoints: Sendable {
  /// Source shard key
  public var fromShardKey: Qdrant_ShardKey {
    get {return _fromShardKey ?? Qdrant_ShardKey()}
    set {_fromShardKey = newValue}
  }
  public var hasFromShardKey: Bool {return self._fromShardKey != nil}
  public mutating func clearFromShardKey() {self._fromShardKey = nil}

  /// Target shard key
  public var toShardKey: Qdrant_ShardKey {
    get {return _toShardKey ?? Qdrant_ShardKey()}
    set {_toShardKey = newValue}
  }
  public var hasToShardKey: Bool {return self._toShardKey != nil}
  public mutating func clearToShardKey() {self._toShardKey = nil}

  /// If set - only points matching the filter will be replicated
  public var filter: Qdrant_Filter {
    get {return _filter ?? Qdrant_Filter()}
    set {_filter = newValue}
  }
  public var hasFilter: Bool {return self._filter != nil}
  public mutating func clearFilter() {self._filter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fromShardKey: Qdrant_ShardKey? = nil
  fileprivate var _toShardKey: Qdrant_ShardKey? = nil
  fileprivate var _filter: Qdrant_Filter? = nil
}

public struct Qdrant_Replica: Sendable {
  public var shardID: UInt32 = 0

  public var peerID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CreateShardKey: Sendable {
  /// User-defined shard key
  public var shardKey: Qdrant_ShardKey {
    get {return _shardKey ?? Qdrant_ShardKey()}
    set {_shardKey = newValue}
  }
  public var hasShardKey: Bool {return self._shardKey != nil}
  public mutating func clearShardKey() {self._shardKey = nil}

  /// Number of shards to create per shard key
  public var shardsNumber: UInt32 {
    get {return _shardsNumber ?? 0}
    set {_shardsNumber = newValue}
  }
  public var hasShardsNumber: Bool {return self._shardsNumber != nil}
  public mutating func clearShardsNumber() {self._shardsNumber = nil}

  /// Number of replicas of each shard to create
  public var replicationFactor: UInt32 {
    get {return _replicationFactor ?? 0}
    set {_replicationFactor = newValue}
  }
  public var hasReplicationFactor: Bool {return self._replicationFactor != nil}
  public mutating func clearReplicationFactor() {self._replicationFactor = nil}

  /// List of peer ids, allowed to create shards. If empty - all peers are allowed
  public var placement: [UInt64] = []

  /// Initial state of created replicas. Warning: use with care.
  public var initialState: Qdrant_ReplicaState {
    get {return _initialState ?? .active}
    set {_initialState = newValue}
  }
  public var hasInitialState: Bool {return self._initialState != nil}
  public mutating func clearInitialState() {self._initialState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shardKey: Qdrant_ShardKey? = nil
  fileprivate var _shardsNumber: UInt32? = nil
  fileprivate var _replicationFactor: UInt32? = nil
  fileprivate var _initialState: Qdrant_ReplicaState? = nil
}

public struct Qdrant_DeleteShardKey: Sendable {
  /// Shard key to delete
  public var shardKey: Qdrant_ShardKey {
    get {return _shardKey ?? Qdrant_ShardKey()}
    set {_shardKey = newValue}
  }
  public var hasShardKey: Bool {return self._shardKey != nil}
  public mutating func clearShardKey() {self._shardKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shardKey: Qdrant_ShardKey? = nil
}

public struct Qdrant_UpdateCollectionClusterSetupRequest: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  public var operation: Qdrant_UpdateCollectionClusterSetupRequest.OneOf_Operation? = nil

  public var moveShard: Qdrant_MoveShard {
    get {
      if case .moveShard(let v)? = operation {return v}
      return Qdrant_MoveShard()
    }
    set {operation = .moveShard(newValue)}
  }

  public var replicateShard: Qdrant_ReplicateShard {
    get {
      if case .replicateShard(let v)? = operation {return v}
      return Qdrant_ReplicateShard()
    }
    set {operation = .replicateShard(newValue)}
  }

  public var abortTransfer: Qdrant_AbortShardTransfer {
    get {
      if case .abortTransfer(let v)? = operation {return v}
      return Qdrant_AbortShardTransfer()
    }
    set {operation = .abortTransfer(newValue)}
  }

  public var dropReplica: Qdrant_Replica {
    get {
      if case .dropReplica(let v)? = operation {return v}
      return Qdrant_Replica()
    }
    set {operation = .dropReplica(newValue)}
  }

  public var createShardKey: Qdrant_CreateShardKey {
    get {
      if case .createShardKey(let v)? = operation {return v}
      return Qdrant_CreateShardKey()
    }
    set {operation = .createShardKey(newValue)}
  }

  public var deleteShardKey: Qdrant_DeleteShardKey {
    get {
      if case .deleteShardKey(let v)? = operation {return v}
      return Qdrant_DeleteShardKey()
    }
    set {operation = .deleteShardKey(newValue)}
  }

  public var restartTransfer: Qdrant_RestartTransfer {
    get {
      if case .restartTransfer(let v)? = operation {return v}
      return Qdrant_RestartTransfer()
    }
    set {operation = .restartTransfer(newValue)}
  }

  public var replicatePoints: Qdrant_ReplicatePoints {
    get {
      if case .replicatePoints(let v)? = operation {return v}
      return Qdrant_ReplicatePoints()
    }
    set {operation = .replicatePoints(newValue)}
  }

  /// Wait timeout for operation commit in seconds.
  /// If not specified - default value will be supplied.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Operation: Equatable, Sendable {
    case moveShard(Qdrant_MoveShard)
    case replicateShard(Qdrant_ReplicateShard)
    case abortTransfer(Qdrant_AbortShardTransfer)
    case dropReplica(Qdrant_Replica)
    case createShardKey(Qdrant_CreateShardKey)
    case deleteShardKey(Qdrant_DeleteShardKey)
    case restartTransfer(Qdrant_RestartTransfer)
    case replicatePoints(Qdrant_ReplicatePoints)

  }

  public init() {}

  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_UpdateCollectionClusterSetupResponse: Sendable {
  public var result: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CreateShardKeyRequest: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  /// Request to create shard key
  public var request: Qdrant_CreateShardKey {
    get {return _request ?? Qdrant_CreateShardKey()}
    set {_request = newValue}
  }
  public var hasRequest: Bool {return self._request != nil}
  public mutating func clearRequest() {self._request = nil}

  /// Wait timeout for operation commit in seconds.
  /// If not specified - default value will be supplied.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: Qdrant_CreateShardKey? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_DeleteShardKeyRequest: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  /// Request to delete shard key
  public var request: Qdrant_DeleteShardKey {
    get {return _request ?? Qdrant_DeleteShardKey()}
    set {_request = newValue}
  }
  public var hasRequest: Bool {return self._request != nil}
  public mutating func clearRequest() {self._request = nil}

  /// Wait timeout for operation commit in seconds.
  /// If not specified - default value will be supplied.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _request: Qdrant_DeleteShardKey? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_ListShardKeysRequest: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_CreateShardKeyResponse: Sendable {
  public var result: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_DeleteShardKeyResponse: Sendable {
  public var result: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_ShardKeyDescription: Sendable {
  public var key: Qdrant_ShardKey {
    get {return _key ?? Qdrant_ShardKey()}
    set {_key = newValue}
  }
  public var hasKey: Bool {return self._key != nil}
  public mutating func clearKey() {self._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: Qdrant_ShardKey? = nil
}

public struct Qdrant_ListShardKeysResponse: Sendable {
  public var shardKeys: [Qdrant_ShardKeyDescription] = []

  /// Time spent to process
  public var time: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qdrant"

extension Qdrant_Datatype: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Default\0\u{1}Float32\0\u{1}Uint8\0\u{1}Float16\0")
}

extension Qdrant_Modifier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0None\0\u{1}Idf\0")
}

extension Qdrant_MultiVectorComparator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MaxSim\0")
}

extension Qdrant_Distance: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UnknownDistance\0\u{1}Cosine\0\u{1}Euclid\0\u{1}Dot\0\u{1}Manhattan\0")
}

extension Qdrant_CollectionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UnknownCollectionStatus\0\u{1}Green\0\u{1}Yellow\0\u{1}Red\0\u{1}Grey\0")
}

extension Qdrant_PayloadSchemaType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UnknownType\0\u{1}Keyword\0\u{1}Integer\0\u{1}Float\0\u{1}Geo\0\u{1}Text\0\u{1}Bool\0\u{1}Datetime\0\u{1}Uuid\0")
}

extension Qdrant_QuantizationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UnknownQuantization\0\u{1}Int8\0")
}

extension Qdrant_CompressionRatio: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0x4\0\u{1}x8\0\u{1}x16\0\u{1}x32\0\u{1}x64\0")
}

extension Qdrant_BinaryQuantizationEncoding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OneBit\0\u{1}TwoBits\0\u{1}OneAndHalfBits\0")
}

extension Qdrant_ShardingMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Auto\0\u{1}Custom\0")
}

extension Qdrant_TokenizerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Unknown\0\u{1}Prefix\0\u{1}Whitespace\0\u{1}Word\0\u{1}Multilingual\0")
}

extension Qdrant_ReplicaState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Active\0\u{1}Dead\0\u{1}Partial\0\u{1}Initializing\0\u{1}Listener\0\u{1}PartialSnapshot\0\u{1}Recovery\0\u{1}Resharding\0\u{1}ReshardingScaleDown\0\u{1}ActiveRead\0")
}

extension Qdrant_ReshardingDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Up\0\u{1}Down\0")
}

extension Qdrant_ShardTransferMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0StreamRecords\0\u{1}Snapshot\0\u{1}WalDelta\0\u{1}ReshardingStreamRecords\0")
}

extension Qdrant_VectorParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}size\0\u{1}distance\0\u{3}hnsw_config\0\u{3}quantization_config\0\u{3}on_disk\0\u{1}datatype\0\u{3}multivector_config\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.distance) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._hnswConfig) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._quantizationConfig) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._datatype) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._multivectorConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 1)
    }
    if self.distance != .unknownDistance {
      try visitor.visitSingularEnumField(value: self.distance, fieldNumber: 2)
    }
    try { if let v = self._hnswConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._quantizationConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._datatype {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._multivectorConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorParams, rhs: Qdrant_VectorParams) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs._hnswConfig != rhs._hnswConfig {return false}
    if lhs._quantizationConfig != rhs._quantizationConfig {return false}
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs._datatype != rhs._datatype {return false}
    if lhs._multivectorConfig != rhs._multivectorConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorParamsDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorParamsDiff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}hnsw_config\0\u{3}quantization_config\0\u{3}on_disk\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hnswConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._quantizationConfig) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hnswConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._quantizationConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorParamsDiff, rhs: Qdrant_VectorParamsDiff) -> Bool {
    if lhs._hnswConfig != rhs._hnswConfig {return false}
    if lhs._quantizationConfig != rhs._quantizationConfig {return false}
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorParamsMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorParamsMap"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_VectorParams>.self, value: &self.map) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_VectorParams>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorParamsMap, rhs: Qdrant_VectorParamsMap) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorParamsDiffMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorParamsDiffMap"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_VectorParamsDiff>.self, value: &self.map) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_VectorParamsDiff>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorParamsDiffMap, rhs: Qdrant_VectorParamsDiffMap) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorsConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}params\0\u{3}params_map\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_VectorParams?
        var hadOneofValue = false
        if let current = self.config {
          hadOneofValue = true
          if case .params(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.config = .params(v)
        }
      }()
      case 2: try {
        var v: Qdrant_VectorParamsMap?
        var hadOneofValue = false
        if let current = self.config {
          hadOneofValue = true
          if case .paramsMap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.config = .paramsMap(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.config {
    case .params?: try {
      guard case .params(let v)? = self.config else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .paramsMap?: try {
      guard case .paramsMap(let v)? = self.config else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorsConfig, rhs: Qdrant_VectorsConfig) -> Bool {
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorsConfigDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorsConfigDiff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}params\0\u{3}params_map\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_VectorParamsDiff?
        var hadOneofValue = false
        if let current = self.config {
          hadOneofValue = true
          if case .params(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.config = .params(v)
        }
      }()
      case 2: try {
        var v: Qdrant_VectorParamsDiffMap?
        var hadOneofValue = false
        if let current = self.config {
          hadOneofValue = true
          if case .paramsMap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.config = .paramsMap(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.config {
    case .params?: try {
      guard case .params(let v)? = self.config else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .paramsMap?: try {
      guard case .paramsMap(let v)? = self.config else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorsConfigDiff, rhs: Qdrant_VectorsConfigDiff) -> Bool {
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SparseVectorParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SparseVectorParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}modifier\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._index) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._modifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._modifier {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SparseVectorParams, rhs: Qdrant_SparseVectorParams) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._modifier != rhs._modifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SparseVectorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SparseVectorConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}map\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_SparseVectorParams>.self, value: &self.map) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.map.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_SparseVectorParams>.self, value: self.map, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SparseVectorConfig, rhs: Qdrant_SparseVectorConfig) -> Bool {
    if lhs.map != rhs.map {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_MultiVectorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiVectorConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}comparator\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.comparator) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.comparator != .maxSim {
      try visitor.visitSingularEnumField(value: self.comparator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_MultiVectorConfig, rhs: Qdrant_MultiVectorConfig) -> Bool {
    if lhs.comparator != rhs.comparator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GetCollectionInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCollectionInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GetCollectionInfoRequest, rhs: Qdrant_GetCollectionInfoRequest) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionExistsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionExistsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionExistsRequest, rhs: Qdrant_CollectionExistsRequest) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionExists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionExists"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}exists\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.exists) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exists != false {
      try visitor.visitSingularBoolField(value: self.exists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionExists, rhs: Qdrant_CollectionExists) -> Bool {
    if lhs.exists != rhs.exists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionExistsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionExistsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionExistsResponse, rhs: Qdrant_CollectionExistsResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ListCollectionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollectionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ListCollectionsRequest, rhs: Qdrant_ListCollectionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionDescription"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionDescription, rhs: Qdrant_CollectionDescription) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GetCollectionInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCollectionInfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GetCollectionInfoResponse, rhs: Qdrant_GetCollectionInfoResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ListCollectionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollectionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}collections\0\u{1}time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.collections) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collections, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ListCollectionsResponse, rhs: Qdrant_ListCollectionsResponse) -> Bool {
    if lhs.collections != rhs.collections {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_MaxOptimizationThreads: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaxOptimizationThreads"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}setting\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .value(v)
        }
      }()
      case 2: try {
        var v: Qdrant_MaxOptimizationThreads.Setting?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .setting(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .value?: try {
      guard case .value(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .setting?: try {
      guard case .setting(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_MaxOptimizationThreads, rhs: Qdrant_MaxOptimizationThreads) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_MaxOptimizationThreads.Setting: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Auto\0")
}

extension Qdrant_OptimizerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptimizerStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ok\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_OptimizerStatus, rhs: Qdrant_OptimizerStatus) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionWarning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionWarning"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionWarning, rhs: Qdrant_CollectionWarning) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_HnswConfigDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HnswConfigDiff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}m\0\u{3}ef_construct\0\u{3}full_scan_threshold\0\u{3}max_indexing_threads\0\u{3}on_disk\0\u{3}payload_m\0\u{3}inline_storage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._m) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._efConstruct) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._fullScanThreshold) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._maxIndexingThreads) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._payloadM) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._inlineStorage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._m {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._efConstruct {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fullScanThreshold {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxIndexingThreads {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._payloadM {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._inlineStorage {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_HnswConfigDiff, rhs: Qdrant_HnswConfigDiff) -> Bool {
    if lhs._m != rhs._m {return false}
    if lhs._efConstruct != rhs._efConstruct {return false}
    if lhs._fullScanThreshold != rhs._fullScanThreshold {return false}
    if lhs._maxIndexingThreads != rhs._maxIndexingThreads {return false}
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs._payloadM != rhs._payloadM {return false}
    if lhs._inlineStorage != rhs._inlineStorage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SparseIndexConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SparseIndexConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}full_scan_threshold\0\u{3}on_disk\0\u{1}datatype\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._fullScanThreshold) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._datatype) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fullScanThreshold {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._datatype {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SparseIndexConfig, rhs: Qdrant_SparseIndexConfig) -> Bool {
    if lhs._fullScanThreshold != rhs._fullScanThreshold {return false}
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs._datatype != rhs._datatype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_WalConfigDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalConfigDiff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}wal_capacity_mb\0\u{3}wal_segments_ahead\0\u{3}wal_retain_closed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._walCapacityMb) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._walSegmentsAhead) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._walRetainClosed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._walCapacityMb {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._walSegmentsAhead {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._walRetainClosed {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_WalConfigDiff, rhs: Qdrant_WalConfigDiff) -> Bool {
    if lhs._walCapacityMb != rhs._walCapacityMb {return false}
    if lhs._walSegmentsAhead != rhs._walSegmentsAhead {return false}
    if lhs._walRetainClosed != rhs._walRetainClosed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_OptimizersConfigDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptimizersConfigDiff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deleted_threshold\0\u{3}vacuum_min_vector_number\0\u{3}default_segment_number\0\u{3}max_segment_size\0\u{3}memmap_threshold\0\u{3}indexing_threshold\0\u{3}flush_interval_sec\0\u{3}deprecated_max_optimization_threads\0\u{3}max_optimization_threads\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._deletedThreshold) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._vacuumMinVectorNumber) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._defaultSegmentNumber) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._maxSegmentSize) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._memmapThreshold) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._indexingThreshold) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._flushIntervalSec) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._deprecatedMaxOptimizationThreads) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._maxOptimizationThreads) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deletedThreshold {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._vacuumMinVectorNumber {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._defaultSegmentNumber {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxSegmentSize {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._memmapThreshold {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._indexingThreshold {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._flushIntervalSec {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._deprecatedMaxOptimizationThreads {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._maxOptimizationThreads {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_OptimizersConfigDiff, rhs: Qdrant_OptimizersConfigDiff) -> Bool {
    if lhs._deletedThreshold != rhs._deletedThreshold {return false}
    if lhs._vacuumMinVectorNumber != rhs._vacuumMinVectorNumber {return false}
    if lhs._defaultSegmentNumber != rhs._defaultSegmentNumber {return false}
    if lhs._maxSegmentSize != rhs._maxSegmentSize {return false}
    if lhs._memmapThreshold != rhs._memmapThreshold {return false}
    if lhs._indexingThreshold != rhs._indexingThreshold {return false}
    if lhs._flushIntervalSec != rhs._flushIntervalSec {return false}
    if lhs._deprecatedMaxOptimizationThreads != rhs._deprecatedMaxOptimizationThreads {return false}
    if lhs._maxOptimizationThreads != rhs._maxOptimizationThreads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ScalarQuantization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScalarQuantization"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}quantile\0\u{3}always_ram\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._quantile) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._alwaysRam) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknownQuantization {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._quantile {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._alwaysRam {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ScalarQuantization, rhs: Qdrant_ScalarQuantization) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._quantile != rhs._quantile {return false}
    if lhs._alwaysRam != rhs._alwaysRam {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ProductQuantization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProductQuantization"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}compression\0\u{3}always_ram\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.compression) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._alwaysRam) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.compression != .x4 {
      try visitor.visitSingularEnumField(value: self.compression, fieldNumber: 1)
    }
    try { if let v = self._alwaysRam {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ProductQuantization, rhs: Qdrant_ProductQuantization) -> Bool {
    if lhs.compression != rhs.compression {return false}
    if lhs._alwaysRam != rhs._alwaysRam {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_BinaryQuantizationQueryEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BinaryQuantizationQueryEncoding"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{4}setting\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: Qdrant_BinaryQuantizationQueryEncoding.Setting?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .setting(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .setting(let v)? = self.variant {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_BinaryQuantizationQueryEncoding, rhs: Qdrant_BinaryQuantizationQueryEncoding) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_BinaryQuantizationQueryEncoding.Setting: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Default\0\u{1}Binary\0\u{1}Scalar4Bits\0\u{1}Scalar8Bits\0")
}

extension Qdrant_BinaryQuantization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BinaryQuantization"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}always_ram\0\u{1}encoding\0\u{3}query_encoding\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._alwaysRam) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._encoding) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._queryEncoding) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._alwaysRam {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._encoding {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._queryEncoding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_BinaryQuantization, rhs: Qdrant_BinaryQuantization) -> Bool {
    if lhs._alwaysRam != rhs._alwaysRam {return false}
    if lhs._encoding != rhs._encoding {return false}
    if lhs._queryEncoding != rhs._queryEncoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QuantizationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuantizationConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}scalar\0\u{1}product\0\u{1}binary\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_ScalarQuantization?
        var hadOneofValue = false
        if let current = self.quantization {
          hadOneofValue = true
          if case .scalar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantization = .scalar(v)
        }
      }()
      case 2: try {
        var v: Qdrant_ProductQuantization?
        var hadOneofValue = false
        if let current = self.quantization {
          hadOneofValue = true
          if case .product(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantization = .product(v)
        }
      }()
      case 3: try {
        var v: Qdrant_BinaryQuantization?
        var hadOneofValue = false
        if let current = self.quantization {
          hadOneofValue = true
          if case .binary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantization = .binary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.quantization {
    case .scalar?: try {
      guard case .scalar(let v)? = self.quantization else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .product?: try {
      guard case .product(let v)? = self.quantization else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .binary?: try {
      guard case .binary(let v)? = self.quantization else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QuantizationConfig, rhs: Qdrant_QuantizationConfig) -> Bool {
    if lhs.quantization != rhs.quantization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Disabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Disabled"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Disabled, rhs: Qdrant_Disabled) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QuantizationConfigDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuantizationConfigDiff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}scalar\0\u{1}product\0\u{1}disabled\0\u{1}binary\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_ScalarQuantization?
        var hadOneofValue = false
        if let current = self.quantization {
          hadOneofValue = true
          if case .scalar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantization = .scalar(v)
        }
      }()
      case 2: try {
        var v: Qdrant_ProductQuantization?
        var hadOneofValue = false
        if let current = self.quantization {
          hadOneofValue = true
          if case .product(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantization = .product(v)
        }
      }()
      case 3: try {
        var v: Qdrant_Disabled?
        var hadOneofValue = false
        if let current = self.quantization {
          hadOneofValue = true
          if case .disabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantization = .disabled(v)
        }
      }()
      case 4: try {
        var v: Qdrant_BinaryQuantization?
        var hadOneofValue = false
        if let current = self.quantization {
          hadOneofValue = true
          if case .binary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.quantization = .binary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.quantization {
    case .scalar?: try {
      guard case .scalar(let v)? = self.quantization else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .product?: try {
      guard case .product(let v)? = self.quantization else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .disabled?: try {
      guard case .disabled(let v)? = self.quantization else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .binary?: try {
      guard case .binary(let v)? = self.quantization else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QuantizationConfigDiff, rhs: Qdrant_QuantizationConfigDiff) -> Bool {
    if lhs.quantization != rhs.quantization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_StrictModeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StrictModeConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{3}max_query_limit\0\u{3}max_timeout\0\u{3}unindexed_filtering_retrieve\0\u{3}unindexed_filtering_update\0\u{3}search_max_hnsw_ef\0\u{3}search_allow_exact\0\u{3}search_max_oversampling\0\u{3}upsert_max_batchsize\0\u{3}max_collection_vector_size_bytes\0\u{3}read_rate_limit\0\u{3}write_rate_limit\0\u{3}max_collection_payload_size_bytes\0\u{3}filter_max_conditions\0\u{3}condition_max_size\0\u{3}multivector_config\0\u{3}sparse_config\0\u{3}max_points_count\0\u{3}max_payload_index_count\0")

  fileprivate class _StorageClass {
    var _enabled: Bool? = nil
    var _maxQueryLimit: UInt32? = nil
    var _maxTimeout: UInt32? = nil
    var _unindexedFilteringRetrieve: Bool? = nil
    var _unindexedFilteringUpdate: Bool? = nil
    var _searchMaxHnswEf: UInt32? = nil
    var _searchAllowExact: Bool? = nil
    var _searchMaxOversampling: Float? = nil
    var _upsertMaxBatchsize: UInt64? = nil
    var _maxCollectionVectorSizeBytes: UInt64? = nil
    var _readRateLimit: UInt32? = nil
    var _writeRateLimit: UInt32? = nil
    var _maxCollectionPayloadSizeBytes: UInt64? = nil
    var _filterMaxConditions: UInt64? = nil
    var _conditionMaxSize: UInt64? = nil
    var _multivectorConfig: Qdrant_StrictModeMultivectorConfig? = nil
    var _sparseConfig: Qdrant_StrictModeSparseConfig? = nil
    var _maxPointsCount: UInt64? = nil
    var _maxPayloadIndexCount: UInt64? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _enabled = source._enabled
      _maxQueryLimit = source._maxQueryLimit
      _maxTimeout = source._maxTimeout
      _unindexedFilteringRetrieve = source._unindexedFilteringRetrieve
      _unindexedFilteringUpdate = source._unindexedFilteringUpdate
      _searchMaxHnswEf = source._searchMaxHnswEf
      _searchAllowExact = source._searchAllowExact
      _searchMaxOversampling = source._searchMaxOversampling
      _upsertMaxBatchsize = source._upsertMaxBatchsize
      _maxCollectionVectorSizeBytes = source._maxCollectionVectorSizeBytes
      _readRateLimit = source._readRateLimit
      _writeRateLimit = source._writeRateLimit
      _maxCollectionPayloadSizeBytes = source._maxCollectionPayloadSizeBytes
      _filterMaxConditions = source._filterMaxConditions
      _conditionMaxSize = source._conditionMaxSize
      _multivectorConfig = source._multivectorConfig
      _sparseConfig = source._sparseConfig
      _maxPointsCount = source._maxPointsCount
      _maxPayloadIndexCount = source._maxPayloadIndexCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._enabled) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxQueryLimit) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxTimeout) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._unindexedFilteringRetrieve) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._unindexedFilteringUpdate) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._searchMaxHnswEf) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._searchAllowExact) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._searchMaxOversampling) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._upsertMaxBatchsize) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxCollectionVectorSizeBytes) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._readRateLimit) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._writeRateLimit) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxCollectionPayloadSizeBytes) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._filterMaxConditions) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._conditionMaxSize) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._multivectorConfig) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._sparseConfig) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxPointsCount) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxPayloadIndexCount) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._enabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._maxQueryLimit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._maxTimeout {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._unindexedFilteringRetrieve {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._unindexedFilteringUpdate {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._searchMaxHnswEf {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._searchAllowExact {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._searchMaxOversampling {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._upsertMaxBatchsize {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._maxCollectionVectorSizeBytes {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._readRateLimit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._writeRateLimit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._maxCollectionPayloadSizeBytes {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._filterMaxConditions {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._conditionMaxSize {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._multivectorConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._sparseConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._maxPointsCount {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._maxPayloadIndexCount {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_StrictModeConfig, rhs: Qdrant_StrictModeConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._enabled != rhs_storage._enabled {return false}
        if _storage._maxQueryLimit != rhs_storage._maxQueryLimit {return false}
        if _storage._maxTimeout != rhs_storage._maxTimeout {return false}
        if _storage._unindexedFilteringRetrieve != rhs_storage._unindexedFilteringRetrieve {return false}
        if _storage._unindexedFilteringUpdate != rhs_storage._unindexedFilteringUpdate {return false}
        if _storage._searchMaxHnswEf != rhs_storage._searchMaxHnswEf {return false}
        if _storage._searchAllowExact != rhs_storage._searchAllowExact {return false}
        if _storage._searchMaxOversampling != rhs_storage._searchMaxOversampling {return false}
        if _storage._upsertMaxBatchsize != rhs_storage._upsertMaxBatchsize {return false}
        if _storage._maxCollectionVectorSizeBytes != rhs_storage._maxCollectionVectorSizeBytes {return false}
        if _storage._readRateLimit != rhs_storage._readRateLimit {return false}
        if _storage._writeRateLimit != rhs_storage._writeRateLimit {return false}
        if _storage._maxCollectionPayloadSizeBytes != rhs_storage._maxCollectionPayloadSizeBytes {return false}
        if _storage._filterMaxConditions != rhs_storage._filterMaxConditions {return false}
        if _storage._conditionMaxSize != rhs_storage._conditionMaxSize {return false}
        if _storage._multivectorConfig != rhs_storage._multivectorConfig {return false}
        if _storage._sparseConfig != rhs_storage._sparseConfig {return false}
        if _storage._maxPointsCount != rhs_storage._maxPointsCount {return false}
        if _storage._maxPayloadIndexCount != rhs_storage._maxPayloadIndexCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_StrictModeSparseConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StrictModeSparseConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}sparse_config\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_StrictModeSparse>.self, value: &self.sparseConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sparseConfig.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_StrictModeSparse>.self, value: self.sparseConfig, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_StrictModeSparseConfig, rhs: Qdrant_StrictModeSparseConfig) -> Bool {
    if lhs.sparseConfig != rhs.sparseConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_StrictModeSparse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StrictModeSparse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{a}max_length\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._maxLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxLength {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_StrictModeSparse, rhs: Qdrant_StrictModeSparse) -> Bool {
    if lhs._maxLength != rhs._maxLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_StrictModeMultivectorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StrictModeMultivectorConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}multivector_config\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_StrictModeMultivector>.self, value: &self.multivectorConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.multivectorConfig.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_StrictModeMultivector>.self, value: self.multivectorConfig, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_StrictModeMultivectorConfig, rhs: Qdrant_StrictModeMultivectorConfig) -> Bool {
    if lhs.multivectorConfig != rhs.multivectorConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_StrictModeMultivector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StrictModeMultivector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}max_vectors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._maxVectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxVectors {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_StrictModeMultivector, rhs: Qdrant_StrictModeMultivector) -> Bool {
    if lhs._maxVectors != rhs._maxVectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CreateCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateCollection"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{4}\u{3}hnsw_config\0\u{3}wal_config\0\u{3}optimizers_config\0\u{3}shard_number\0\u{3}on_disk_payload\0\u{1}timeout\0\u{3}vectors_config\0\u{3}replication_factor\0\u{3}write_consistency_factor\0\u{4}\u{2}quantization_config\0\u{3}sharding_method\0\u{3}sparse_vectors_config\0\u{3}strict_mode_config\0\u{1}metadata\0\u{c}\u{2}\u{1}\u{c}\u{3}\u{1}\u{c}\u{d}\u{1}")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _hnswConfig: Qdrant_HnswConfigDiff? = nil
    var _walConfig: Qdrant_WalConfigDiff? = nil
    var _optimizersConfig: Qdrant_OptimizersConfigDiff? = nil
    var _shardNumber: UInt32? = nil
    var _onDiskPayload: Bool? = nil
    var _timeout: UInt64? = nil
    var _vectorsConfig: Qdrant_VectorsConfig? = nil
    var _replicationFactor: UInt32? = nil
    var _writeConsistencyFactor: UInt32? = nil
    var _quantizationConfig: Qdrant_QuantizationConfig? = nil
    var _shardingMethod: Qdrant_ShardingMethod? = nil
    var _sparseVectorsConfig: Qdrant_SparseVectorConfig? = nil
    var _strictModeConfig: Qdrant_StrictModeConfig? = nil
    var _metadata: Dictionary<String,Qdrant_Value> = [:]

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _hnswConfig = source._hnswConfig
      _walConfig = source._walConfig
      _optimizersConfig = source._optimizersConfig
      _shardNumber = source._shardNumber
      _onDiskPayload = source._onDiskPayload
      _timeout = source._timeout
      _vectorsConfig = source._vectorsConfig
      _replicationFactor = source._replicationFactor
      _writeConsistencyFactor = source._writeConsistencyFactor
      _quantizationConfig = source._quantizationConfig
      _shardingMethod = source._shardingMethod
      _sparseVectorsConfig = source._sparseVectorsConfig
      _strictModeConfig = source._strictModeConfig
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._hnswConfig) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._walConfig) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._optimizersConfig) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._shardNumber) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._onDiskPayload) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._vectorsConfig) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._replicationFactor) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._writeConsistencyFactor) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._quantizationConfig) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._shardingMethod) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._sparseVectorsConfig) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._strictModeConfig) }()
        case 18: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      try { if let v = _storage._hnswConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._walConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._optimizersConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._shardNumber {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._onDiskPayload {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._vectorsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._replicationFactor {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._writeConsistencyFactor {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._quantizationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._shardingMethod {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._sparseVectorsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._strictModeConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: _storage._metadata, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CreateCollection, rhs: Qdrant_CreateCollection) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._hnswConfig != rhs_storage._hnswConfig {return false}
        if _storage._walConfig != rhs_storage._walConfig {return false}
        if _storage._optimizersConfig != rhs_storage._optimizersConfig {return false}
        if _storage._shardNumber != rhs_storage._shardNumber {return false}
        if _storage._onDiskPayload != rhs_storage._onDiskPayload {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._vectorsConfig != rhs_storage._vectorsConfig {return false}
        if _storage._replicationFactor != rhs_storage._replicationFactor {return false}
        if _storage._writeConsistencyFactor != rhs_storage._writeConsistencyFactor {return false}
        if _storage._quantizationConfig != rhs_storage._quantizationConfig {return false}
        if _storage._shardingMethod != rhs_storage._shardingMethod {return false}
        if _storage._sparseVectorsConfig != rhs_storage._sparseVectorsConfig {return false}
        if _storage._strictModeConfig != rhs_storage._strictModeConfig {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UpdateCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCollection"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{3}optimizers_config\0\u{1}timeout\0\u{1}params\0\u{3}hnsw_config\0\u{3}vectors_config\0\u{3}quantization_config\0\u{3}sparse_vectors_config\0\u{3}strict_mode_config\0\u{1}metadata\0")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _optimizersConfig: Qdrant_OptimizersConfigDiff? = nil
    var _timeout: UInt64? = nil
    var _params: Qdrant_CollectionParamsDiff? = nil
    var _hnswConfig: Qdrant_HnswConfigDiff? = nil
    var _vectorsConfig: Qdrant_VectorsConfigDiff? = nil
    var _quantizationConfig: Qdrant_QuantizationConfigDiff? = nil
    var _sparseVectorsConfig: Qdrant_SparseVectorConfig? = nil
    var _strictModeConfig: Qdrant_StrictModeConfig? = nil
    var _metadata: Dictionary<String,Qdrant_Value> = [:]

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _optimizersConfig = source._optimizersConfig
      _timeout = source._timeout
      _params = source._params
      _hnswConfig = source._hnswConfig
      _vectorsConfig = source._vectorsConfig
      _quantizationConfig = source._quantizationConfig
      _sparseVectorsConfig = source._sparseVectorsConfig
      _strictModeConfig = source._strictModeConfig
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._optimizersConfig) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._hnswConfig) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._vectorsConfig) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._quantizationConfig) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._sparseVectorsConfig) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._strictModeConfig) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      try { if let v = _storage._optimizersConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._hnswConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._vectorsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._quantizationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._sparseVectorsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._strictModeConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: _storage._metadata, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UpdateCollection, rhs: Qdrant_UpdateCollection) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._optimizersConfig != rhs_storage._optimizersConfig {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._hnswConfig != rhs_storage._hnswConfig {return false}
        if _storage._vectorsConfig != rhs_storage._vectorsConfig {return false}
        if _storage._quantizationConfig != rhs_storage._quantizationConfig {return false}
        if _storage._sparseVectorsConfig != rhs_storage._sparseVectorsConfig {return false}
        if _storage._strictModeConfig != rhs_storage._strictModeConfig {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeleteCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCollection"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeleteCollection, rhs: Qdrant_DeleteCollection) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionOperationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionOperationResponse, rhs: Qdrant_CollectionOperationResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{3}shard_number\0\u{3}on_disk_payload\0\u{3}vectors_config\0\u{3}replication_factor\0\u{3}write_consistency_factor\0\u{3}read_fan_out_factor\0\u{3}sharding_method\0\u{3}sparse_vectors_config\0\u{c}\u{1}\u{1}\u{c}\u{2}\u{1}")

  fileprivate class _StorageClass {
    var _shardNumber: UInt32 = 0
    var _onDiskPayload: Bool = false
    var _vectorsConfig: Qdrant_VectorsConfig? = nil
    var _replicationFactor: UInt32? = nil
    var _writeConsistencyFactor: UInt32? = nil
    var _readFanOutFactor: UInt32? = nil
    var _shardingMethod: Qdrant_ShardingMethod? = nil
    var _sparseVectorsConfig: Qdrant_SparseVectorConfig? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shardNumber = source._shardNumber
      _onDiskPayload = source._onDiskPayload
      _vectorsConfig = source._vectorsConfig
      _replicationFactor = source._replicationFactor
      _writeConsistencyFactor = source._writeConsistencyFactor
      _readFanOutFactor = source._readFanOutFactor
      _shardingMethod = source._shardingMethod
      _sparseVectorsConfig = source._sparseVectorsConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._shardNumber) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._onDiskPayload) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._vectorsConfig) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._replicationFactor) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._writeConsistencyFactor) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._readFanOutFactor) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._shardingMethod) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._sparseVectorsConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._shardNumber != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._shardNumber, fieldNumber: 3)
      }
      if _storage._onDiskPayload != false {
        try visitor.visitSingularBoolField(value: _storage._onDiskPayload, fieldNumber: 4)
      }
      try { if let v = _storage._vectorsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._replicationFactor {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._writeConsistencyFactor {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._readFanOutFactor {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._shardingMethod {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._sparseVectorsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionParams, rhs: Qdrant_CollectionParams) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._shardNumber != rhs_storage._shardNumber {return false}
        if _storage._onDiskPayload != rhs_storage._onDiskPayload {return false}
        if _storage._vectorsConfig != rhs_storage._vectorsConfig {return false}
        if _storage._replicationFactor != rhs_storage._replicationFactor {return false}
        if _storage._writeConsistencyFactor != rhs_storage._writeConsistencyFactor {return false}
        if _storage._readFanOutFactor != rhs_storage._readFanOutFactor {return false}
        if _storage._shardingMethod != rhs_storage._shardingMethod {return false}
        if _storage._sparseVectorsConfig != rhs_storage._sparseVectorsConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionParamsDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionParamsDiff"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}replication_factor\0\u{3}write_consistency_factor\0\u{3}on_disk_payload\0\u{3}read_fan_out_factor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._replicationFactor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._writeConsistencyFactor) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._onDiskPayload) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._readFanOutFactor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._replicationFactor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._writeConsistencyFactor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._onDiskPayload {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._readFanOutFactor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionParamsDiff, rhs: Qdrant_CollectionParamsDiff) -> Bool {
    if lhs._replicationFactor != rhs._replicationFactor {return false}
    if lhs._writeConsistencyFactor != rhs._writeConsistencyFactor {return false}
    if lhs._onDiskPayload != rhs._onDiskPayload {return false}
    if lhs._readFanOutFactor != rhs._readFanOutFactor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}params\0\u{3}hnsw_config\0\u{3}optimizer_config\0\u{3}wal_config\0\u{3}quantization_config\0\u{3}strict_mode_config\0\u{1}metadata\0")

  fileprivate class _StorageClass {
    var _params: Qdrant_CollectionParams? = nil
    var _hnswConfig: Qdrant_HnswConfigDiff? = nil
    var _optimizerConfig: Qdrant_OptimizersConfigDiff? = nil
    var _walConfig: Qdrant_WalConfigDiff? = nil
    var _quantizationConfig: Qdrant_QuantizationConfig? = nil
    var _strictModeConfig: Qdrant_StrictModeConfig? = nil
    var _metadata: Dictionary<String,Qdrant_Value> = [:]

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _hnswConfig = source._hnswConfig
      _optimizerConfig = source._optimizerConfig
      _walConfig = source._walConfig
      _quantizationConfig = source._quantizationConfig
      _strictModeConfig = source._strictModeConfig
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._hnswConfig) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._optimizerConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._walConfig) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._quantizationConfig) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._strictModeConfig) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._hnswConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._optimizerConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._walConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._quantizationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._strictModeConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: _storage._metadata, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionConfig, rhs: Qdrant_CollectionConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._hnswConfig != rhs_storage._hnswConfig {return false}
        if _storage._optimizerConfig != rhs_storage._optimizerConfig {return false}
        if _storage._walConfig != rhs_storage._walConfig {return false}
        if _storage._quantizationConfig != rhs_storage._quantizationConfig {return false}
        if _storage._strictModeConfig != rhs_storage._strictModeConfig {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_KeywordIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeywordIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_tenant\0\u{3}on_disk\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isTenant) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isTenant {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_KeywordIndexParams, rhs: Qdrant_KeywordIndexParams) -> Bool {
    if lhs._isTenant != rhs._isTenant {return false}
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_IntegerIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegerIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lookup\0\u{1}range\0\u{3}is_principal\0\u{3}on_disk\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._lookup) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._range) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isPrincipal) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lookup {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._range {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isPrincipal {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_IntegerIndexParams, rhs: Qdrant_IntegerIndexParams) -> Bool {
    if lhs._lookup != rhs._lookup {return false}
    if lhs._range != rhs._range {return false}
    if lhs._isPrincipal != rhs._isPrincipal {return false}
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_FloatIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FloatIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}on_disk\0\u{3}is_principal\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isPrincipal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isPrincipal {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_FloatIndexParams, rhs: Qdrant_FloatIndexParams) -> Bool {
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs._isPrincipal != rhs._isPrincipal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GeoIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}on_disk\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GeoIndexParams, rhs: Qdrant_GeoIndexParams) -> Bool {
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_StopwordsSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopwordsSet"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}languages\0\u{1}custom\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.languages) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.custom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.languages, fieldNumber: 1)
    }
    if !self.custom.isEmpty {
      try visitor.visitRepeatedStringField(value: self.custom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_StopwordsSet, rhs: Qdrant_StopwordsSet) -> Bool {
    if lhs.languages != rhs.languages {return false}
    if lhs.custom != rhs.custom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_TextIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tokenizer\0\u{1}lowercase\0\u{3}min_token_len\0\u{3}max_token_len\0\u{3}on_disk\0\u{1}stopwords\0\u{3}phrase_matching\0\u{1}stemmer\0\u{3}ascii_folding\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tokenizer) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._lowercase) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._minTokenLen) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._maxTokenLen) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._stopwords) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._phraseMatching) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._stemmer) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._asciiFolding) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.tokenizer != .unknown {
      try visitor.visitSingularEnumField(value: self.tokenizer, fieldNumber: 1)
    }
    try { if let v = self._lowercase {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minTokenLen {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxTokenLen {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._stopwords {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._phraseMatching {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._stemmer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._asciiFolding {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_TextIndexParams, rhs: Qdrant_TextIndexParams) -> Bool {
    if lhs.tokenizer != rhs.tokenizer {return false}
    if lhs._lowercase != rhs._lowercase {return false}
    if lhs._minTokenLen != rhs._minTokenLen {return false}
    if lhs._maxTokenLen != rhs._maxTokenLen {return false}
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs._stopwords != rhs._stopwords {return false}
    if lhs._phraseMatching != rhs._phraseMatching {return false}
    if lhs._stemmer != rhs._stemmer {return false}
    if lhs._asciiFolding != rhs._asciiFolding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_StemmingAlgorithm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StemmingAlgorithm"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}snowball\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_SnowballParams?
        var hadOneofValue = false
        if let current = self.stemmingParams {
          hadOneofValue = true
          if case .snowball(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stemmingParams = .snowball(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .snowball(let v)? = self.stemmingParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_StemmingAlgorithm, rhs: Qdrant_StemmingAlgorithm) -> Bool {
    if lhs.stemmingParams != rhs.stemmingParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SnowballParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SnowballParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}language\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SnowballParams, rhs: Qdrant_SnowballParams) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_BoolIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoolIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}on_disk\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_BoolIndexParams, rhs: Qdrant_BoolIndexParams) -> Bool {
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DatetimeIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatetimeIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}on_disk\0\u{3}is_principal\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isPrincipal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isPrincipal {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DatetimeIndexParams, rhs: Qdrant_DatetimeIndexParams) -> Bool {
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs._isPrincipal != rhs._isPrincipal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UuidIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UuidIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_tenant\0\u{3}on_disk\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._isTenant) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._onDisk) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isTenant {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._onDisk {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UuidIndexParams, rhs: Qdrant_UuidIndexParams) -> Bool {
    if lhs._isTenant != rhs._isTenant {return false}
    if lhs._onDisk != rhs._onDisk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PayloadIndexParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayloadIndexParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}text_index_params\0\u{3}integer_index_params\0\u{3}keyword_index_params\0\u{3}float_index_params\0\u{3}geo_index_params\0\u{3}bool_index_params\0\u{3}datetime_index_params\0\u{3}uuid_index_params\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_TextIndexParams?
        var hadOneofValue = false
        if let current = self.indexParams {
          hadOneofValue = true
          if case .textIndexParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.indexParams = .textIndexParams(v)
        }
      }()
      case 2: try {
        var v: Qdrant_IntegerIndexParams?
        var hadOneofValue = false
        if let current = self.indexParams {
          hadOneofValue = true
          if case .integerIndexParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.indexParams = .integerIndexParams(v)
        }
      }()
      case 3: try {
        var v: Qdrant_KeywordIndexParams?
        var hadOneofValue = false
        if let current = self.indexParams {
          hadOneofValue = true
          if case .keywordIndexParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.indexParams = .keywordIndexParams(v)
        }
      }()
      case 4: try {
        var v: Qdrant_FloatIndexParams?
        var hadOneofValue = false
        if let current = self.indexParams {
          hadOneofValue = true
          if case .floatIndexParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.indexParams = .floatIndexParams(v)
        }
      }()
      case 5: try {
        var v: Qdrant_GeoIndexParams?
        var hadOneofValue = false
        if let current = self.indexParams {
          hadOneofValue = true
          if case .geoIndexParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.indexParams = .geoIndexParams(v)
        }
      }()
      case 6: try {
        var v: Qdrant_BoolIndexParams?
        var hadOneofValue = false
        if let current = self.indexParams {
          hadOneofValue = true
          if case .boolIndexParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.indexParams = .boolIndexParams(v)
        }
      }()
      case 7: try {
        var v: Qdrant_DatetimeIndexParams?
        var hadOneofValue = false
        if let current = self.indexParams {
          hadOneofValue = true
          if case .datetimeIndexParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.indexParams = .datetimeIndexParams(v)
        }
      }()
      case 8: try {
        var v: Qdrant_UuidIndexParams?
        var hadOneofValue = false
        if let current = self.indexParams {
          hadOneofValue = true
          if case .uuidIndexParams(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.indexParams = .uuidIndexParams(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.indexParams {
    case .textIndexParams?: try {
      guard case .textIndexParams(let v)? = self.indexParams else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .integerIndexParams?: try {
      guard case .integerIndexParams(let v)? = self.indexParams else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .keywordIndexParams?: try {
      guard case .keywordIndexParams(let v)? = self.indexParams else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .floatIndexParams?: try {
      guard case .floatIndexParams(let v)? = self.indexParams else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .geoIndexParams?: try {
      guard case .geoIndexParams(let v)? = self.indexParams else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .boolIndexParams?: try {
      guard case .boolIndexParams(let v)? = self.indexParams else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .datetimeIndexParams?: try {
      guard case .datetimeIndexParams(let v)? = self.indexParams else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .uuidIndexParams?: try {
      guard case .uuidIndexParams(let v)? = self.indexParams else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PayloadIndexParams, rhs: Qdrant_PayloadIndexParams) -> Bool {
    if lhs.indexParams != rhs.indexParams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PayloadSchemaInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayloadSchemaInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}data_type\0\u{1}params\0\u{1}points\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dataType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._points) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.dataType != .unknownType {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._points {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PayloadSchemaInfo, rhs: Qdrant_PayloadSchemaInfo) -> Bool {
    if lhs.dataType != rhs.dataType {return false}
    if lhs._params != rhs._params {return false}
    if lhs._points != rhs._points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0\u{3}optimizer_status\0\u{4}\u{2}segments_count\0\u{2}\u{3}config\0\u{3}payload_schema\0\u{3}points_count\0\u{3}indexed_vectors_count\0\u{1}warnings\0\u{c}\u{3}\u{1}\u{c}\u{5}\u{1}\u{c}\u{6}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._optimizerStatus) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.segmentsCount) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_PayloadSchemaInfo>.self, value: &self.payloadSchema) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._pointsCount) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._indexedVectorsCount) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.warnings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unknownCollectionStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._optimizerStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.segmentsCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.segmentsCount, fieldNumber: 4)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.payloadSchema.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_PayloadSchemaInfo>.self, value: self.payloadSchema, fieldNumber: 8)
    }
    try { if let v = self._pointsCount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._indexedVectorsCount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.warnings, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionInfo, rhs: Qdrant_CollectionInfo) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._optimizerStatus != rhs._optimizerStatus {return false}
    if lhs.segmentsCount != rhs.segmentsCount {return false}
    if lhs._config != rhs._config {return false}
    if lhs.payloadSchema != rhs.payloadSchema {return false}
    if lhs._pointsCount != rhs._pointsCount {return false}
    if lhs._indexedVectorsCount != rhs._indexedVectorsCount {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ChangeAliases: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChangeAliases"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}actions\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ChangeAliases, rhs: Qdrant_ChangeAliases) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_AliasOperations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AliasOperations"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}create_alias\0\u{3}rename_alias\0\u{3}delete_alias\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_CreateAlias?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .createAlias(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .createAlias(v)
        }
      }()
      case 2: try {
        var v: Qdrant_RenameAlias?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .renameAlias(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .renameAlias(v)
        }
      }()
      case 3: try {
        var v: Qdrant_DeleteAlias?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .deleteAlias(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .deleteAlias(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .createAlias?: try {
      guard case .createAlias(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .renameAlias?: try {
      guard case .renameAlias(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .deleteAlias?: try {
      guard case .deleteAlias(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_AliasOperations, rhs: Qdrant_AliasOperations) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CreateAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAlias"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{3}alias_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.aliasName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    if !self.aliasName.isEmpty {
      try visitor.visitSingularStringField(value: self.aliasName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CreateAlias, rhs: Qdrant_CreateAlias) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.aliasName != rhs.aliasName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RenameAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenameAlias"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}old_alias_name\0\u{3}new_alias_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oldAliasName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newAliasName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oldAliasName.isEmpty {
      try visitor.visitSingularStringField(value: self.oldAliasName, fieldNumber: 1)
    }
    if !self.newAliasName.isEmpty {
      try visitor.visitSingularStringField(value: self.newAliasName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RenameAlias, rhs: Qdrant_RenameAlias) -> Bool {
    if lhs.oldAliasName != rhs.oldAliasName {return false}
    if lhs.newAliasName != rhs.newAliasName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeleteAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAlias"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}alias_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.aliasName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aliasName.isEmpty {
      try visitor.visitSingularStringField(value: self.aliasName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeleteAlias, rhs: Qdrant_DeleteAlias) -> Bool {
    if lhs.aliasName != rhs.aliasName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ListAliasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAliasesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ListAliasesRequest, rhs: Qdrant_ListAliasesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ListCollectionAliasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollectionAliasesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ListCollectionAliasesRequest, rhs: Qdrant_ListCollectionAliasesRequest) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_AliasDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AliasDescription"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}alias_name\0\u{3}collection_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.aliasName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aliasName.isEmpty {
      try visitor.visitSingularStringField(value: self.aliasName, fieldNumber: 1)
    }
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_AliasDescription, rhs: Qdrant_AliasDescription) -> Bool {
    if lhs.aliasName != rhs.aliasName {return false}
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ListAliasesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAliasesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}aliases\0\u{1}time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.aliases) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aliases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aliases, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ListAliasesResponse, rhs: Qdrant_ListAliasesResponse) -> Bool {
    if lhs.aliases != rhs.aliases {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionClusterInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionClusterInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionClusterInfoRequest, rhs: Qdrant_CollectionClusterInfoRequest) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ShardKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShardKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}keyword\0\u{1}number\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .keyword(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .number(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .keyword?: try {
      guard case .keyword(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .number?: try {
      guard case .number(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ShardKey, rhs: Qdrant_ShardKey) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_LocalShardInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalShardInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{3}points_count\0\u{1}state\0\u{3}shard_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.pointsCount) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._shardKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.pointsCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.pointsCount, fieldNumber: 2)
    }
    if self.state != .active {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try { if let v = self._shardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_LocalShardInfo, rhs: Qdrant_LocalShardInfo) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs.pointsCount != rhs.pointsCount {return false}
    if lhs.state != rhs.state {return false}
    if lhs._shardKey != rhs._shardKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RemoteShardInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteShardInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{3}peer_id\0\u{1}state\0\u{3}shard_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.peerID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._shardKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.peerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.peerID, fieldNumber: 2)
    }
    if self.state != .active {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try { if let v = self._shardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RemoteShardInfo, rhs: Qdrant_RemoteShardInfo) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.state != rhs.state {return false}
    if lhs._shardKey != rhs._shardKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ShardTransferInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShardTransferInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{1}from\0\u{1}to\0\u{1}sync\0\u{3}to_shard_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.from) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.to) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sync) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._toShardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.from != 0 {
      try visitor.visitSingularUInt64Field(value: self.from, fieldNumber: 2)
    }
    if self.to != 0 {
      try visitor.visitSingularUInt64Field(value: self.to, fieldNumber: 3)
    }
    if self.sync != false {
      try visitor.visitSingularBoolField(value: self.sync, fieldNumber: 4)
    }
    try { if let v = self._toShardID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ShardTransferInfo, rhs: Qdrant_ShardTransferInfo) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs._toShardID != rhs._toShardID {return false}
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.sync != rhs.sync {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ReshardingInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReshardingInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{3}peer_id\0\u{3}shard_key\0\u{1}direction\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.peerID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shardKey) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.peerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.peerID, fieldNumber: 2)
    }
    try { if let v = self._shardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.direction != .up {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ReshardingInfo, rhs: Qdrant_ReshardingInfo) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs._shardKey != rhs._shardKey {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CollectionClusterInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionClusterInfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}peer_id\0\u{3}shard_count\0\u{3}local_shards\0\u{3}remote_shards\0\u{3}shard_transfers\0\u{3}resharding_operations\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.peerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.shardCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.localShards) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.remoteShards) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.shardTransfers) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.reshardingOperations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.peerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.peerID, fieldNumber: 1)
    }
    if self.shardCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.shardCount, fieldNumber: 2)
    }
    if !self.localShards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localShards, fieldNumber: 3)
    }
    if !self.remoteShards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.remoteShards, fieldNumber: 4)
    }
    if !self.shardTransfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shardTransfers, fieldNumber: 5)
    }
    if !self.reshardingOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reshardingOperations, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CollectionClusterInfoResponse, rhs: Qdrant_CollectionClusterInfoResponse) -> Bool {
    if lhs.peerID != rhs.peerID {return false}
    if lhs.shardCount != rhs.shardCount {return false}
    if lhs.localShards != rhs.localShards {return false}
    if lhs.remoteShards != rhs.remoteShards {return false}
    if lhs.shardTransfers != rhs.shardTransfers {return false}
    if lhs.reshardingOperations != rhs.reshardingOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_MoveShard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoveShard"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{3}from_peer_id\0\u{3}to_peer_id\0\u{1}method\0\u{3}to_shard_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.fromPeerID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.toPeerID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._method) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._toShardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.fromPeerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.fromPeerID, fieldNumber: 2)
    }
    if self.toPeerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.toPeerID, fieldNumber: 3)
    }
    try { if let v = self._method {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._toShardID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_MoveShard, rhs: Qdrant_MoveShard) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs._toShardID != rhs._toShardID {return false}
    if lhs.fromPeerID != rhs.fromPeerID {return false}
    if lhs.toPeerID != rhs.toPeerID {return false}
    if lhs._method != rhs._method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ReplicateShard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplicateShard"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{3}from_peer_id\0\u{3}to_peer_id\0\u{1}method\0\u{3}to_shard_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.fromPeerID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.toPeerID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._method) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._toShardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.fromPeerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.fromPeerID, fieldNumber: 2)
    }
    if self.toPeerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.toPeerID, fieldNumber: 3)
    }
    try { if let v = self._method {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._toShardID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ReplicateShard, rhs: Qdrant_ReplicateShard) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs._toShardID != rhs._toShardID {return false}
    if lhs.fromPeerID != rhs.fromPeerID {return false}
    if lhs.toPeerID != rhs.toPeerID {return false}
    if lhs._method != rhs._method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_AbortShardTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AbortShardTransfer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{3}from_peer_id\0\u{3}to_peer_id\0\u{3}to_shard_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.fromPeerID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.toPeerID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._toShardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.fromPeerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.fromPeerID, fieldNumber: 2)
    }
    if self.toPeerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.toPeerID, fieldNumber: 3)
    }
    try { if let v = self._toShardID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_AbortShardTransfer, rhs: Qdrant_AbortShardTransfer) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs._toShardID != rhs._toShardID {return false}
    if lhs.fromPeerID != rhs.fromPeerID {return false}
    if lhs.toPeerID != rhs.toPeerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RestartTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestartTransfer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{3}from_peer_id\0\u{3}to_peer_id\0\u{1}method\0\u{3}to_shard_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.fromPeerID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.toPeerID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._toShardID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.fromPeerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.fromPeerID, fieldNumber: 2)
    }
    if self.toPeerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.toPeerID, fieldNumber: 3)
    }
    if self.method != .streamRecords {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 4)
    }
    try { if let v = self._toShardID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RestartTransfer, rhs: Qdrant_RestartTransfer) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs._toShardID != rhs._toShardID {return false}
    if lhs.fromPeerID != rhs.fromPeerID {return false}
    if lhs.toPeerID != rhs.toPeerID {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ReplicatePoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplicatePoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}from_shard_key\0\u{3}to_shard_key\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromShardKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._toShardKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fromShardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._toShardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ReplicatePoints, rhs: Qdrant_ReplicatePoints) -> Bool {
    if lhs._fromShardKey != rhs._fromShardKey {return false}
    if lhs._toShardKey != rhs._toShardKey {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Replica: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Replica"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_id\0\u{3}peer_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.shardID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.peerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shardID != 0 {
      try visitor.visitSingularUInt32Field(value: self.shardID, fieldNumber: 1)
    }
    if self.peerID != 0 {
      try visitor.visitSingularUInt64Field(value: self.peerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Replica, rhs: Qdrant_Replica) -> Bool {
    if lhs.shardID != rhs.shardID {return false}
    if lhs.peerID != rhs.peerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CreateShardKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateShardKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_key\0\u{3}shards_number\0\u{3}replication_factor\0\u{1}placement\0\u{3}initial_state\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shardKey) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._shardsNumber) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._replicationFactor) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.placement) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._initialState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shardsNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._replicationFactor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.placement.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.placement, fieldNumber: 4)
    }
    try { if let v = self._initialState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CreateShardKey, rhs: Qdrant_CreateShardKey) -> Bool {
    if lhs._shardKey != rhs._shardKey {return false}
    if lhs._shardsNumber != rhs._shardsNumber {return false}
    if lhs._replicationFactor != rhs._replicationFactor {return false}
    if lhs.placement != rhs.placement {return false}
    if lhs._initialState != rhs._initialState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeleteShardKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteShardKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shardKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeleteShardKey, rhs: Qdrant_DeleteShardKey) -> Bool {
    if lhs._shardKey != rhs._shardKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UpdateCollectionClusterSetupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCollectionClusterSetupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{3}move_shard\0\u{3}replicate_shard\0\u{3}abort_transfer\0\u{3}drop_replica\0\u{1}timeout\0\u{3}create_shard_key\0\u{3}delete_shard_key\0\u{3}restart_transfer\0\u{3}replicate_points\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try {
        var v: Qdrant_MoveShard?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .moveShard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .moveShard(v)
        }
      }()
      case 3: try {
        var v: Qdrant_ReplicateShard?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .replicateShard(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .replicateShard(v)
        }
      }()
      case 4: try {
        var v: Qdrant_AbortShardTransfer?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .abortTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .abortTransfer(v)
        }
      }()
      case 5: try {
        var v: Qdrant_Replica?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .dropReplica(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .dropReplica(v)
        }
      }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      case 7: try {
        var v: Qdrant_CreateShardKey?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .createShardKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .createShardKey(v)
        }
      }()
      case 8: try {
        var v: Qdrant_DeleteShardKey?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteShardKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteShardKey(v)
        }
      }()
      case 9: try {
        var v: Qdrant_RestartTransfer?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .restartTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .restartTransfer(v)
        }
      }()
      case 10: try {
        var v: Qdrant_ReplicatePoints?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .replicatePoints(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .replicatePoints(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    switch self.operation {
    case .moveShard?: try {
      guard case .moveShard(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .replicateShard?: try {
      guard case .replicateShard(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .abortTransfer?: try {
      guard case .abortTransfer(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .dropReplica?: try {
      guard case .dropReplica(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    switch self.operation {
    case .createShardKey?: try {
      guard case .createShardKey(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleteShardKey?: try {
      guard case .deleteShardKey(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .restartTransfer?: try {
      guard case .restartTransfer(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .replicatePoints?: try {
      guard case .replicatePoints(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UpdateCollectionClusterSetupRequest, rhs: Qdrant_UpdateCollectionClusterSetupRequest) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UpdateCollectionClusterSetupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCollectionClusterSetupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UpdateCollectionClusterSetupResponse, rhs: Qdrant_UpdateCollectionClusterSetupResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CreateShardKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateShardKeyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}request\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CreateShardKeyRequest, rhs: Qdrant_CreateShardKeyRequest) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._request != rhs._request {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeleteShardKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteShardKeyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}request\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeleteShardKeyRequest, rhs: Qdrant_DeleteShardKeyRequest) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._request != rhs._request {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ListShardKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListShardKeysRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ListShardKeysRequest, rhs: Qdrant_ListShardKeysRequest) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CreateShardKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateShardKeyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CreateShardKeyResponse, rhs: Qdrant_CreateShardKeyResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeleteShardKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteShardKeyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeleteShardKeyResponse, rhs: Qdrant_DeleteShardKeyResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ShardKeyDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShardKeyDescription"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ShardKeyDescription, rhs: Qdrant_ShardKeyDescription) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ListShardKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListShardKeysResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_keys\0\u{1}time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shardKeys) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shardKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shardKeys, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ListShardKeysResponse, rhs: Qdrant_ListShardKeysResponse) -> Bool {
    if lhs.shardKeys != rhs.shardKeys {return false}
    if lhs.time != rhs.time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
