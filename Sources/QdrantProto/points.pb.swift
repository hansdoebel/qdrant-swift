// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: points.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Qdrant_WriteOrderingType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Write operations may be reordered, works faster, default
  case weak // = 0

  /// Write operations go through dynamically selected leader,
  /// may be inconsistent for a short period of time in case of leader change
  case medium // = 1

  /// Write operations go through the permanent leader, consistent,
  /// but may be unavailable if leader is down
  case strong // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .weak
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .weak
    case 1: self = .medium
    case 2: self = .strong
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .weak: return 0
    case .medium: return 1
    case .strong: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_WriteOrderingType] = [
    .weak,
    .medium,
    .strong,
  ]

}

public enum Qdrant_ReadConsistencyType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Send request to all nodes and return points which are present on all of them
  case all // = 0

  /// Send requests to all nodes and return points which are present on majority of them
  case majority // = 1

  /// Send requests to half + 1 nodes, return points which are present on all of them
  case quorum // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .all
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .all
    case 1: self = .majority
    case 2: self = .quorum
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .all: return 0
    case .majority: return 1
    case .quorum: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_ReadConsistencyType] = [
    .all,
    .majority,
    .quorum,
  ]

}

public enum Qdrant_FieldType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case keyword // = 0
  case integer // = 1
  case float // = 2
  case geo // = 3
  case text // = 4
  case bool // = 5
  case datetime // = 6
  case uuid // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .keyword
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .keyword
    case 1: self = .integer
    case 2: self = .float
    case 3: self = .geo
    case 4: self = .text
    case 5: self = .bool
    case 6: self = .datetime
    case 7: self = .uuid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .keyword: return 0
    case .integer: return 1
    case .float: return 2
    case .geo: return 3
    case .text: return 4
    case .bool: return 5
    case .datetime: return 6
    case .uuid: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_FieldType] = [
    .keyword,
    .integer,
    .float,
    .geo,
    .text,
    .bool,
    .datetime,
    .uuid,
  ]

}

public enum Qdrant_Direction: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case asc // = 0
  case desc // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .asc
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .asc
    case 1: self = .desc
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .asc: return 0
    case .desc: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_Direction] = [
    .asc,
    .desc,
  ]

}

/// How to use positive and negative vectors to find the results, default is `AverageVector`.
public enum Qdrant_RecommendStrategy: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Average positive and negative vectors and create a single query with the formula
  /// `query = avg_pos + avg_pos - avg_neg`. Then performs normal search.
  case averageVector // = 0

  /// Uses custom search objective. Each candidate is compared against all
  /// examples, its score is then chosen from the `max(max_pos_score, max_neg_score)`.
  /// If the `max_neg_score` is chosen then it is squared and negated.
  case bestScore // = 1

  /// Uses custom search objective. Compares against all inputs, sums all the scores.
  /// Scores against positive vectors are added, against negatives are subtracted.
  case sumScores // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .averageVector
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .averageVector
    case 1: self = .bestScore
    case 2: self = .sumScores
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .averageVector: return 0
    case .bestScore: return 1
    case .sumScores: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_RecommendStrategy] = [
    .averageVector,
    .bestScore,
    .sumScores,
  ]

}

public enum Qdrant_Fusion: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Reciprocal Rank Fusion (with default parameters)
  case rrf // = 0

  /// Distribution-Based Score Fusion
  case dbsf // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .rrf
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rrf
    case 1: self = .dbsf
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .rrf: return 0
    case .dbsf: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_Fusion] = [
    .rrf,
    .dbsf,
  ]

}

/// Sample points from the collection
///
/// Available sampling methods:
///
/// * `random` - Random sampling
public enum Qdrant_Sample: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case random // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .random
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .random
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .random: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_Sample] = [
    .random,
  ]

}

public enum Qdrant_UpdateStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownUpdateStatus // = 0

  /// Update is received, but not processed yet
  case acknowledged // = 1

  /// Update is applied and ready for search
  case completed // = 2

  /// Internal: update is rejected due to an outdated clock
  case clockRejected // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownUpdateStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownUpdateStatus
    case 1: self = .acknowledged
    case 2: self = .completed
    case 3: self = .clockRejected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownUpdateStatus: return 0
    case .acknowledged: return 1
    case .completed: return 2
    case .clockRejected: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  public static let allCases: [Qdrant_UpdateStatus] = [
    .unknownUpdateStatus,
    .acknowledged,
    .completed,
    .clockRejected,
  ]

}

public struct Qdrant_WriteOrdering: Sendable {
  /// Write ordering guarantees
  public var type: Qdrant_WriteOrderingType = .weak

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_ReadConsistency: Sendable {
  public var value: Qdrant_ReadConsistency.OneOf_Value? = nil

  /// Common read consistency configurations
  public var type: Qdrant_ReadConsistencyType {
    get {
      if case .type(let v)? = value {return v}
      return .all
    }
    set {value = .type(newValue)}
  }

  /// Send request to a specified number of nodes,
  /// and return points which are present on all of them
  public var factor: UInt64 {
    get {
      if case .factor(let v)? = value {return v}
      return 0
    }
    set {value = .factor(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable, Sendable {
    /// Common read consistency configurations
    case type(Qdrant_ReadConsistencyType)
    /// Send request to a specified number of nodes,
    /// and return points which are present on all of them
    case factor(UInt64)

  }

  public init() {}
}

public struct Qdrant_SparseIndices: Sendable {
  public var data: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_Document: Sendable {
  /// Text of the document
  public var text: String = String()

  /// Model name
  public var model: String = String()

  /// Model options
  public var options: Dictionary<String,Qdrant_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_Image: Sendable {
  /// Image data, either base64 encoded or URL
  public var image: Qdrant_Value {
    get {return _image ?? Qdrant_Value()}
    set {_image = newValue}
  }
  public var hasImage: Bool {return self._image != nil}
  public mutating func clearImage() {self._image = nil}

  /// Model name
  public var model: String = String()

  /// Model options
  public var options: Dictionary<String,Qdrant_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _image: Qdrant_Value? = nil
}

public struct Qdrant_InferenceObject: Sendable {
  /// Object to infer
  public var object: Qdrant_Value {
    get {return _object ?? Qdrant_Value()}
    set {_object = newValue}
  }
  public var hasObject: Bool {return self._object != nil}
  public mutating func clearObject() {self._object = nil}

  /// Model name
  public var model: String = String()

  /// Model options
  public var options: Dictionary<String,Qdrant_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _object: Qdrant_Value? = nil
}

public struct Qdrant_Vector: Sendable {
  /// Vector data (flatten for multi vectors), deprecated
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var data: [Float] = []

  /// Sparse indices for sparse vectors, deprecated
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var indices: Qdrant_SparseIndices {
    get {return _indices ?? Qdrant_SparseIndices()}
    set {_indices = newValue}
  }
  public var hasIndices: Bool {return self._indices != nil}
  public mutating func clearIndices() {self._indices = nil}

  /// Number of vectors per multi vector, deprecated
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var vectorsCount: UInt32 {
    get {return _vectorsCount ?? 0}
    set {_vectorsCount = newValue}
  }
  public var hasVectorsCount: Bool {return self._vectorsCount != nil}
  public mutating func clearVectorsCount() {self._vectorsCount = nil}

  public var vector: Qdrant_Vector.OneOf_Vector? = nil

  /// Dense vector
  public var dense: Qdrant_DenseVector {
    get {
      if case .dense(let v)? = vector {return v}
      return Qdrant_DenseVector()
    }
    set {vector = .dense(newValue)}
  }

  /// Sparse vector
  public var sparse: Qdrant_SparseVector {
    get {
      if case .sparse(let v)? = vector {return v}
      return Qdrant_SparseVector()
    }
    set {vector = .sparse(newValue)}
  }

  /// Multi dense vector
  public var multiDense: Qdrant_MultiDenseVector {
    get {
      if case .multiDense(let v)? = vector {return v}
      return Qdrant_MultiDenseVector()
    }
    set {vector = .multiDense(newValue)}
  }

  public var document: Qdrant_Document {
    get {
      if case .document(let v)? = vector {return v}
      return Qdrant_Document()
    }
    set {vector = .document(newValue)}
  }

  public var image: Qdrant_Image {
    get {
      if case .image(let v)? = vector {return v}
      return Qdrant_Image()
    }
    set {vector = .image(newValue)}
  }

  public var object: Qdrant_InferenceObject {
    get {
      if case .object(let v)? = vector {return v}
      return Qdrant_InferenceObject()
    }
    set {vector = .object(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Vector: Equatable, Sendable {
    /// Dense vector
    case dense(Qdrant_DenseVector)
    /// Sparse vector
    case sparse(Qdrant_SparseVector)
    /// Multi dense vector
    case multiDense(Qdrant_MultiDenseVector)
    case document(Qdrant_Document)
    case image(Qdrant_Image)
    case object(Qdrant_InferenceObject)

  }

  public init() {}

  fileprivate var _indices: Qdrant_SparseIndices? = nil
  fileprivate var _vectorsCount: UInt32? = nil
}

public struct Qdrant_VectorOutput: Sendable {
  /// Vector data (flatten for multi vectors), deprecated
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var data: [Float] = []

  /// Sparse indices for sparse vectors, deprecated
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var indices: Qdrant_SparseIndices {
    get {return _indices ?? Qdrant_SparseIndices()}
    set {_indices = newValue}
  }
  public var hasIndices: Bool {return self._indices != nil}
  public mutating func clearIndices() {self._indices = nil}

  /// Number of vectors per multi vector, deprecated
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  public var vectorsCount: UInt32 {
    get {return _vectorsCount ?? 0}
    set {_vectorsCount = newValue}
  }
  public var hasVectorsCount: Bool {return self._vectorsCount != nil}
  public mutating func clearVectorsCount() {self._vectorsCount = nil}

  public var vector: Qdrant_VectorOutput.OneOf_Vector? = nil

  /// Dense vector
  public var dense: Qdrant_DenseVector {
    get {
      if case .dense(let v)? = vector {return v}
      return Qdrant_DenseVector()
    }
    set {vector = .dense(newValue)}
  }

  /// Sparse vector
  public var sparse: Qdrant_SparseVector {
    get {
      if case .sparse(let v)? = vector {return v}
      return Qdrant_SparseVector()
    }
    set {vector = .sparse(newValue)}
  }

  /// Multi dense vector
  public var multiDense: Qdrant_MultiDenseVector {
    get {
      if case .multiDense(let v)? = vector {return v}
      return Qdrant_MultiDenseVector()
    }
    set {vector = .multiDense(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Vector: Equatable, Sendable {
    /// Dense vector
    case dense(Qdrant_DenseVector)
    /// Sparse vector
    case sparse(Qdrant_SparseVector)
    /// Multi dense vector
    case multiDense(Qdrant_MultiDenseVector)

  }

  public init() {}

  fileprivate var _indices: Qdrant_SparseIndices? = nil
  fileprivate var _vectorsCount: UInt32? = nil
}

public struct Qdrant_DenseVector: Sendable {
  public var data: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_SparseVector: Sendable {
  public var values: [Float] = []

  public var indices: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_MultiDenseVector: Sendable {
  public var vectors: [Qdrant_DenseVector] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Vector type to be used in queries.
/// Ids will be substituted with their corresponding vectors from the collection.
public struct Qdrant_VectorInput: Sendable {
  public var variant: Qdrant_VectorInput.OneOf_Variant? = nil

  public var id: Qdrant_PointId {
    get {
      if case .id(let v)? = variant {return v}
      return Qdrant_PointId()
    }
    set {variant = .id(newValue)}
  }

  public var dense: Qdrant_DenseVector {
    get {
      if case .dense(let v)? = variant {return v}
      return Qdrant_DenseVector()
    }
    set {variant = .dense(newValue)}
  }

  public var sparse: Qdrant_SparseVector {
    get {
      if case .sparse(let v)? = variant {return v}
      return Qdrant_SparseVector()
    }
    set {variant = .sparse(newValue)}
  }

  public var multiDense: Qdrant_MultiDenseVector {
    get {
      if case .multiDense(let v)? = variant {return v}
      return Qdrant_MultiDenseVector()
    }
    set {variant = .multiDense(newValue)}
  }

  public var document: Qdrant_Document {
    get {
      if case .document(let v)? = variant {return v}
      return Qdrant_Document()
    }
    set {variant = .document(newValue)}
  }

  public var image: Qdrant_Image {
    get {
      if case .image(let v)? = variant {return v}
      return Qdrant_Image()
    }
    set {variant = .image(newValue)}
  }

  public var object: Qdrant_InferenceObject {
    get {
      if case .object(let v)? = variant {return v}
      return Qdrant_InferenceObject()
    }
    set {variant = .object(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable, Sendable {
    case id(Qdrant_PointId)
    case dense(Qdrant_DenseVector)
    case sparse(Qdrant_SparseVector)
    case multiDense(Qdrant_MultiDenseVector)
    case document(Qdrant_Document)
    case image(Qdrant_Image)
    case object(Qdrant_InferenceObject)

  }

  public init() {}
}

public struct Qdrant_ShardKeySelector: Sendable {
  /// List of shard keys which should be used in the request
  public var shardKeys: [Qdrant_ShardKey] = []

  public var fallback: Qdrant_ShardKey {
    get {return _fallback ?? Qdrant_ShardKey()}
    set {_fallback = newValue}
  }
  public var hasFallback: Bool {return self._fallback != nil}
  public mutating func clearFallback() {self._fallback = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fallback: Qdrant_ShardKey? = nil
}

public struct Qdrant_UpsertPoints: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  public var points: [Qdrant_PointStruct] = []

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Option for custom sharding to specify used shard keys
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// If specified, only points that match this filter will be updated, others will be inserted
  public var updateFilter: Qdrant_Filter {
    get {return _updateFilter ?? Qdrant_Filter()}
    set {_updateFilter = newValue}
  }
  public var hasUpdateFilter: Bool {return self._updateFilter != nil}
  public mutating func clearUpdateFilter() {self._updateFilter = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _updateFilter: Qdrant_Filter? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_DeletePoints: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  /// Affected points
  public var points: Qdrant_PointsSelector {
    get {return _points ?? Qdrant_PointsSelector()}
    set {_points = newValue}
  }
  public var hasPoints: Bool {return self._points != nil}
  public mutating func clearPoints() {self._points = nil}

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Option for custom sharding to specify used shard keys
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _points: Qdrant_PointsSelector? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_GetPoints: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// List of points to retrieve
  public var ids: [Qdrant_PointId] = []

  /// Options for specifying which payload to include or not
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _withPayload ?? Qdrant_WithPayloadSelector()}
    set {_withPayload = newValue}
  }
  public var hasWithPayload: Bool {return self._withPayload != nil}
  public mutating func clearWithPayload() {self._withPayload = nil}

  /// Options for specifying which vectors to include into response
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _withVectors ?? Qdrant_WithVectorsSelector()}
    set {_withVectors = newValue}
  }
  public var hasWithVectors: Bool {return self._withVectors != nil}
  public mutating func clearWithVectors() {self._withVectors = nil}

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _readConsistency ?? Qdrant_ReadConsistency()}
    set {_readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return self._readConsistency != nil}
  public mutating func clearReadConsistency() {self._readConsistency = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _withPayload: Qdrant_WithPayloadSelector? = nil
  fileprivate var _withVectors: Qdrant_WithVectorsSelector? = nil
  fileprivate var _readConsistency: Qdrant_ReadConsistency? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_UpdatePointVectors: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  /// List of points and vectors to update
  public var points: [Qdrant_PointVectors] = []

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Option for custom sharding to specify used shard keys
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// If specified, only points that match this filter will be updated
  public var updateFilter: Qdrant_Filter {
    get {return _updateFilter ?? Qdrant_Filter()}
    set {_updateFilter = newValue}
  }
  public var hasUpdateFilter: Bool {return self._updateFilter != nil}
  public mutating func clearUpdateFilter() {self._updateFilter = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _updateFilter: Qdrant_Filter? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_PointVectors: Sendable {
  /// ID to update vectors for
  public var id: Qdrant_PointId {
    get {return _id ?? Qdrant_PointId()}
    set {_id = newValue}
  }
  public var hasID: Bool {return self._id != nil}
  public mutating func clearID() {self._id = nil}

  /// Named vectors to update, leave others intact
  public var vectors: Qdrant_Vectors {
    get {return _vectors ?? Qdrant_Vectors()}
    set {_vectors = newValue}
  }
  public var hasVectors: Bool {return self._vectors != nil}
  public mutating func clearVectors() {self._vectors = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Qdrant_PointId? = nil
  fileprivate var _vectors: Qdrant_Vectors? = nil
}

public struct Qdrant_DeletePointVectors: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  /// Affected points
  public var pointsSelector: Qdrant_PointsSelector {
    get {return _pointsSelector ?? Qdrant_PointsSelector()}
    set {_pointsSelector = newValue}
  }
  public var hasPointsSelector: Bool {return self._pointsSelector != nil}
  public mutating func clearPointsSelector() {self._pointsSelector = nil}

  /// List of vector names to delete
  public var vectors: Qdrant_VectorsSelector {
    get {return _vectors ?? Qdrant_VectorsSelector()}
    set {_vectors = newValue}
  }
  public var hasVectors: Bool {return self._vectors != nil}
  public mutating func clearVectors() {self._vectors = nil}

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Option for custom sharding to specify used shard keys
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _pointsSelector: Qdrant_PointsSelector? = nil
  fileprivate var _vectors: Qdrant_VectorsSelector? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_SetPayloadPoints: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  /// New payload values
  public var payload: Dictionary<String,Qdrant_Value> = [:]

  /// Affected points
  public var pointsSelector: Qdrant_PointsSelector {
    get {return _pointsSelector ?? Qdrant_PointsSelector()}
    set {_pointsSelector = newValue}
  }
  public var hasPointsSelector: Bool {return self._pointsSelector != nil}
  public mutating func clearPointsSelector() {self._pointsSelector = nil}

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Option for custom sharding to specify used shard keys
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// Option for indicate property of payload
  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  public var hasKey: Bool {return self._key != nil}
  public mutating func clearKey() {self._key = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _pointsSelector: Qdrant_PointsSelector? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _key: String? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_DeletePayloadPoints: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  /// List of keys to delete
  public var keys: [String] = []

  /// Affected points
  public var pointsSelector: Qdrant_PointsSelector {
    get {return _pointsSelector ?? Qdrant_PointsSelector()}
    set {_pointsSelector = newValue}
  }
  public var hasPointsSelector: Bool {return self._pointsSelector != nil}
  public mutating func clearPointsSelector() {self._pointsSelector = nil}

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Option for custom sharding to specify used shard keys
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _pointsSelector: Qdrant_PointsSelector? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_ClearPayloadPoints: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  /// Affected points
  public var points: Qdrant_PointsSelector {
    get {return _points ?? Qdrant_PointsSelector()}
    set {_points = newValue}
  }
  public var hasPoints: Bool {return self._points != nil}
  public mutating func clearPoints() {self._points = nil}

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Option for custom sharding to specify used shard keys
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _points: Qdrant_PointsSelector? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_CreateFieldIndexCollection: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  /// Field name to index
  public var fieldName: String = String()

  /// Field type.
  public var fieldType: Qdrant_FieldType {
    get {return _fieldType ?? .keyword}
    set {_fieldType = newValue}
  }
  public var hasFieldType: Bool {return self._fieldType != nil}
  public mutating func clearFieldType() {self._fieldType = nil}

  /// Payload index params.
  public var fieldIndexParams: Qdrant_PayloadIndexParams {
    get {return _fieldIndexParams ?? Qdrant_PayloadIndexParams()}
    set {_fieldIndexParams = newValue}
  }
  public var hasFieldIndexParams: Bool {return self._fieldIndexParams != nil}
  public mutating func clearFieldIndexParams() {self._fieldIndexParams = nil}

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _fieldType: Qdrant_FieldType? = nil
  fileprivate var _fieldIndexParams: Qdrant_PayloadIndexParams? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_DeleteFieldIndexCollection: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  /// Field name to delete
  public var fieldName: String = String()

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Timeout for the request in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_PayloadIncludeSelector: Sendable {
  /// List of payload keys to include into result
  public var fields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_PayloadExcludeSelector: Sendable {
  /// List of payload keys to exclude from the result
  public var fields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_WithPayloadSelector: Sendable {
  public var selectorOptions: Qdrant_WithPayloadSelector.OneOf_SelectorOptions? = nil

  /// If `true` - return all payload, if `false` - none
  public var enable: Bool {
    get {
      if case .enable(let v)? = selectorOptions {return v}
      return false
    }
    set {selectorOptions = .enable(newValue)}
  }

  public var include: Qdrant_PayloadIncludeSelector {
    get {
      if case .include(let v)? = selectorOptions {return v}
      return Qdrant_PayloadIncludeSelector()
    }
    set {selectorOptions = .include(newValue)}
  }

  public var exclude: Qdrant_PayloadExcludeSelector {
    get {
      if case .exclude(let v)? = selectorOptions {return v}
      return Qdrant_PayloadExcludeSelector()
    }
    set {selectorOptions = .exclude(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SelectorOptions: Equatable, Sendable {
    /// If `true` - return all payload, if `false` - none
    case enable(Bool)
    case include(Qdrant_PayloadIncludeSelector)
    case exclude(Qdrant_PayloadExcludeSelector)

  }

  public init() {}
}

public struct Qdrant_NamedVectors: Sendable {
  public var vectors: Dictionary<String,Qdrant_Vector> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_NamedVectorsOutput: Sendable {
  public var vectors: Dictionary<String,Qdrant_VectorOutput> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_Vectors: Sendable {
  public var vectorsOptions: Qdrant_Vectors.OneOf_VectorsOptions? = nil

  public var vector: Qdrant_Vector {
    get {
      if case .vector(let v)? = vectorsOptions {return v}
      return Qdrant_Vector()
    }
    set {vectorsOptions = .vector(newValue)}
  }

  public var vectors: Qdrant_NamedVectors {
    get {
      if case .vectors(let v)? = vectorsOptions {return v}
      return Qdrant_NamedVectors()
    }
    set {vectorsOptions = .vectors(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_VectorsOptions: Equatable, Sendable {
    case vector(Qdrant_Vector)
    case vectors(Qdrant_NamedVectors)

  }

  public init() {}
}

public struct Qdrant_VectorsOutput: Sendable {
  public var vectorsOptions: Qdrant_VectorsOutput.OneOf_VectorsOptions? = nil

  public var vector: Qdrant_VectorOutput {
    get {
      if case .vector(let v)? = vectorsOptions {return v}
      return Qdrant_VectorOutput()
    }
    set {vectorsOptions = .vector(newValue)}
  }

  public var vectors: Qdrant_NamedVectorsOutput {
    get {
      if case .vectors(let v)? = vectorsOptions {return v}
      return Qdrant_NamedVectorsOutput()
    }
    set {vectorsOptions = .vectors(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_VectorsOptions: Equatable, Sendable {
    case vector(Qdrant_VectorOutput)
    case vectors(Qdrant_NamedVectorsOutput)

  }

  public init() {}
}

public struct Qdrant_VectorsSelector: Sendable {
  /// List of vectors to include into result
  public var names: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_WithVectorsSelector: Sendable {
  public var selectorOptions: Qdrant_WithVectorsSelector.OneOf_SelectorOptions? = nil

  /// If `true` - return all vectors, if `false` - none
  public var enable: Bool {
    get {
      if case .enable(let v)? = selectorOptions {return v}
      return false
    }
    set {selectorOptions = .enable(newValue)}
  }

  /// List of vectors to include into result
  public var include: Qdrant_VectorsSelector {
    get {
      if case .include(let v)? = selectorOptions {return v}
      return Qdrant_VectorsSelector()
    }
    set {selectorOptions = .include(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SelectorOptions: Equatable, Sendable {
    /// If `true` - return all vectors, if `false` - none
    case enable(Bool)
    /// List of vectors to include into result
    case include(Qdrant_VectorsSelector)

  }

  public init() {}
}

public struct Qdrant_QuantizationSearchParams: Sendable {
  /// If set to true, search will ignore quantized vector data
  public var ignore: Bool {
    get {return _ignore ?? false}
    set {_ignore = newValue}
  }
  public var hasIgnore: Bool {return self._ignore != nil}
  public mutating func clearIgnore() {self._ignore = nil}

  /// If true, use original vectors to re-score top-k results.
  /// If ignored, qdrant decides automatically does rescore enabled or not.
  public var rescore: Bool {
    get {return _rescore ?? false}
    set {_rescore = newValue}
  }
  public var hasRescore: Bool {return self._rescore != nil}
  public mutating func clearRescore() {self._rescore = nil}

  /// Oversampling factor for quantization.
  ///
  /// Defines how many extra vectors should be pre-selected using quantized index,
  /// and then re-scored using original vectors.
  ///
  /// For example, if `oversampling` is 2.4 and `limit` is 100,
  /// then 240 vectors will be pre-selected using quantized index,
  /// and then top-100 will be returned after re-scoring.
  public var oversampling: Double {
    get {return _oversampling ?? 0}
    set {_oversampling = newValue}
  }
  public var hasOversampling: Bool {return self._oversampling != nil}
  public mutating func clearOversampling() {self._oversampling = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ignore: Bool? = nil
  fileprivate var _rescore: Bool? = nil
  fileprivate var _oversampling: Double? = nil
}

public struct Qdrant_AcornSearchParams: Sendable {
  /// If true, then ACORN may be used for the HNSW search based on filters
  /// selectivity.
  ///
  /// Improves search recall for searches with multiple low-selectivity
  /// payload filters, at cost of performance.
  public var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  public var hasEnable: Bool {return self._enable != nil}
  public mutating func clearEnable() {self._enable = nil}

  /// Maximum selectivity of filters to enable ACORN.
  ///
  /// If estimated filters selectivity is higher than this value,
  /// ACORN will not be used. Selectivity is estimated as:
  /// `estimated number of points satisfying the filters / total number of points`.
  ///
  /// 0.0 for never, 1.0 for always. Default is 0.4.
  public var maxSelectivity: Double {
    get {return _maxSelectivity ?? 0}
    set {_maxSelectivity = newValue}
  }
  public var hasMaxSelectivity: Bool {return self._maxSelectivity != nil}
  public mutating func clearMaxSelectivity() {self._maxSelectivity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _enable: Bool? = nil
  fileprivate var _maxSelectivity: Double? = nil
}

public struct Qdrant_SearchParams: Sendable {
  /// Params relevant to HNSW index. Size of the beam in a beam-search.
  /// Larger the value - more accurate the result, more time required for search.
  public var hnswEf: UInt64 {
    get {return _hnswEf ?? 0}
    set {_hnswEf = newValue}
  }
  public var hasHnswEf: Bool {return self._hnswEf != nil}
  public mutating func clearHnswEf() {self._hnswEf = nil}

  /// Search without approximation. If set to true, search may run long but with exact results.
  public var exact: Bool {
    get {return _exact ?? false}
    set {_exact = newValue}
  }
  public var hasExact: Bool {return self._exact != nil}
  public mutating func clearExact() {self._exact = nil}

  /// If set to true, search will ignore quantized vector data
  public var quantization: Qdrant_QuantizationSearchParams {
    get {return _quantization ?? Qdrant_QuantizationSearchParams()}
    set {_quantization = newValue}
  }
  public var hasQuantization: Bool {return self._quantization != nil}
  public mutating func clearQuantization() {self._quantization = nil}

  /// If enabled, the engine will only perform search among indexed or small segments.
  /// Using this option prevents slow searches in case of delayed index, but does not
  /// guarantee that all uploaded vectors will be included in search results
  public var indexedOnly: Bool {
    get {return _indexedOnly ?? false}
    set {_indexedOnly = newValue}
  }
  public var hasIndexedOnly: Bool {return self._indexedOnly != nil}
  public mutating func clearIndexedOnly() {self._indexedOnly = nil}

  /// ACORN search params
  public var acorn: Qdrant_AcornSearchParams {
    get {return _acorn ?? Qdrant_AcornSearchParams()}
    set {_acorn = newValue}
  }
  public var hasAcorn: Bool {return self._acorn != nil}
  public mutating func clearAcorn() {self._acorn = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hnswEf: UInt64? = nil
  fileprivate var _exact: Bool? = nil
  fileprivate var _quantization: Qdrant_QuantizationSearchParams? = nil
  fileprivate var _indexedOnly: Bool? = nil
  fileprivate var _acorn: Qdrant_AcornSearchParams? = nil
}

public struct Qdrant_SearchPoints: @unchecked Sendable {
  /// name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// vector
  public var vector: [Float] {
    get {return _storage._vector}
    set {_uniqueStorage()._vector = newValue}
  }

  /// Filter conditions - return only those points that satisfy the specified conditions
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Max number of result
  public var limit: UInt64 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  /// Options for specifying which payload to include or not
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _storage._withPayload ?? Qdrant_WithPayloadSelector()}
    set {_uniqueStorage()._withPayload = newValue}
  }
  public var hasWithPayload: Bool {return _storage._withPayload != nil}
  public mutating func clearWithPayload() {_uniqueStorage()._withPayload = nil}

  /// Search config
  public var params: Qdrant_SearchParams {
    get {return _storage._params ?? Qdrant_SearchParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// If provided - cut off results with worse scores
  public var scoreThreshold: Float {
    get {return _storage._scoreThreshold ?? 0}
    set {_uniqueStorage()._scoreThreshold = newValue}
  }
  public var hasScoreThreshold: Bool {return _storage._scoreThreshold != nil}
  public mutating func clearScoreThreshold() {_uniqueStorage()._scoreThreshold = nil}

  /// Offset of the result
  public var offset: UInt64 {
    get {return _storage._offset ?? 0}
    set {_uniqueStorage()._offset = newValue}
  }
  public var hasOffset: Bool {return _storage._offset != nil}
  public mutating func clearOffset() {_uniqueStorage()._offset = nil}

  /// Which vector to use for search, if not specified - use default vector
  public var vectorName: String {
    get {return _storage._vectorName ?? String()}
    set {_uniqueStorage()._vectorName = newValue}
  }
  public var hasVectorName: Bool {return _storage._vectorName != nil}
  public mutating func clearVectorName() {_uniqueStorage()._vectorName = nil}

  /// Options for specifying which vectors to include into response
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _storage._withVectors ?? Qdrant_WithVectorsSelector()}
    set {_uniqueStorage()._withVectors = newValue}
  }
  public var hasWithVectors: Bool {return _storage._withVectors != nil}
  public mutating func clearWithVectors() {_uniqueStorage()._withVectors = nil}

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _storage._readConsistency ?? Qdrant_ReadConsistency()}
    set {_uniqueStorage()._readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return _storage._readConsistency != nil}
  public mutating func clearReadConsistency() {_uniqueStorage()._readConsistency = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _storage._shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_uniqueStorage()._shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return _storage._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {_uniqueStorage()._shardKeySelector = nil}

  public var sparseIndices: Qdrant_SparseIndices {
    get {return _storage._sparseIndices ?? Qdrant_SparseIndices()}
    set {_uniqueStorage()._sparseIndices = newValue}
  }
  public var hasSparseIndices: Bool {return _storage._sparseIndices != nil}
  public mutating func clearSparseIndices() {_uniqueStorage()._sparseIndices = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_SearchBatchPoints: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  public var searchPoints: [Qdrant_SearchPoints] = []

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _readConsistency ?? Qdrant_ReadConsistency()}
    set {_readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return self._readConsistency != nil}
  public mutating func clearReadConsistency() {self._readConsistency = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readConsistency: Qdrant_ReadConsistency? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_WithLookup: Sendable {
  /// Name of the collection to use for points lookup
  public var collection: String = String()

  /// Options for specifying which payload to include (or not)
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _withPayload ?? Qdrant_WithPayloadSelector()}
    set {_withPayload = newValue}
  }
  public var hasWithPayload: Bool {return self._withPayload != nil}
  public mutating func clearWithPayload() {self._withPayload = nil}

  /// Options for specifying which vectors to include (or not)
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _withVectors ?? Qdrant_WithVectorsSelector()}
    set {_withVectors = newValue}
  }
  public var hasWithVectors: Bool {return self._withVectors != nil}
  public mutating func clearWithVectors() {self._withVectors = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _withPayload: Qdrant_WithPayloadSelector? = nil
  fileprivate var _withVectors: Qdrant_WithVectorsSelector? = nil
}

public struct Qdrant_SearchPointGroups: @unchecked Sendable {
  /// Name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// Vector to compare against
  public var vector: [Float] {
    get {return _storage._vector}
    set {_uniqueStorage()._vector = newValue}
  }

  /// Filter conditions - return only those points that satisfy the specified conditions
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Max number of result
  public var limit: UInt32 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  /// Options for specifying which payload to include or not
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _storage._withPayload ?? Qdrant_WithPayloadSelector()}
    set {_uniqueStorage()._withPayload = newValue}
  }
  public var hasWithPayload: Bool {return _storage._withPayload != nil}
  public mutating func clearWithPayload() {_uniqueStorage()._withPayload = nil}

  /// Search config
  public var params: Qdrant_SearchParams {
    get {return _storage._params ?? Qdrant_SearchParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// If provided - cut off results with worse scores
  public var scoreThreshold: Float {
    get {return _storage._scoreThreshold ?? 0}
    set {_uniqueStorage()._scoreThreshold = newValue}
  }
  public var hasScoreThreshold: Bool {return _storage._scoreThreshold != nil}
  public mutating func clearScoreThreshold() {_uniqueStorage()._scoreThreshold = nil}

  /// Which vector to use for search, if not specified - use default vector
  public var vectorName: String {
    get {return _storage._vectorName ?? String()}
    set {_uniqueStorage()._vectorName = newValue}
  }
  public var hasVectorName: Bool {return _storage._vectorName != nil}
  public mutating func clearVectorName() {_uniqueStorage()._vectorName = nil}

  /// Options for specifying which vectors to include into response
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _storage._withVectors ?? Qdrant_WithVectorsSelector()}
    set {_uniqueStorage()._withVectors = newValue}
  }
  public var hasWithVectors: Bool {return _storage._withVectors != nil}
  public mutating func clearWithVectors() {_uniqueStorage()._withVectors = nil}

  /// Payload field to group by, must be a string or number field.
  /// If there are multiple values for the field, all of them will be used.
  /// One point can be in multiple groups.
  public var groupBy: String {
    get {return _storage._groupBy}
    set {_uniqueStorage()._groupBy = newValue}
  }

  /// Maximum amount of points to return per group
  public var groupSize: UInt32 {
    get {return _storage._groupSize}
    set {_uniqueStorage()._groupSize = newValue}
  }

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _storage._readConsistency ?? Qdrant_ReadConsistency()}
    set {_uniqueStorage()._readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return _storage._readConsistency != nil}
  public mutating func clearReadConsistency() {_uniqueStorage()._readConsistency = nil}

  /// Options for specifying how to use the group id to lookup points in another collection
  public var withLookup: Qdrant_WithLookup {
    get {return _storage._withLookup ?? Qdrant_WithLookup()}
    set {_uniqueStorage()._withLookup = newValue}
  }
  public var hasWithLookup: Bool {return _storage._withLookup != nil}
  public mutating func clearWithLookup() {_uniqueStorage()._withLookup = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _storage._shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_uniqueStorage()._shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return _storage._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {_uniqueStorage()._shardKeySelector = nil}

  public var sparseIndices: Qdrant_SparseIndices {
    get {return _storage._sparseIndices ?? Qdrant_SparseIndices()}
    set {_uniqueStorage()._sparseIndices = newValue}
  }
  public var hasSparseIndices: Bool {return _storage._sparseIndices != nil}
  public mutating func clearSparseIndices() {_uniqueStorage()._sparseIndices = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_StartFrom: Sendable {
  public var value: Qdrant_StartFrom.OneOf_Value? = nil

  public var float: Double {
    get {
      if case .float(let v)? = value {return v}
      return 0
    }
    set {value = .float(newValue)}
  }

  public var integer: Int64 {
    get {
      if case .integer(let v)? = value {return v}
      return 0
    }
    set {value = .integer(newValue)}
  }

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .timestamp(let v)? = value {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {value = .timestamp(newValue)}
  }

  public var datetime: String {
    get {
      if case .datetime(let v)? = value {return v}
      return String()
    }
    set {value = .datetime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable, Sendable {
    case float(Double)
    case integer(Int64)
    case timestamp(SwiftProtobuf.Google_Protobuf_Timestamp)
    case datetime(String)

  }

  public init() {}
}

public struct Qdrant_OrderBy: Sendable {
  /// Payload key to order by
  public var key: String = String()

  /// Ascending or descending order
  public var direction: Qdrant_Direction {
    get {return _direction ?? .asc}
    set {_direction = newValue}
  }
  public var hasDirection: Bool {return self._direction != nil}
  public mutating func clearDirection() {self._direction = nil}

  /// Start from this value
  public var startFrom: Qdrant_StartFrom {
    get {return _startFrom ?? Qdrant_StartFrom()}
    set {_startFrom = newValue}
  }
  public var hasStartFrom: Bool {return self._startFrom != nil}
  public mutating func clearStartFrom() {self._startFrom = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _direction: Qdrant_Direction? = nil
  fileprivate var _startFrom: Qdrant_StartFrom? = nil
}

public struct Qdrant_ScrollPoints: @unchecked Sendable {
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// Filter conditions - return only those points that satisfy the specified conditions
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Start with this ID
  public var offset: Qdrant_PointId {
    get {return _storage._offset ?? Qdrant_PointId()}
    set {_uniqueStorage()._offset = newValue}
  }
  public var hasOffset: Bool {return _storage._offset != nil}
  public mutating func clearOffset() {_uniqueStorage()._offset = nil}

  /// Max number of result
  public var limit: UInt32 {
    get {return _storage._limit ?? 0}
    set {_uniqueStorage()._limit = newValue}
  }
  public var hasLimit: Bool {return _storage._limit != nil}
  public mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// Options for specifying which payload to include or not
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _storage._withPayload ?? Qdrant_WithPayloadSelector()}
    set {_uniqueStorage()._withPayload = newValue}
  }
  public var hasWithPayload: Bool {return _storage._withPayload != nil}
  public mutating func clearWithPayload() {_uniqueStorage()._withPayload = nil}

  /// Options for specifying which vectors to include into response
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _storage._withVectors ?? Qdrant_WithVectorsSelector()}
    set {_uniqueStorage()._withVectors = newValue}
  }
  public var hasWithVectors: Bool {return _storage._withVectors != nil}
  public mutating func clearWithVectors() {_uniqueStorage()._withVectors = nil}

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _storage._readConsistency ?? Qdrant_ReadConsistency()}
    set {_uniqueStorage()._readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return _storage._readConsistency != nil}
  public mutating func clearReadConsistency() {_uniqueStorage()._readConsistency = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _storage._shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_uniqueStorage()._shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return _storage._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {_uniqueStorage()._shardKeySelector = nil}

  /// Order the records by a payload field
  public var orderBy: Qdrant_OrderBy {
    get {return _storage._orderBy ?? Qdrant_OrderBy()}
    set {_uniqueStorage()._orderBy = newValue}
  }
  public var hasOrderBy: Bool {return _storage._orderBy != nil}
  public mutating func clearOrderBy() {_uniqueStorage()._orderBy = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_LookupLocation: Sendable {
  public var collectionName: String = String()

  /// Which vector to use for search, if not specified - use default vector
  public var vectorName: String {
    get {return _vectorName ?? String()}
    set {_vectorName = newValue}
  }
  public var hasVectorName: Bool {return self._vectorName != nil}
  public mutating func clearVectorName() {self._vectorName = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vectorName: String? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
}

public struct Qdrant_RecommendPoints: @unchecked Sendable {
  /// name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// Look for vectors closest to the vectors from these points
  public var positive: [Qdrant_PointId] {
    get {return _storage._positive}
    set {_uniqueStorage()._positive = newValue}
  }

  /// Try to avoid vectors like the vector from these points
  public var negative: [Qdrant_PointId] {
    get {return _storage._negative}
    set {_uniqueStorage()._negative = newValue}
  }

  /// Filter conditions - return only those points that satisfy the specified conditions
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Max number of result
  public var limit: UInt64 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  /// Options for specifying which payload to include or not
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _storage._withPayload ?? Qdrant_WithPayloadSelector()}
    set {_uniqueStorage()._withPayload = newValue}
  }
  public var hasWithPayload: Bool {return _storage._withPayload != nil}
  public mutating func clearWithPayload() {_uniqueStorage()._withPayload = nil}

  /// Search config
  public var params: Qdrant_SearchParams {
    get {return _storage._params ?? Qdrant_SearchParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// If provided - cut off results with worse scores
  public var scoreThreshold: Float {
    get {return _storage._scoreThreshold ?? 0}
    set {_uniqueStorage()._scoreThreshold = newValue}
  }
  public var hasScoreThreshold: Bool {return _storage._scoreThreshold != nil}
  public mutating func clearScoreThreshold() {_uniqueStorage()._scoreThreshold = nil}

  /// Offset of the result
  public var offset: UInt64 {
    get {return _storage._offset ?? 0}
    set {_uniqueStorage()._offset = newValue}
  }
  public var hasOffset: Bool {return _storage._offset != nil}
  public mutating func clearOffset() {_uniqueStorage()._offset = nil}

  /// Define which vector to use for recommendation, if not specified - default vector
  public var using: String {
    get {return _storage._using ?? String()}
    set {_uniqueStorage()._using = newValue}
  }
  public var hasUsing: Bool {return _storage._using != nil}
  public mutating func clearUsing() {_uniqueStorage()._using = nil}

  /// Options for specifying which vectors to include into response
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _storage._withVectors ?? Qdrant_WithVectorsSelector()}
    set {_uniqueStorage()._withVectors = newValue}
  }
  public var hasWithVectors: Bool {return _storage._withVectors != nil}
  public mutating func clearWithVectors() {_uniqueStorage()._withVectors = nil}

  /// Name of the collection to use for points lookup, if not specified - use current collection
  public var lookupFrom: Qdrant_LookupLocation {
    get {return _storage._lookupFrom ?? Qdrant_LookupLocation()}
    set {_uniqueStorage()._lookupFrom = newValue}
  }
  public var hasLookupFrom: Bool {return _storage._lookupFrom != nil}
  public mutating func clearLookupFrom() {_uniqueStorage()._lookupFrom = nil}

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _storage._readConsistency ?? Qdrant_ReadConsistency()}
    set {_uniqueStorage()._readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return _storage._readConsistency != nil}
  public mutating func clearReadConsistency() {_uniqueStorage()._readConsistency = nil}

  /// How to use the example vectors to find the results
  public var strategy: Qdrant_RecommendStrategy {
    get {return _storage._strategy ?? .averageVector}
    set {_uniqueStorage()._strategy = newValue}
  }
  public var hasStrategy: Bool {return _storage._strategy != nil}
  public mutating func clearStrategy() {_uniqueStorage()._strategy = nil}

  /// Look for vectors closest to those
  public var positiveVectors: [Qdrant_Vector] {
    get {return _storage._positiveVectors}
    set {_uniqueStorage()._positiveVectors = newValue}
  }

  /// Try to avoid vectors like this
  public var negativeVectors: [Qdrant_Vector] {
    get {return _storage._negativeVectors}
    set {_uniqueStorage()._negativeVectors = newValue}
  }

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _storage._shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_uniqueStorage()._shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return _storage._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {_uniqueStorage()._shardKeySelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_RecommendBatchPoints: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  public var recommendPoints: [Qdrant_RecommendPoints] = []

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _readConsistency ?? Qdrant_ReadConsistency()}
    set {_readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return self._readConsistency != nil}
  public mutating func clearReadConsistency() {self._readConsistency = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readConsistency: Qdrant_ReadConsistency? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_RecommendPointGroups: @unchecked Sendable {
  /// Name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// Look for vectors closest to the vectors from these points
  public var positive: [Qdrant_PointId] {
    get {return _storage._positive}
    set {_uniqueStorage()._positive = newValue}
  }

  /// Try to avoid vectors like the vector from these points
  public var negative: [Qdrant_PointId] {
    get {return _storage._negative}
    set {_uniqueStorage()._negative = newValue}
  }

  /// Filter conditions - return only those points that satisfy the specified conditions
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Max number of groups in result
  public var limit: UInt32 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  /// Options for specifying which payload to include or not
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _storage._withPayload ?? Qdrant_WithPayloadSelector()}
    set {_uniqueStorage()._withPayload = newValue}
  }
  public var hasWithPayload: Bool {return _storage._withPayload != nil}
  public mutating func clearWithPayload() {_uniqueStorage()._withPayload = nil}

  /// Search config
  public var params: Qdrant_SearchParams {
    get {return _storage._params ?? Qdrant_SearchParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// If provided - cut off results with worse scores
  public var scoreThreshold: Float {
    get {return _storage._scoreThreshold ?? 0}
    set {_uniqueStorage()._scoreThreshold = newValue}
  }
  public var hasScoreThreshold: Bool {return _storage._scoreThreshold != nil}
  public mutating func clearScoreThreshold() {_uniqueStorage()._scoreThreshold = nil}

  /// Define which vector to use for recommendation, if not specified - default vector
  public var using: String {
    get {return _storage._using ?? String()}
    set {_uniqueStorage()._using = newValue}
  }
  public var hasUsing: Bool {return _storage._using != nil}
  public mutating func clearUsing() {_uniqueStorage()._using = nil}

  /// Options for specifying which vectors to include into response
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _storage._withVectors ?? Qdrant_WithVectorsSelector()}
    set {_uniqueStorage()._withVectors = newValue}
  }
  public var hasWithVectors: Bool {return _storage._withVectors != nil}
  public mutating func clearWithVectors() {_uniqueStorage()._withVectors = nil}

  /// Name of the collection to use for points lookup, if not specified - use current collection
  public var lookupFrom: Qdrant_LookupLocation {
    get {return _storage._lookupFrom ?? Qdrant_LookupLocation()}
    set {_uniqueStorage()._lookupFrom = newValue}
  }
  public var hasLookupFrom: Bool {return _storage._lookupFrom != nil}
  public mutating func clearLookupFrom() {_uniqueStorage()._lookupFrom = nil}

  /// Payload field to group by, must be a string or number field.
  /// If there are multiple values for the field, all of them will be used.
  /// One point can be in multiple groups.
  public var groupBy: String {
    get {return _storage._groupBy}
    set {_uniqueStorage()._groupBy = newValue}
  }

  /// Maximum amount of points to return per group
  public var groupSize: UInt32 {
    get {return _storage._groupSize}
    set {_uniqueStorage()._groupSize = newValue}
  }

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _storage._readConsistency ?? Qdrant_ReadConsistency()}
    set {_uniqueStorage()._readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return _storage._readConsistency != nil}
  public mutating func clearReadConsistency() {_uniqueStorage()._readConsistency = nil}

  /// Options for specifying how to use the group id to lookup points in another collection
  public var withLookup: Qdrant_WithLookup {
    get {return _storage._withLookup ?? Qdrant_WithLookup()}
    set {_uniqueStorage()._withLookup = newValue}
  }
  public var hasWithLookup: Bool {return _storage._withLookup != nil}
  public mutating func clearWithLookup() {_uniqueStorage()._withLookup = nil}

  /// How to use the example vectors to find the results
  public var strategy: Qdrant_RecommendStrategy {
    get {return _storage._strategy ?? .averageVector}
    set {_uniqueStorage()._strategy = newValue}
  }
  public var hasStrategy: Bool {return _storage._strategy != nil}
  public mutating func clearStrategy() {_uniqueStorage()._strategy = nil}

  /// Look for vectors closest to those
  public var positiveVectors: [Qdrant_Vector] {
    get {return _storage._positiveVectors}
    set {_uniqueStorage()._positiveVectors = newValue}
  }

  /// Try to avoid vectors like this
  public var negativeVectors: [Qdrant_Vector] {
    get {return _storage._negativeVectors}
    set {_uniqueStorage()._negativeVectors = newValue}
  }

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _storage._shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_uniqueStorage()._shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return _storage._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {_uniqueStorage()._shardKeySelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_TargetVector: Sendable {
  public var target: Qdrant_TargetVector.OneOf_Target? = nil

  public var single: Qdrant_VectorExample {
    get {
      if case .single(let v)? = target {return v}
      return Qdrant_VectorExample()
    }
    set {target = .single(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable, Sendable {
    case single(Qdrant_VectorExample)

  }

  public init() {}
}

public struct Qdrant_VectorExample: Sendable {
  public var example: Qdrant_VectorExample.OneOf_Example? = nil

  public var id: Qdrant_PointId {
    get {
      if case .id(let v)? = example {return v}
      return Qdrant_PointId()
    }
    set {example = .id(newValue)}
  }

  public var vector: Qdrant_Vector {
    get {
      if case .vector(let v)? = example {return v}
      return Qdrant_Vector()
    }
    set {example = .vector(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Example: Equatable, Sendable {
    case id(Qdrant_PointId)
    case vector(Qdrant_Vector)

  }

  public init() {}
}

public struct Qdrant_ContextExamplePair: Sendable {
  public var positive: Qdrant_VectorExample {
    get {return _positive ?? Qdrant_VectorExample()}
    set {_positive = newValue}
  }
  public var hasPositive: Bool {return self._positive != nil}
  public mutating func clearPositive() {self._positive = nil}

  public var negative: Qdrant_VectorExample {
    get {return _negative ?? Qdrant_VectorExample()}
    set {_negative = newValue}
  }
  public var hasNegative: Bool {return self._negative != nil}
  public mutating func clearNegative() {self._negative = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _positive: Qdrant_VectorExample? = nil
  fileprivate var _negative: Qdrant_VectorExample? = nil
}

public struct Qdrant_DiscoverPoints: @unchecked Sendable {
  /// name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// Use this as the primary search objective
  public var target: Qdrant_TargetVector {
    get {return _storage._target ?? Qdrant_TargetVector()}
    set {_uniqueStorage()._target = newValue}
  }
  public var hasTarget: Bool {return _storage._target != nil}
  public mutating func clearTarget() {_uniqueStorage()._target = nil}

  /// Search will be constrained by these pairs of examples
  public var context: [Qdrant_ContextExamplePair] {
    get {return _storage._context}
    set {_uniqueStorage()._context = newValue}
  }

  /// Filter conditions - return only those points that satisfy the specified conditions
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Max number of result
  public var limit: UInt64 {
    get {return _storage._limit}
    set {_uniqueStorage()._limit = newValue}
  }

  /// Options for specifying which payload to include or not
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _storage._withPayload ?? Qdrant_WithPayloadSelector()}
    set {_uniqueStorage()._withPayload = newValue}
  }
  public var hasWithPayload: Bool {return _storage._withPayload != nil}
  public mutating func clearWithPayload() {_uniqueStorage()._withPayload = nil}

  /// Search config
  public var params: Qdrant_SearchParams {
    get {return _storage._params ?? Qdrant_SearchParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// Offset of the result
  public var offset: UInt64 {
    get {return _storage._offset ?? 0}
    set {_uniqueStorage()._offset = newValue}
  }
  public var hasOffset: Bool {return _storage._offset != nil}
  public mutating func clearOffset() {_uniqueStorage()._offset = nil}

  /// Define which vector to use for recommendation, if not specified - default vector
  public var using: String {
    get {return _storage._using ?? String()}
    set {_uniqueStorage()._using = newValue}
  }
  public var hasUsing: Bool {return _storage._using != nil}
  public mutating func clearUsing() {_uniqueStorage()._using = nil}

  /// Options for specifying which vectors to include into response
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _storage._withVectors ?? Qdrant_WithVectorsSelector()}
    set {_uniqueStorage()._withVectors = newValue}
  }
  public var hasWithVectors: Bool {return _storage._withVectors != nil}
  public mutating func clearWithVectors() {_uniqueStorage()._withVectors = nil}

  /// Name of the collection to use for points lookup, if not specified - use current collection
  public var lookupFrom: Qdrant_LookupLocation {
    get {return _storage._lookupFrom ?? Qdrant_LookupLocation()}
    set {_uniqueStorage()._lookupFrom = newValue}
  }
  public var hasLookupFrom: Bool {return _storage._lookupFrom != nil}
  public mutating func clearLookupFrom() {_uniqueStorage()._lookupFrom = nil}

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _storage._readConsistency ?? Qdrant_ReadConsistency()}
    set {_uniqueStorage()._readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return _storage._readConsistency != nil}
  public mutating func clearReadConsistency() {_uniqueStorage()._readConsistency = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _storage._shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_uniqueStorage()._shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return _storage._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {_uniqueStorage()._shardKeySelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_DiscoverBatchPoints: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  public var discoverPoints: [Qdrant_DiscoverPoints] = []

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _readConsistency ?? Qdrant_ReadConsistency()}
    set {_readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return self._readConsistency != nil}
  public mutating func clearReadConsistency() {self._readConsistency = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readConsistency: Qdrant_ReadConsistency? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_CountPoints: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  /// Filter conditions - return only those points that satisfy the specified conditions
  public var filter: Qdrant_Filter {
    get {return _filter ?? Qdrant_Filter()}
    set {_filter = newValue}
  }
  public var hasFilter: Bool {return self._filter != nil}
  public mutating func clearFilter() {self._filter = nil}

  /// If `true` - return exact count, if `false` - return approximate count
  public var exact: Bool {
    get {return _exact ?? false}
    set {_exact = newValue}
  }
  public var hasExact: Bool {return self._exact != nil}
  public mutating func clearExact() {self._exact = nil}

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _readConsistency ?? Qdrant_ReadConsistency()}
    set {_readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return self._readConsistency != nil}
  public mutating func clearReadConsistency() {self._readConsistency = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filter: Qdrant_Filter? = nil
  fileprivate var _exact: Bool? = nil
  fileprivate var _readConsistency: Qdrant_ReadConsistency? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_RecommendInput: Sendable {
  /// Look for vectors closest to the vectors from these points
  public var positive: [Qdrant_VectorInput] = []

  /// Try to avoid vectors like the vector from these points
  public var negative: [Qdrant_VectorInput] = []

  /// How to use the provided vectors to find the results
  public var strategy: Qdrant_RecommendStrategy {
    get {return _strategy ?? .averageVector}
    set {_strategy = newValue}
  }
  public var hasStrategy: Bool {return self._strategy != nil}
  public mutating func clearStrategy() {self._strategy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _strategy: Qdrant_RecommendStrategy? = nil
}

public struct Qdrant_ContextInputPair: Sendable {
  /// A positive vector
  public var positive: Qdrant_VectorInput {
    get {return _positive ?? Qdrant_VectorInput()}
    set {_positive = newValue}
  }
  public var hasPositive: Bool {return self._positive != nil}
  public mutating func clearPositive() {self._positive = nil}

  /// Repel from this vector
  public var negative: Qdrant_VectorInput {
    get {return _negative ?? Qdrant_VectorInput()}
    set {_negative = newValue}
  }
  public var hasNegative: Bool {return self._negative != nil}
  public mutating func clearNegative() {self._negative = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _positive: Qdrant_VectorInput? = nil
  fileprivate var _negative: Qdrant_VectorInput? = nil
}

public struct Qdrant_DiscoverInput: Sendable {
  /// Use this as the primary search objective
  public var target: Qdrant_VectorInput {
    get {return _target ?? Qdrant_VectorInput()}
    set {_target = newValue}
  }
  public var hasTarget: Bool {return self._target != nil}
  public mutating func clearTarget() {self._target = nil}

  /// Search space will be constrained by these pairs of vectors
  public var context: Qdrant_ContextInput {
    get {return _context ?? Qdrant_ContextInput()}
    set {_context = newValue}
  }
  public var hasContext: Bool {return self._context != nil}
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _target: Qdrant_VectorInput? = nil
  fileprivate var _context: Qdrant_ContextInput? = nil
}

public struct Qdrant_ContextInput: Sendable {
  /// Search space will be constrained by these pairs of vectors
  public var pairs: [Qdrant_ContextInputPair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_Formula: Sendable {
  public var expression: Qdrant_Expression {
    get {return _expression ?? Qdrant_Expression()}
    set {_expression = newValue}
  }
  public var hasExpression: Bool {return self._expression != nil}
  public mutating func clearExpression() {self._expression = nil}

  public var defaults: Dictionary<String,Qdrant_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expression: Qdrant_Expression? = nil
}

public struct Qdrant_Expression: @unchecked Sendable {
  public var variant: OneOf_Variant? {
    get {return _storage._variant}
    set {_uniqueStorage()._variant = newValue}
  }

  public var constant: Float {
    get {
      if case .constant(let v)? = _storage._variant {return v}
      return 0
    }
    set {_uniqueStorage()._variant = .constant(newValue)}
  }

  /// Payload key or reference to score.
  public var variable: String {
    get {
      if case .variable(let v)? = _storage._variant {return v}
      return String()
    }
    set {_uniqueStorage()._variant = .variable(newValue)}
  }

  /// Payload condition. If true, becomes 1.0; otherwise 0.0
  public var condition: Qdrant_Condition {
    get {
      if case .condition(let v)? = _storage._variant {return v}
      return Qdrant_Condition()
    }
    set {_uniqueStorage()._variant = .condition(newValue)}
  }

  /// Geographic distance in meters
  public var geoDistance: Qdrant_GeoDistance {
    get {
      if case .geoDistance(let v)? = _storage._variant {return v}
      return Qdrant_GeoDistance()
    }
    set {_uniqueStorage()._variant = .geoDistance(newValue)}
  }

  /// Date-time constant
  public var datetime: String {
    get {
      if case .datetime(let v)? = _storage._variant {return v}
      return String()
    }
    set {_uniqueStorage()._variant = .datetime(newValue)}
  }

  /// Payload key with date-time values
  public var datetimeKey: String {
    get {
      if case .datetimeKey(let v)? = _storage._variant {return v}
      return String()
    }
    set {_uniqueStorage()._variant = .datetimeKey(newValue)}
  }

  /// Multiply
  public var mult: Qdrant_MultExpression {
    get {
      if case .mult(let v)? = _storage._variant {return v}
      return Qdrant_MultExpression()
    }
    set {_uniqueStorage()._variant = .mult(newValue)}
  }

  /// Sum
  public var sum: Qdrant_SumExpression {
    get {
      if case .sum(let v)? = _storage._variant {return v}
      return Qdrant_SumExpression()
    }
    set {_uniqueStorage()._variant = .sum(newValue)}
  }

  /// Divide
  public var div: Qdrant_DivExpression {
    get {
      if case .div(let v)? = _storage._variant {return v}
      return Qdrant_DivExpression()
    }
    set {_uniqueStorage()._variant = .div(newValue)}
  }

  /// Negate
  public var neg: Qdrant_Expression {
    get {
      if case .neg(let v)? = _storage._variant {return v}
      return Qdrant_Expression()
    }
    set {_uniqueStorage()._variant = .neg(newValue)}
  }

  /// Absolute value
  public var abs: Qdrant_Expression {
    get {
      if case .abs(let v)? = _storage._variant {return v}
      return Qdrant_Expression()
    }
    set {_uniqueStorage()._variant = .abs(newValue)}
  }

  /// Square root
  public var sqrt: Qdrant_Expression {
    get {
      if case .sqrt(let v)? = _storage._variant {return v}
      return Qdrant_Expression()
    }
    set {_uniqueStorage()._variant = .sqrt(newValue)}
  }

  /// Power
  public var pow: Qdrant_PowExpression {
    get {
      if case .pow(let v)? = _storage._variant {return v}
      return Qdrant_PowExpression()
    }
    set {_uniqueStorage()._variant = .pow(newValue)}
  }

  /// Exponential
  public var exp: Qdrant_Expression {
    get {
      if case .exp(let v)? = _storage._variant {return v}
      return Qdrant_Expression()
    }
    set {_uniqueStorage()._variant = .exp(newValue)}
  }

  /// Logarithm
  public var log10: Qdrant_Expression {
    get {
      if case .log10(let v)? = _storage._variant {return v}
      return Qdrant_Expression()
    }
    set {_uniqueStorage()._variant = .log10(newValue)}
  }

  /// Natural logarithm
  public var ln: Qdrant_Expression {
    get {
      if case .ln(let v)? = _storage._variant {return v}
      return Qdrant_Expression()
    }
    set {_uniqueStorage()._variant = .ln(newValue)}
  }

  /// Exponential decay
  public var expDecay: Qdrant_DecayParamsExpression {
    get {
      if case .expDecay(let v)? = _storage._variant {return v}
      return Qdrant_DecayParamsExpression()
    }
    set {_uniqueStorage()._variant = .expDecay(newValue)}
  }

  /// Gaussian decay
  public var gaussDecay: Qdrant_DecayParamsExpression {
    get {
      if case .gaussDecay(let v)? = _storage._variant {return v}
      return Qdrant_DecayParamsExpression()
    }
    set {_uniqueStorage()._variant = .gaussDecay(newValue)}
  }

  /// Linear decay
  public var linDecay: Qdrant_DecayParamsExpression {
    get {
      if case .linDecay(let v)? = _storage._variant {return v}
      return Qdrant_DecayParamsExpression()
    }
    set {_uniqueStorage()._variant = .linDecay(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable, Sendable {
    case constant(Float)
    /// Payload key or reference to score.
    case variable(String)
    /// Payload condition. If true, becomes 1.0; otherwise 0.0
    case condition(Qdrant_Condition)
    /// Geographic distance in meters
    case geoDistance(Qdrant_GeoDistance)
    /// Date-time constant
    case datetime(String)
    /// Payload key with date-time values
    case datetimeKey(String)
    /// Multiply
    case mult(Qdrant_MultExpression)
    /// Sum
    case sum(Qdrant_SumExpression)
    /// Divide
    case div(Qdrant_DivExpression)
    /// Negate
    case neg(Qdrant_Expression)
    /// Absolute value
    case abs(Qdrant_Expression)
    /// Square root
    case sqrt(Qdrant_Expression)
    /// Power
    case pow(Qdrant_PowExpression)
    /// Exponential
    case exp(Qdrant_Expression)
    /// Logarithm
    case log10(Qdrant_Expression)
    /// Natural logarithm
    case ln(Qdrant_Expression)
    /// Exponential decay
    case expDecay(Qdrant_DecayParamsExpression)
    /// Gaussian decay
    case gaussDecay(Qdrant_DecayParamsExpression)
    /// Linear decay
    case linDecay(Qdrant_DecayParamsExpression)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_GeoDistance: Sendable {
  public var origin: Qdrant_GeoPoint {
    get {return _origin ?? Qdrant_GeoPoint()}
    set {_origin = newValue}
  }
  public var hasOrigin: Bool {return self._origin != nil}
  public mutating func clearOrigin() {self._origin = nil}

  public var to: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _origin: Qdrant_GeoPoint? = nil
}

public struct Qdrant_MultExpression: Sendable {
  public var mult: [Qdrant_Expression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_SumExpression: Sendable {
  public var sum: [Qdrant_Expression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_DivExpression: @unchecked Sendable {
  public var left: Qdrant_Expression {
    get {return _storage._left ?? Qdrant_Expression()}
    set {_uniqueStorage()._left = newValue}
  }
  public var hasLeft: Bool {return _storage._left != nil}
  public mutating func clearLeft() {_uniqueStorage()._left = nil}

  public var right: Qdrant_Expression {
    get {return _storage._right ?? Qdrant_Expression()}
    set {_uniqueStorage()._right = newValue}
  }
  public var hasRight: Bool {return _storage._right != nil}
  public mutating func clearRight() {_uniqueStorage()._right = nil}

  public var byZeroDefault: Float {
    get {return _storage._byZeroDefault ?? 0}
    set {_uniqueStorage()._byZeroDefault = newValue}
  }
  public var hasByZeroDefault: Bool {return _storage._byZeroDefault != nil}
  public mutating func clearByZeroDefault() {_uniqueStorage()._byZeroDefault = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_PowExpression: @unchecked Sendable {
  public var base: Qdrant_Expression {
    get {return _storage._base ?? Qdrant_Expression()}
    set {_uniqueStorage()._base = newValue}
  }
  public var hasBase: Bool {return _storage._base != nil}
  public mutating func clearBase() {_uniqueStorage()._base = nil}

  public var exponent: Qdrant_Expression {
    get {return _storage._exponent ?? Qdrant_Expression()}
    set {_uniqueStorage()._exponent = newValue}
  }
  public var hasExponent: Bool {return _storage._exponent != nil}
  public mutating func clearExponent() {_uniqueStorage()._exponent = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_DecayParamsExpression: @unchecked Sendable {
  /// The variable to decay
  public var x: Qdrant_Expression {
    get {return _storage._x ?? Qdrant_Expression()}
    set {_uniqueStorage()._x = newValue}
  }
  public var hasX: Bool {return _storage._x != nil}
  public mutating func clearX() {_uniqueStorage()._x = nil}

  /// The target value to start decaying from. Defaults to 0.
  public var target: Qdrant_Expression {
    get {return _storage._target ?? Qdrant_Expression()}
    set {_uniqueStorage()._target = newValue}
  }
  public var hasTarget: Bool {return _storage._target != nil}
  public mutating func clearTarget() {_uniqueStorage()._target = nil}

  /// The scale factor of the decay, in terms of `x`.
  /// Defaults to 1.0. Must be a non-zero positive number.
  public var scale: Float {
    get {return _storage._scale ?? 0}
    set {_uniqueStorage()._scale = newValue}
  }
  public var hasScale: Bool {return _storage._scale != nil}
  public mutating func clearScale() {_uniqueStorage()._scale = nil}

  /// The midpoint of the decay.
  /// Should be between 0 and 1. Defaults to 0.5.
  /// Output will be this value when `|x - target| == scale`.
  public var midpoint: Float {
    get {return _storage._midpoint ?? 0}
    set {_uniqueStorage()._midpoint = newValue}
  }
  public var hasMidpoint: Bool {return _storage._midpoint != nil}
  public mutating func clearMidpoint() {_uniqueStorage()._midpoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_NearestInputWithMmr: Sendable {
  /// The vector to search for nearest neighbors.
  public var nearest: Qdrant_VectorInput {
    get {return _nearest ?? Qdrant_VectorInput()}
    set {_nearest = newValue}
  }
  public var hasNearest: Bool {return self._nearest != nil}
  public mutating func clearNearest() {self._nearest = nil}

  /// Perform MMR (Maximal Marginal Relevance) reranking after search,
  /// using the same vector in this query to calculate relevance.
  public var mmr: Qdrant_Mmr {
    get {return _mmr ?? Qdrant_Mmr()}
    set {_mmr = newValue}
  }
  public var hasMmr: Bool {return self._mmr != nil}
  public mutating func clearMmr() {self._mmr = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nearest: Qdrant_VectorInput? = nil
  fileprivate var _mmr: Qdrant_Mmr? = nil
}

/// Maximal Marginal Relevance (MMR) algorithm for re-ranking the points.
public struct Qdrant_Mmr: Sendable {
  /// Tunable parameter for the MMR algorithm.
  /// Determines the balance between diversity and relevance.
  ///
  /// A higher value favors diversity (dissimilarity to selected results),
  /// while a lower value favors relevance (similarity to the query vector).
  ///
  /// Must be in the range [0, 1].
  /// Default value is 0.5.
  public var diversity: Float {
    get {return _diversity ?? 0}
    set {_diversity = newValue}
  }
  public var hasDiversity: Bool {return self._diversity != nil}
  public mutating func clearDiversity() {self._diversity = nil}

  /// The maximum number of candidates to consider for re-ranking.
  ///
  /// If not specified, the `limit` value is used.
  public var candidatesLimit: UInt32 {
    get {return _candidatesLimit ?? 0}
    set {_candidatesLimit = newValue}
  }
  public var hasCandidatesLimit: Bool {return self._candidatesLimit != nil}
  public mutating func clearCandidatesLimit() {self._candidatesLimit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _diversity: Float? = nil
  fileprivate var _candidatesLimit: UInt32? = nil
}

/// Parameterized reciprocal rank fusion
public struct Qdrant_Rrf: Sendable {
  /// K parameter for reciprocal rank fusion
  public var k: UInt32 {
    get {return _k ?? 0}
    set {_k = newValue}
  }
  public var hasK: Bool {return self._k != nil}
  public mutating func clearK() {self._k = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _k: UInt32? = nil
}

public struct Qdrant_Query: Sendable {
  public var variant: Qdrant_Query.OneOf_Variant? = nil

  /// Find the nearest neighbors to this vector.
  public var nearest: Qdrant_VectorInput {
    get {
      if case .nearest(let v)? = variant {return v}
      return Qdrant_VectorInput()
    }
    set {variant = .nearest(newValue)}
  }

  /// Use multiple positive and negative vectors to find the results.
  public var recommend: Qdrant_RecommendInput {
    get {
      if case .recommend(let v)? = variant {return v}
      return Qdrant_RecommendInput()
    }
    set {variant = .recommend(newValue)}
  }

  /// Search for nearest points, but constrain the search space with context
  public var discover: Qdrant_DiscoverInput {
    get {
      if case .discover(let v)? = variant {return v}
      return Qdrant_DiscoverInput()
    }
    set {variant = .discover(newValue)}
  }

  /// Return points that live in positive areas.
  public var context: Qdrant_ContextInput {
    get {
      if case .context(let v)? = variant {return v}
      return Qdrant_ContextInput()
    }
    set {variant = .context(newValue)}
  }

  /// Order the points by a payload field.
  public var orderBy: Qdrant_OrderBy {
    get {
      if case .orderBy(let v)? = variant {return v}
      return Qdrant_OrderBy()
    }
    set {variant = .orderBy(newValue)}
  }

  /// Fuse the results of multiple prefetches.
  public var fusion: Qdrant_Fusion {
    get {
      if case .fusion(let v)? = variant {return v}
      return .rrf
    }
    set {variant = .fusion(newValue)}
  }

  /// Sample points from the collection.
  public var sample: Qdrant_Sample {
    get {
      if case .sample(let v)? = variant {return v}
      return .random
    }
    set {variant = .sample(newValue)}
  }

  /// Score boosting via an arbitrary formula
  public var formula: Qdrant_Formula {
    get {
      if case .formula(let v)? = variant {return v}
      return Qdrant_Formula()
    }
    set {variant = .formula(newValue)}
  }

  /// Search nearest neighbors, but re-rank based on the Maximal Marginal Relevance algorithm.
  public var nearestWithMmr: Qdrant_NearestInputWithMmr {
    get {
      if case .nearestWithMmr(let v)? = variant {return v}
      return Qdrant_NearestInputWithMmr()
    }
    set {variant = .nearestWithMmr(newValue)}
  }

  /// Parameterized reciprocal rank fusion
  public var rrf: Qdrant_Rrf {
    get {
      if case .rrf(let v)? = variant {return v}
      return Qdrant_Rrf()
    }
    set {variant = .rrf(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable, Sendable {
    /// Find the nearest neighbors to this vector.
    case nearest(Qdrant_VectorInput)
    /// Use multiple positive and negative vectors to find the results.
    case recommend(Qdrant_RecommendInput)
    /// Search for nearest points, but constrain the search space with context
    case discover(Qdrant_DiscoverInput)
    /// Return points that live in positive areas.
    case context(Qdrant_ContextInput)
    /// Order the points by a payload field.
    case orderBy(Qdrant_OrderBy)
    /// Fuse the results of multiple prefetches.
    case fusion(Qdrant_Fusion)
    /// Sample points from the collection.
    case sample(Qdrant_Sample)
    /// Score boosting via an arbitrary formula
    case formula(Qdrant_Formula)
    /// Search nearest neighbors, but re-rank based on the Maximal Marginal Relevance algorithm.
    case nearestWithMmr(Qdrant_NearestInputWithMmr)
    /// Parameterized reciprocal rank fusion
    case rrf(Qdrant_Rrf)

  }

  public init() {}
}

public struct Qdrant_PrefetchQuery: @unchecked Sendable {
  /// Sub-requests to perform first.
  /// If present, the query will be performed on the results of the prefetches.
  public var prefetch: [Qdrant_PrefetchQuery] {
    get {return _storage._prefetch}
    set {_uniqueStorage()._prefetch = newValue}
  }

  /// Query to perform.
  /// If missing, returns points ordered by their IDs.
  public var query: Qdrant_Query {
    get {return _storage._query ?? Qdrant_Query()}
    set {_uniqueStorage()._query = newValue}
  }
  public var hasQuery: Bool {return _storage._query != nil}
  public mutating func clearQuery() {_uniqueStorage()._query = nil}

  /// Define which vector to use for querying.
  /// If missing, the default vector is used.
  public var using: String {
    get {return _storage._using ?? String()}
    set {_uniqueStorage()._using = newValue}
  }
  public var hasUsing: Bool {return _storage._using != nil}
  public mutating func clearUsing() {_uniqueStorage()._using = nil}

  /// Filter conditions - return only those points that satisfy the specified conditions.
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Search params for when there is no prefetch.
  public var params: Qdrant_SearchParams {
    get {return _storage._params ?? Qdrant_SearchParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// Return points with scores better than this threshold.
  public var scoreThreshold: Float {
    get {return _storage._scoreThreshold ?? 0}
    set {_uniqueStorage()._scoreThreshold = newValue}
  }
  public var hasScoreThreshold: Bool {return _storage._scoreThreshold != nil}
  public mutating func clearScoreThreshold() {_uniqueStorage()._scoreThreshold = nil}

  /// Max number of points. Default is 10
  public var limit: UInt64 {
    get {return _storage._limit ?? 0}
    set {_uniqueStorage()._limit = newValue}
  }
  public var hasLimit: Bool {return _storage._limit != nil}
  public mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// The location to use for IDs lookup.
  /// If not specified - use the current collection and the 'using' vector.
  public var lookupFrom: Qdrant_LookupLocation {
    get {return _storage._lookupFrom ?? Qdrant_LookupLocation()}
    set {_uniqueStorage()._lookupFrom = newValue}
  }
  public var hasLookupFrom: Bool {return _storage._lookupFrom != nil}
  public mutating func clearLookupFrom() {_uniqueStorage()._lookupFrom = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_QueryPoints: @unchecked Sendable {
  /// Name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// Sub-requests to perform first.
  /// If present, the query will be performed on the results of the prefetches.
  public var prefetch: [Qdrant_PrefetchQuery] {
    get {return _storage._prefetch}
    set {_uniqueStorage()._prefetch = newValue}
  }

  /// Query to perform. If missing, returns points ordered by their IDs.
  public var query: Qdrant_Query {
    get {return _storage._query ?? Qdrant_Query()}
    set {_uniqueStorage()._query = newValue}
  }
  public var hasQuery: Bool {return _storage._query != nil}
  public mutating func clearQuery() {_uniqueStorage()._query = nil}

  /// Define which vector to use for querying.
  /// If missing, the default vector is used.
  public var using: String {
    get {return _storage._using ?? String()}
    set {_uniqueStorage()._using = newValue}
  }
  public var hasUsing: Bool {return _storage._using != nil}
  public mutating func clearUsing() {_uniqueStorage()._using = nil}

  /// Filter conditions - return only those points that satisfy the specified conditions.
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Search params for when there is no prefetch.
  public var params: Qdrant_SearchParams {
    get {return _storage._params ?? Qdrant_SearchParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// Return points with scores better than this threshold.
  public var scoreThreshold: Float {
    get {return _storage._scoreThreshold ?? 0}
    set {_uniqueStorage()._scoreThreshold = newValue}
  }
  public var hasScoreThreshold: Bool {return _storage._scoreThreshold != nil}
  public mutating func clearScoreThreshold() {_uniqueStorage()._scoreThreshold = nil}

  /// Max number of points. Default is 10.
  public var limit: UInt64 {
    get {return _storage._limit ?? 0}
    set {_uniqueStorage()._limit = newValue}
  }
  public var hasLimit: Bool {return _storage._limit != nil}
  public mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// Offset of the result. Skip this many points. Default is 0.
  public var offset: UInt64 {
    get {return _storage._offset ?? 0}
    set {_uniqueStorage()._offset = newValue}
  }
  public var hasOffset: Bool {return _storage._offset != nil}
  public mutating func clearOffset() {_uniqueStorage()._offset = nil}

  /// Options for specifying which vectors to include into the response.
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _storage._withVectors ?? Qdrant_WithVectorsSelector()}
    set {_uniqueStorage()._withVectors = newValue}
  }
  public var hasWithVectors: Bool {return _storage._withVectors != nil}
  public mutating func clearWithVectors() {_uniqueStorage()._withVectors = nil}

  /// Options for specifying which payload to include or not.
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _storage._withPayload ?? Qdrant_WithPayloadSelector()}
    set {_uniqueStorage()._withPayload = newValue}
  }
  public var hasWithPayload: Bool {return _storage._withPayload != nil}
  public mutating func clearWithPayload() {_uniqueStorage()._withPayload = nil}

  /// Options for specifying read consistency guarantees.
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _storage._readConsistency ?? Qdrant_ReadConsistency()}
    set {_uniqueStorage()._readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return _storage._readConsistency != nil}
  public mutating func clearReadConsistency() {_uniqueStorage()._readConsistency = nil}

  /// Specify in which shards to look for the points.
  /// If not specified - look in all shards.
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _storage._shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_uniqueStorage()._shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return _storage._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {_uniqueStorage()._shardKeySelector = nil}

  /// The location to use for IDs lookup.
  /// If not specified - use the current collection and the 'using' vector.
  public var lookupFrom: Qdrant_LookupLocation {
    get {return _storage._lookupFrom ?? Qdrant_LookupLocation()}
    set {_uniqueStorage()._lookupFrom = newValue}
  }
  public var hasLookupFrom: Bool {return _storage._lookupFrom != nil}
  public mutating func clearLookupFrom() {_uniqueStorage()._lookupFrom = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_QueryBatchPoints: Sendable {
  public var collectionName: String = String()

  public var queryPoints: [Qdrant_QueryPoints] = []

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _readConsistency ?? Qdrant_ReadConsistency()}
    set {_readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return self._readConsistency != nil}
  public mutating func clearReadConsistency() {self._readConsistency = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readConsistency: Qdrant_ReadConsistency? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_QueryPointGroups: @unchecked Sendable {
  /// Name of the collection
  public var collectionName: String {
    get {return _storage._collectionName}
    set {_uniqueStorage()._collectionName = newValue}
  }

  /// Sub-requests to perform first.
  /// If present, the query will be performed on the results of the prefetches.
  public var prefetch: [Qdrant_PrefetchQuery] {
    get {return _storage._prefetch}
    set {_uniqueStorage()._prefetch = newValue}
  }

  /// Query to perform. If missing, returns points ordered by their IDs.
  public var query: Qdrant_Query {
    get {return _storage._query ?? Qdrant_Query()}
    set {_uniqueStorage()._query = newValue}
  }
  public var hasQuery: Bool {return _storage._query != nil}
  public mutating func clearQuery() {_uniqueStorage()._query = nil}

  /// Define which vector to use for querying.
  /// If missing, the default vector is used.
  public var using: String {
    get {return _storage._using ?? String()}
    set {_uniqueStorage()._using = newValue}
  }
  public var hasUsing: Bool {return _storage._using != nil}
  public mutating func clearUsing() {_uniqueStorage()._using = nil}

  /// Filter conditions - return only those points that satisfy the specified conditions.
  public var filter: Qdrant_Filter {
    get {return _storage._filter ?? Qdrant_Filter()}
    set {_uniqueStorage()._filter = newValue}
  }
  public var hasFilter: Bool {return _storage._filter != nil}
  public mutating func clearFilter() {_uniqueStorage()._filter = nil}

  /// Search params for when there is no prefetch.
  public var params: Qdrant_SearchParams {
    get {return _storage._params ?? Qdrant_SearchParams()}
    set {_uniqueStorage()._params = newValue}
  }
  public var hasParams: Bool {return _storage._params != nil}
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  /// Return points with scores better than this threshold.
  public var scoreThreshold: Float {
    get {return _storage._scoreThreshold ?? 0}
    set {_uniqueStorage()._scoreThreshold = newValue}
  }
  public var hasScoreThreshold: Bool {return _storage._scoreThreshold != nil}
  public mutating func clearScoreThreshold() {_uniqueStorage()._scoreThreshold = nil}

  /// Options for specifying which payload to include or not
  public var withPayload: Qdrant_WithPayloadSelector {
    get {return _storage._withPayload ?? Qdrant_WithPayloadSelector()}
    set {_uniqueStorage()._withPayload = newValue}
  }
  public var hasWithPayload: Bool {return _storage._withPayload != nil}
  public mutating func clearWithPayload() {_uniqueStorage()._withPayload = nil}

  /// Options for specifying which vectors to include into response
  public var withVectors: Qdrant_WithVectorsSelector {
    get {return _storage._withVectors ?? Qdrant_WithVectorsSelector()}
    set {_uniqueStorage()._withVectors = newValue}
  }
  public var hasWithVectors: Bool {return _storage._withVectors != nil}
  public mutating func clearWithVectors() {_uniqueStorage()._withVectors = nil}

  /// The location to use for IDs lookup.
  /// If not specified - use the current collection and the 'using' vector.
  public var lookupFrom: Qdrant_LookupLocation {
    get {return _storage._lookupFrom ?? Qdrant_LookupLocation()}
    set {_uniqueStorage()._lookupFrom = newValue}
  }
  public var hasLookupFrom: Bool {return _storage._lookupFrom != nil}
  public mutating func clearLookupFrom() {_uniqueStorage()._lookupFrom = nil}

  /// Max number of points. Default is 3.
  public var limit: UInt64 {
    get {return _storage._limit ?? 0}
    set {_uniqueStorage()._limit = newValue}
  }
  public var hasLimit: Bool {return _storage._limit != nil}
  public mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// Maximum amount of points to return per group. Defaults to 10.
  public var groupSize: UInt64 {
    get {return _storage._groupSize ?? 0}
    set {_uniqueStorage()._groupSize = newValue}
  }
  public var hasGroupSize: Bool {return _storage._groupSize != nil}
  public mutating func clearGroupSize() {_uniqueStorage()._groupSize = nil}

  /// Payload field to group by, must be a string or number field.
  /// If there are multiple values for the field, all of them will be used.
  /// One point can be in multiple groups.
  public var groupBy: String {
    get {return _storage._groupBy}
    set {_uniqueStorage()._groupBy = newValue}
  }

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _storage._readConsistency ?? Qdrant_ReadConsistency()}
    set {_uniqueStorage()._readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return _storage._readConsistency != nil}
  public mutating func clearReadConsistency() {_uniqueStorage()._readConsistency = nil}

  /// Options for specifying how to use the group id to lookup points in another collection
  public var withLookup: Qdrant_WithLookup {
    get {return _storage._withLookup ?? Qdrant_WithLookup()}
    set {_uniqueStorage()._withLookup = newValue}
  }
  public var hasWithLookup: Bool {return _storage._withLookup != nil}
  public mutating func clearWithLookup() {_uniqueStorage()._withLookup = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _storage._timeout ?? 0}
    set {_uniqueStorage()._timeout = newValue}
  }
  public var hasTimeout: Bool {return _storage._timeout != nil}
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _storage._shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_uniqueStorage()._shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return _storage._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {_uniqueStorage()._shardKeySelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_FacetCounts: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  /// Payload key of the facet
  public var key: String = String()

  /// Filter conditions - return only those points that satisfy the specified conditions.
  public var filter: Qdrant_Filter {
    get {return _filter ?? Qdrant_Filter()}
    set {_filter = newValue}
  }
  public var hasFilter: Bool {return self._filter != nil}
  public mutating func clearFilter() {self._filter = nil}

  /// Max number of facets. Default is 10.
  public var limit: UInt64 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  public var hasLimit: Bool {return self._limit != nil}
  public mutating func clearLimit() {self._limit = nil}

  /// If true, return exact counts, slower but useful for debugging purposes. Default is false.
  public var exact: Bool {
    get {return _exact ?? false}
    set {_exact = newValue}
  }
  public var hasExact: Bool {return self._exact != nil}
  public mutating func clearExact() {self._exact = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _readConsistency ?? Qdrant_ReadConsistency()}
    set {_readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return self._readConsistency != nil}
  public mutating func clearReadConsistency() {self._readConsistency = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filter: Qdrant_Filter? = nil
  fileprivate var _limit: UInt64? = nil
  fileprivate var _exact: Bool? = nil
  fileprivate var _timeout: UInt64? = nil
  fileprivate var _readConsistency: Qdrant_ReadConsistency? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
}

public struct Qdrant_FacetValue: Sendable {
  public var variant: Qdrant_FacetValue.OneOf_Variant? = nil

  /// String value from the facet
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = variant {return v}
      return String()
    }
    set {variant = .stringValue(newValue)}
  }

  /// Integer value from the facet
  public var integerValue: Int64 {
    get {
      if case .integerValue(let v)? = variant {return v}
      return 0
    }
    set {variant = .integerValue(newValue)}
  }

  /// Boolean value from the facet
  public var boolValue: Bool {
    get {
      if case .boolValue(let v)? = variant {return v}
      return false
    }
    set {variant = .boolValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable, Sendable {
    /// String value from the facet
    case stringValue(String)
    /// Integer value from the facet
    case integerValue(Int64)
    /// Boolean value from the facet
    case boolValue(Bool)

  }

  public init() {}
}

public struct Qdrant_FacetHit: Sendable {
  /// Value from the facet
  public var value: Qdrant_FacetValue {
    get {return _value ?? Qdrant_FacetValue()}
    set {_value = newValue}
  }
  public var hasValue: Bool {return self._value != nil}
  public mutating func clearValue() {self._value = nil}

  /// Number of points with this value
  public var count: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Qdrant_FacetValue? = nil
}

public struct Qdrant_SearchMatrixPoints: Sendable {
  /// Name of the collection
  public var collectionName: String = String()

  /// Filter conditions - return only those points that satisfy the specified conditions.
  public var filter: Qdrant_Filter {
    get {return _filter ?? Qdrant_Filter()}
    set {_filter = newValue}
  }
  public var hasFilter: Bool {return self._filter != nil}
  public mutating func clearFilter() {self._filter = nil}

  /// How many points to select and search within. Default is 10.
  public var sample: UInt64 {
    get {return _sample ?? 0}
    set {_sample = newValue}
  }
  public var hasSample: Bool {return self._sample != nil}
  public mutating func clearSample() {self._sample = nil}

  /// How many neighbours per sample to find. Default is 3.
  public var limit: UInt64 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  public var hasLimit: Bool {return self._limit != nil}
  public mutating func clearLimit() {self._limit = nil}

  /// Define which vector to use for querying. If missing, the default vector is used.
  public var using: String {
    get {return _using ?? String()}
    set {_using = newValue}
  }
  public var hasUsing: Bool {return self._using != nil}
  public mutating func clearUsing() {self._using = nil}

  /// If set, overrides global timeout setting for this request. Unit is seconds.
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  /// Options for specifying read consistency guarantees
  public var readConsistency: Qdrant_ReadConsistency {
    get {return _readConsistency ?? Qdrant_ReadConsistency()}
    set {_readConsistency = newValue}
  }
  public var hasReadConsistency: Bool {return self._readConsistency != nil}
  public mutating func clearReadConsistency() {self._readConsistency = nil}

  /// Specify in which shards to look for the points, if not specified - look in all shards
  public var shardKeySelector: Qdrant_ShardKeySelector {
    get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
    set {_shardKeySelector = newValue}
  }
  public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
  public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filter: Qdrant_Filter? = nil
  fileprivate var _sample: UInt64? = nil
  fileprivate var _limit: UInt64? = nil
  fileprivate var _using: String? = nil
  fileprivate var _timeout: UInt64? = nil
  fileprivate var _readConsistency: Qdrant_ReadConsistency? = nil
  fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
}

public struct Qdrant_SearchMatrixPairs: Sendable {
  /// List of pairs of points with scores
  public var pairs: [Qdrant_SearchMatrixPair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_SearchMatrixPair: Sendable {
  /// first id of the pair
  public var a: Qdrant_PointId {
    get {return _a ?? Qdrant_PointId()}
    set {_a = newValue}
  }
  public var hasA: Bool {return self._a != nil}
  public mutating func clearA() {self._a = nil}

  /// second id of the pair
  public var b: Qdrant_PointId {
    get {return _b ?? Qdrant_PointId()}
    set {_b = newValue}
  }
  public var hasB: Bool {return self._b != nil}
  public mutating func clearB() {self._b = nil}

  /// score of the pair
  public var score: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _a: Qdrant_PointId? = nil
  fileprivate var _b: Qdrant_PointId? = nil
}

public struct Qdrant_SearchMatrixOffsets: Sendable {
  /// Row indices of the matrix
  public var offsetsRow: [UInt64] = []

  /// Column indices of the matrix
  public var offsetsCol: [UInt64] = []

  /// Scores associated with matrix coordinates
  public var scores: [Float] = []

  /// Ids of the points in order
  public var ids: [Qdrant_PointId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_PointsUpdateOperation: Sendable {
  public var operation: Qdrant_PointsUpdateOperation.OneOf_Operation? = nil

  public var upsert: Qdrant_PointsUpdateOperation.PointStructList {
    get {
      if case .upsert(let v)? = operation {return v}
      return Qdrant_PointsUpdateOperation.PointStructList()
    }
    set {operation = .upsert(newValue)}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  public var deleteDeprecated: Qdrant_PointsSelector {
    get {
      if case .deleteDeprecated(let v)? = operation {return v}
      return Qdrant_PointsSelector()
    }
    set {operation = .deleteDeprecated(newValue)}
  }

  public var setPayload: Qdrant_PointsUpdateOperation.SetPayload {
    get {
      if case .setPayload(let v)? = operation {return v}
      return Qdrant_PointsUpdateOperation.SetPayload()
    }
    set {operation = .setPayload(newValue)}
  }

  public var overwritePayload: Qdrant_PointsUpdateOperation.OverwritePayload {
    get {
      if case .overwritePayload(let v)? = operation {return v}
      return Qdrant_PointsUpdateOperation.OverwritePayload()
    }
    set {operation = .overwritePayload(newValue)}
  }

  public var deletePayload: Qdrant_PointsUpdateOperation.DeletePayload {
    get {
      if case .deletePayload(let v)? = operation {return v}
      return Qdrant_PointsUpdateOperation.DeletePayload()
    }
    set {operation = .deletePayload(newValue)}
  }

  /// NOTE: This field was marked as deprecated in the .proto file.
  public var clearPayloadDeprecated_p: Qdrant_PointsSelector {
    get {
      if case .clearPayloadDeprecated_p(let v)? = operation {return v}
      return Qdrant_PointsSelector()
    }
    set {operation = .clearPayloadDeprecated_p(newValue)}
  }

  public var updateVectors: Qdrant_PointsUpdateOperation.UpdateVectors {
    get {
      if case .updateVectors(let v)? = operation {return v}
      return Qdrant_PointsUpdateOperation.UpdateVectors()
    }
    set {operation = .updateVectors(newValue)}
  }

  public var deleteVectors: Qdrant_PointsUpdateOperation.DeleteVectors {
    get {
      if case .deleteVectors(let v)? = operation {return v}
      return Qdrant_PointsUpdateOperation.DeleteVectors()
    }
    set {operation = .deleteVectors(newValue)}
  }

  public var deletePoints: Qdrant_PointsUpdateOperation.DeletePoints {
    get {
      if case .deletePoints(let v)? = operation {return v}
      return Qdrant_PointsUpdateOperation.DeletePoints()
    }
    set {operation = .deletePoints(newValue)}
  }

  public var clearPayload_p: Qdrant_PointsUpdateOperation.ClearPayload {
    get {
      if case .clearPayload_p(let v)? = operation {return v}
      return Qdrant_PointsUpdateOperation.ClearPayload()
    }
    set {operation = .clearPayload_p(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Operation: Equatable, Sendable {
    case upsert(Qdrant_PointsUpdateOperation.PointStructList)
    /// NOTE: This field was marked as deprecated in the .proto file.
    case deleteDeprecated(Qdrant_PointsSelector)
    case setPayload(Qdrant_PointsUpdateOperation.SetPayload)
    case overwritePayload(Qdrant_PointsUpdateOperation.OverwritePayload)
    case deletePayload(Qdrant_PointsUpdateOperation.DeletePayload)
    /// NOTE: This field was marked as deprecated in the .proto file.
    case clearPayloadDeprecated_p(Qdrant_PointsSelector)
    case updateVectors(Qdrant_PointsUpdateOperation.UpdateVectors)
    case deleteVectors(Qdrant_PointsUpdateOperation.DeleteVectors)
    case deletePoints(Qdrant_PointsUpdateOperation.DeletePoints)
    case clearPayload_p(Qdrant_PointsUpdateOperation.ClearPayload)

  }

  public struct PointStructList: Sendable {
    public var points: [Qdrant_PointStruct] = []

    /// Option for custom sharding to specify used shard keys
    public var shardKeySelector: Qdrant_ShardKeySelector {
      get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
      set {_shardKeySelector = newValue}
    }
      public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
      public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

    /// If specified, only points that match this filter will be updated, others will be inserted
    public var updateFilter: Qdrant_Filter {
      get {return _updateFilter ?? Qdrant_Filter()}
      set {_updateFilter = newValue}
    }
      public var hasUpdateFilter: Bool {return self._updateFilter != nil}
      public mutating func clearUpdateFilter() {self._updateFilter = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
    fileprivate var _updateFilter: Qdrant_Filter? = nil
  }

  public struct SetPayload: Sendable {
    public var payload: Dictionary<String,Qdrant_Value> = [:]

    /// Affected points
    public var pointsSelector: Qdrant_PointsSelector {
      get {return _pointsSelector ?? Qdrant_PointsSelector()}
      set {_pointsSelector = newValue}
    }
      public var hasPointsSelector: Bool {return self._pointsSelector != nil}
      public mutating func clearPointsSelector() {self._pointsSelector = nil}

    /// Option for custom sharding to specify used shard keys
    public var shardKeySelector: Qdrant_ShardKeySelector {
      get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
      set {_shardKeySelector = newValue}
    }
      public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
      public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

    /// Option for indicate property of payload
    public var key: String {
      get {return _key ?? String()}
      set {_key = newValue}
    }
      public var hasKey: Bool {return self._key != nil}
      public mutating func clearKey() {self._key = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pointsSelector: Qdrant_PointsSelector? = nil
    fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
    fileprivate var _key: String? = nil
  }

  public struct OverwritePayload: Sendable {
    public var payload: Dictionary<String,Qdrant_Value> = [:]

    /// Affected points
    public var pointsSelector: Qdrant_PointsSelector {
      get {return _pointsSelector ?? Qdrant_PointsSelector()}
      set {_pointsSelector = newValue}
    }
      public var hasPointsSelector: Bool {return self._pointsSelector != nil}
      public mutating func clearPointsSelector() {self._pointsSelector = nil}

    /// Option for custom sharding to specify used shard keys
    public var shardKeySelector: Qdrant_ShardKeySelector {
      get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
      set {_shardKeySelector = newValue}
    }
      public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
      public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

    /// Option for indicate property of payload
    public var key: String {
      get {return _key ?? String()}
      set {_key = newValue}
    }
      public var hasKey: Bool {return self._key != nil}
      public mutating func clearKey() {self._key = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pointsSelector: Qdrant_PointsSelector? = nil
    fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
    fileprivate var _key: String? = nil
  }

  public struct DeletePayload: Sendable {
    public var keys: [String] = []

    /// Affected points
    public var pointsSelector: Qdrant_PointsSelector {
      get {return _pointsSelector ?? Qdrant_PointsSelector()}
      set {_pointsSelector = newValue}
    }
      public var hasPointsSelector: Bool {return self._pointsSelector != nil}
      public mutating func clearPointsSelector() {self._pointsSelector = nil}

    /// Option for custom sharding to specify used shard keys
    public var shardKeySelector: Qdrant_ShardKeySelector {
      get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
      set {_shardKeySelector = newValue}
    }
      public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
      public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pointsSelector: Qdrant_PointsSelector? = nil
    fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  }

  public struct UpdateVectors: Sendable {
    /// List of points and vectors to update
    public var points: [Qdrant_PointVectors] = []

    /// Option for custom sharding to specify used shard keys
    public var shardKeySelector: Qdrant_ShardKeySelector {
      get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
      set {_shardKeySelector = newValue}
    }
      public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
      public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

    /// If specified, only points that match this filter will be updated
    public var updateFilter: Qdrant_Filter {
      get {return _updateFilter ?? Qdrant_Filter()}
      set {_updateFilter = newValue}
    }
      public var hasUpdateFilter: Bool {return self._updateFilter != nil}
      public mutating func clearUpdateFilter() {self._updateFilter = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
    fileprivate var _updateFilter: Qdrant_Filter? = nil
  }

  public struct DeleteVectors: Sendable {
    /// Affected points
    public var pointsSelector: Qdrant_PointsSelector {
      get {return _pointsSelector ?? Qdrant_PointsSelector()}
      set {_pointsSelector = newValue}
    }
      public var hasPointsSelector: Bool {return self._pointsSelector != nil}
      public mutating func clearPointsSelector() {self._pointsSelector = nil}

    /// List of vector names to delete
    public var vectors: Qdrant_VectorsSelector {
      get {return _vectors ?? Qdrant_VectorsSelector()}
      set {_vectors = newValue}
    }
      public var hasVectors: Bool {return self._vectors != nil}
      public mutating func clearVectors() {self._vectors = nil}

    /// Option for custom sharding to specify used shard keys
    public var shardKeySelector: Qdrant_ShardKeySelector {
      get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
      set {_shardKeySelector = newValue}
    }
      public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
      public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pointsSelector: Qdrant_PointsSelector? = nil
    fileprivate var _vectors: Qdrant_VectorsSelector? = nil
    fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  }

  public struct DeletePoints: Sendable {
    /// Affected points
    public var points: Qdrant_PointsSelector {
      get {return _points ?? Qdrant_PointsSelector()}
      set {_points = newValue}
    }
      public var hasPoints: Bool {return self._points != nil}
      public mutating func clearPoints() {self._points = nil}

    /// Option for custom sharding to specify used shard keys
    public var shardKeySelector: Qdrant_ShardKeySelector {
      get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
      set {_shardKeySelector = newValue}
    }
      public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
      public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _points: Qdrant_PointsSelector? = nil
    fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  }

  public struct ClearPayload: Sendable {
    /// Affected points
    public var points: Qdrant_PointsSelector {
      get {return _points ?? Qdrant_PointsSelector()}
      set {_points = newValue}
    }
      public var hasPoints: Bool {return self._points != nil}
      public mutating func clearPoints() {self._points = nil}

    /// Option for custom sharding to specify used shard keys
    public var shardKeySelector: Qdrant_ShardKeySelector {
      get {return _shardKeySelector ?? Qdrant_ShardKeySelector()}
      set {_shardKeySelector = newValue}
    }
      public var hasShardKeySelector: Bool {return self._shardKeySelector != nil}
      public mutating func clearShardKeySelector() {self._shardKeySelector = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _points: Qdrant_PointsSelector? = nil
    fileprivate var _shardKeySelector: Qdrant_ShardKeySelector? = nil
  }

  public init() {}
}

public struct Qdrant_UpdateBatchPoints: Sendable {
  /// name of the collection
  public var collectionName: String = String()

  /// Wait until the changes have been applied?
  public var wait: Bool {
    get {return _wait ?? false}
    set {_wait = newValue}
  }
  public var hasWait: Bool {return self._wait != nil}
  public mutating func clearWait() {self._wait = nil}

  public var operations: [Qdrant_PointsUpdateOperation] = []

  /// Write ordering guarantees
  public var ordering: Qdrant_WriteOrdering {
    get {return _ordering ?? Qdrant_WriteOrdering()}
    set {_ordering = newValue}
  }
  public var hasOrdering: Bool {return self._ordering != nil}
  public mutating func clearOrdering() {self._ordering = nil}

  /// Timeout for the operation in seconds
  public var timeout: UInt64 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  public var hasTimeout: Bool {return self._timeout != nil}
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wait: Bool? = nil
  fileprivate var _ordering: Qdrant_WriteOrdering? = nil
  fileprivate var _timeout: UInt64? = nil
}

public struct Qdrant_PointsOperationResponse: Sendable {
  public var result: Qdrant_UpdateResult {
    get {return _result ?? Qdrant_UpdateResult()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_UpdateResult? = nil
  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_UpdateResult: Sendable {
  /// Number of operation
  public var operationID: UInt64 {
    get {return _operationID ?? 0}
    set {_operationID = newValue}
  }
  public var hasOperationID: Bool {return self._operationID != nil}
  public mutating func clearOperationID() {self._operationID = nil}

  /// Operation status
  public var status: Qdrant_UpdateStatus = .unknownUpdateStatus

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _operationID: UInt64? = nil
}

public struct Qdrant_OrderValue: Sendable {
  public var variant: Qdrant_OrderValue.OneOf_Variant? = nil

  public var int: Int64 {
    get {
      if case .int(let v)? = variant {return v}
      return 0
    }
    set {variant = .int(newValue)}
  }

  public var float: Double {
    get {
      if case .float(let v)? = variant {return v}
      return 0
    }
    set {variant = .float(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Variant: Equatable, Sendable {
    case int(Int64)
    case float(Double)

  }

  public init() {}
}

public struct Qdrant_ScoredPoint: Sendable {
  /// Point id
  public var id: Qdrant_PointId {
    get {return _id ?? Qdrant_PointId()}
    set {_id = newValue}
  }
  public var hasID: Bool {return self._id != nil}
  public mutating func clearID() {self._id = nil}

  /// Payload
  public var payload: Dictionary<String,Qdrant_Value> = [:]

  /// Similarity score
  public var score: Float = 0

  /// Last update operation applied to this point
  public var version: UInt64 = 0

  /// Vectors to search
  public var vectors: Qdrant_VectorsOutput {
    get {return _vectors ?? Qdrant_VectorsOutput()}
    set {_vectors = newValue}
  }
  public var hasVectors: Bool {return self._vectors != nil}
  public mutating func clearVectors() {self._vectors = nil}

  /// Shard key
  public var shardKey: Qdrant_ShardKey {
    get {return _shardKey ?? Qdrant_ShardKey()}
    set {_shardKey = newValue}
  }
  public var hasShardKey: Bool {return self._shardKey != nil}
  public mutating func clearShardKey() {self._shardKey = nil}

  /// Order by value
  public var orderValue: Qdrant_OrderValue {
    get {return _orderValue ?? Qdrant_OrderValue()}
    set {_orderValue = newValue}
  }
  public var hasOrderValue: Bool {return self._orderValue != nil}
  public mutating func clearOrderValue() {self._orderValue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Qdrant_PointId? = nil
  fileprivate var _vectors: Qdrant_VectorsOutput? = nil
  fileprivate var _shardKey: Qdrant_ShardKey? = nil
  fileprivate var _orderValue: Qdrant_OrderValue? = nil
}

public struct Qdrant_GroupId: Sendable {
  public var kind: Qdrant_GroupId.OneOf_Kind? = nil

  /// Represents an unsigned integer value.
  public var unsignedValue: UInt64 {
    get {
      if case .unsignedValue(let v)? = kind {return v}
      return 0
    }
    set {kind = .unsignedValue(newValue)}
  }

  /// Represents an integer value
  public var integerValue: Int64 {
    get {
      if case .integerValue(let v)? = kind {return v}
      return 0
    }
    set {kind = .integerValue(newValue)}
  }

  /// Represents a string value.
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = kind {return v}
      return String()
    }
    set {kind = .stringValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable, Sendable {
    /// Represents an unsigned integer value.
    case unsignedValue(UInt64)
    /// Represents an integer value
    case integerValue(Int64)
    /// Represents a string value.
    case stringValue(String)

  }

  public init() {}
}

public struct Qdrant_PointGroup: Sendable {
  /// Group id
  public var id: Qdrant_GroupId {
    get {return _id ?? Qdrant_GroupId()}
    set {_id = newValue}
  }
  public var hasID: Bool {return self._id != nil}
  public mutating func clearID() {self._id = nil}

  /// Points in the group
  public var hits: [Qdrant_ScoredPoint] = []

  /// Point(s) from the lookup collection that matches the group id
  public var lookup: Qdrant_RetrievedPoint {
    get {return _lookup ?? Qdrant_RetrievedPoint()}
    set {_lookup = newValue}
  }
  public var hasLookup: Bool {return self._lookup != nil}
  public mutating func clearLookup() {self._lookup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Qdrant_GroupId? = nil
  fileprivate var _lookup: Qdrant_RetrievedPoint? = nil
}

public struct Qdrant_GroupsResult: Sendable {
  /// Groups
  public var groups: [Qdrant_PointGroup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_SearchResponse: Sendable {
  public var result: [Qdrant_ScoredPoint] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_QueryResponse: Sendable {
  public var result: [Qdrant_ScoredPoint] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_QueryBatchResponse: Sendable {
  public var result: [Qdrant_BatchResult] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_QueryGroupsResponse: Sendable {
  public var result: Qdrant_GroupsResult {
    get {return _result ?? Qdrant_GroupsResult()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_GroupsResult? = nil
  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_BatchResult: Sendable {
  public var result: [Qdrant_ScoredPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_SearchBatchResponse: Sendable {
  public var result: [Qdrant_BatchResult] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_SearchGroupsResponse: Sendable {
  public var result: Qdrant_GroupsResult {
    get {return _result ?? Qdrant_GroupsResult()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_GroupsResult? = nil
  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_CountResponse: Sendable {
  public var result: Qdrant_CountResult {
    get {return _result ?? Qdrant_CountResult()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_CountResult? = nil
  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_ScrollResponse: Sendable {
  /// Use this offset for the next query
  public var nextPageOffset: Qdrant_PointId {
    get {return _nextPageOffset ?? Qdrant_PointId()}
    set {_nextPageOffset = newValue}
  }
  public var hasNextPageOffset: Bool {return self._nextPageOffset != nil}
  public mutating func clearNextPageOffset() {self._nextPageOffset = nil}

  public var result: [Qdrant_RetrievedPoint] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nextPageOffset: Qdrant_PointId? = nil
  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_CountResult: Sendable {
  public var count: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_RetrievedPoint: Sendable {
  public var id: Qdrant_PointId {
    get {return _id ?? Qdrant_PointId()}
    set {_id = newValue}
  }
  public var hasID: Bool {return self._id != nil}
  public mutating func clearID() {self._id = nil}

  public var payload: Dictionary<String,Qdrant_Value> = [:]

  public var vectors: Qdrant_VectorsOutput {
    get {return _vectors ?? Qdrant_VectorsOutput()}
    set {_vectors = newValue}
  }
  public var hasVectors: Bool {return self._vectors != nil}
  public mutating func clearVectors() {self._vectors = nil}

  /// Shard key
  public var shardKey: Qdrant_ShardKey {
    get {return _shardKey ?? Qdrant_ShardKey()}
    set {_shardKey = newValue}
  }
  public var hasShardKey: Bool {return self._shardKey != nil}
  public mutating func clearShardKey() {self._shardKey = nil}

  /// Order-by value
  public var orderValue: Qdrant_OrderValue {
    get {return _orderValue ?? Qdrant_OrderValue()}
    set {_orderValue = newValue}
  }
  public var hasOrderValue: Bool {return self._orderValue != nil}
  public mutating func clearOrderValue() {self._orderValue = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Qdrant_PointId? = nil
  fileprivate var _vectors: Qdrant_VectorsOutput? = nil
  fileprivate var _shardKey: Qdrant_ShardKey? = nil
  fileprivate var _orderValue: Qdrant_OrderValue? = nil
}

public struct Qdrant_GetResponse: Sendable {
  public var result: [Qdrant_RetrievedPoint] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_RecommendResponse: Sendable {
  public var result: [Qdrant_ScoredPoint] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_RecommendBatchResponse: Sendable {
  public var result: [Qdrant_BatchResult] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_DiscoverResponse: Sendable {
  public var result: [Qdrant_ScoredPoint] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_DiscoverBatchResponse: Sendable {
  public var result: [Qdrant_BatchResult] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_RecommendGroupsResponse: Sendable {
  public var result: Qdrant_GroupsResult {
    get {return _result ?? Qdrant_GroupsResult()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_GroupsResult? = nil
  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_UpdateBatchResponse: Sendable {
  public var result: [Qdrant_UpdateResult] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_FacetResponse: Sendable {
  public var hits: [Qdrant_FacetHit] = []

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_SearchMatrixPairsResponse: Sendable {
  public var result: Qdrant_SearchMatrixPairs {
    get {return _result ?? Qdrant_SearchMatrixPairs()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_SearchMatrixPairs? = nil
  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_SearchMatrixOffsetsResponse: Sendable {
  public var result: Qdrant_SearchMatrixOffsets {
    get {return _result ?? Qdrant_SearchMatrixOffsets()}
    set {_result = newValue}
  }
  public var hasResult: Bool {return self._result != nil}
  public mutating func clearResult() {self._result = nil}

  /// Time spent to process
  public var time: Double = 0

  public var usage: Qdrant_Usage {
    get {return _usage ?? Qdrant_Usage()}
    set {_usage = newValue}
  }
  public var hasUsage: Bool {return self._usage != nil}
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Qdrant_SearchMatrixOffsets? = nil
  fileprivate var _usage: Qdrant_Usage? = nil
}

public struct Qdrant_PointsSelector: Sendable {
  public var pointsSelectorOneOf: Qdrant_PointsSelector.OneOf_PointsSelectorOneOf? = nil

  public var points: Qdrant_PointsIdsList {
    get {
      if case .points(let v)? = pointsSelectorOneOf {return v}
      return Qdrant_PointsIdsList()
    }
    set {pointsSelectorOneOf = .points(newValue)}
  }

  public var filter: Qdrant_Filter {
    get {
      if case .filter(let v)? = pointsSelectorOneOf {return v}
      return Qdrant_Filter()
    }
    set {pointsSelectorOneOf = .filter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PointsSelectorOneOf: Equatable, Sendable {
    case points(Qdrant_PointsIdsList)
    case filter(Qdrant_Filter)

  }

  public init() {}
}

public struct Qdrant_PointsIdsList: Sendable {
  public var ids: [Qdrant_PointId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_PointStruct: Sendable {
  public var id: Qdrant_PointId {
    get {return _id ?? Qdrant_PointId()}
    set {_id = newValue}
  }
  public var hasID: Bool {return self._id != nil}
  public mutating func clearID() {self._id = nil}

  public var payload: Dictionary<String,Qdrant_Value> = [:]

  public var vectors: Qdrant_Vectors {
    get {return _vectors ?? Qdrant_Vectors()}
    set {_vectors = newValue}
  }
  public var hasVectors: Bool {return self._vectors != nil}
  public mutating func clearVectors() {self._vectors = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Qdrant_PointId? = nil
  fileprivate var _vectors: Qdrant_Vectors? = nil
}

/// ---------------------------------------------
/// ----------- Measurements collector ----------
/// ---------------------------------------------
public struct Qdrant_Usage: Sendable {
  public var hardware: Qdrant_HardwareUsage {
    get {return _hardware ?? Qdrant_HardwareUsage()}
    set {_hardware = newValue}
  }
  public var hasHardware: Bool {return self._hardware != nil}
  public mutating func clearHardware() {self._hardware = nil}

  public var inference: Qdrant_InferenceUsage {
    get {return _inference ?? Qdrant_InferenceUsage()}
    set {_inference = newValue}
  }
  public var hasInference: Bool {return self._inference != nil}
  public mutating func clearInference() {self._inference = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hardware: Qdrant_HardwareUsage? = nil
  fileprivate var _inference: Qdrant_InferenceUsage? = nil
}

public struct Qdrant_InferenceUsage: Sendable {
  public var models: Dictionary<String,Qdrant_ModelUsage> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_ModelUsage: Sendable {
  public var tokens: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_HardwareUsage: Sendable {
  public var cpu: UInt64 = 0

  public var payloadIoRead: UInt64 = 0

  public var payloadIoWrite: UInt64 = 0

  public var payloadIndexIoRead: UInt64 = 0

  public var payloadIndexIoWrite: UInt64 = 0

  public var vectorIoRead: UInt64 = 0

  public var vectorIoWrite: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qdrant"

extension Qdrant_WriteOrderingType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Weak\0\u{1}Medium\0\u{1}Strong\0")
}

extension Qdrant_ReadConsistencyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0All\0\u{1}Majority\0\u{1}Quorum\0")
}

extension Qdrant_FieldType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0FieldTypeKeyword\0\u{1}FieldTypeInteger\0\u{1}FieldTypeFloat\0\u{1}FieldTypeGeo\0\u{1}FieldTypeText\0\u{1}FieldTypeBool\0\u{1}FieldTypeDatetime\0\u{1}FieldTypeUuid\0")
}

extension Qdrant_Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Asc\0\u{1}Desc\0")
}

extension Qdrant_RecommendStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0AverageVector\0\u{1}BestScore\0\u{1}SumScores\0")
}

extension Qdrant_Fusion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RRF\0\u{1}DBSF\0")
}

extension Qdrant_Sample: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Random\0")
}

extension Qdrant_UpdateStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UnknownUpdateStatus\0\u{1}Acknowledged\0\u{1}Completed\0\u{1}ClockRejected\0")
}

extension Qdrant_WriteOrdering: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteOrdering"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .weak {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_WriteOrdering, rhs: Qdrant_WriteOrdering) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ReadConsistency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadConsistency"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}factor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_ReadConsistencyType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .type(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .factor(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .type?: try {
      guard case .type(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .factor?: try {
      guard case .factor(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ReadConsistency, rhs: Qdrant_ReadConsistency) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SparseIndices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SparseIndices"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SparseIndices, rhs: Qdrant_SparseIndices) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Document"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{2}\u{2}model\0\u{1}options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 3)
    }
    if !self.options.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.options, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Document, rhs: Qdrant_Document) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.model != rhs.model {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Image"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}image\0\u{1}model\0\u{1}options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    if !self.options.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.options, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Image, rhs: Qdrant_Image) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.model != rhs.model {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_InferenceObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InferenceObject"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}object\0\u{1}model\0\u{1}options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._object) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._object {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 2)
    }
    if !self.options.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.options, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_InferenceObject, rhs: Qdrant_InferenceObject) -> Bool {
    if lhs._object != rhs._object {return false}
    if lhs.model != rhs.model {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Vector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0\u{1}indices\0\u{3}vectors_count\0\u{2}b\u{1}dense\0\u{1}sparse\0\u{3}multi_dense\0\u{1}document\0\u{1}image\0\u{1}object\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._indices) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._vectorsCount) }()
      case 101: try {
        var v: Qdrant_DenseVector?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .dense(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .dense(v)
        }
      }()
      case 102: try {
        var v: Qdrant_SparseVector?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .sparse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .sparse(v)
        }
      }()
      case 103: try {
        var v: Qdrant_MultiDenseVector?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .multiDense(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .multiDense(v)
        }
      }()
      case 104: try {
        var v: Qdrant_Document?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .document(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .document(v)
        }
      }()
      case 105: try {
        var v: Qdrant_Image?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .image(v)
        }
      }()
      case 106: try {
        var v: Qdrant_InferenceObject?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .object(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .object(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.data.isEmpty {
      try visitor.visitPackedFloatField(value: self.data, fieldNumber: 1)
    }
    try { if let v = self._indices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._vectorsCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    switch self.vector {
    case .dense?: try {
      guard case .dense(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .sparse?: try {
      guard case .sparse(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .multiDense?: try {
      guard case .multiDense(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .document?: try {
      guard case .document(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .image?: try {
      guard case .image(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .object?: try {
      guard case .object(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Vector, rhs: Qdrant_Vector) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs._indices != rhs._indices {return false}
    if lhs._vectorsCount != rhs._vectorsCount {return false}
    if lhs.vector != rhs.vector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorOutput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0\u{1}indices\0\u{3}vectors_count\0\u{2}b\u{1}dense\0\u{1}sparse\0\u{3}multi_dense\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._indices) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._vectorsCount) }()
      case 101: try {
        var v: Qdrant_DenseVector?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .dense(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .dense(v)
        }
      }()
      case 102: try {
        var v: Qdrant_SparseVector?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .sparse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .sparse(v)
        }
      }()
      case 103: try {
        var v: Qdrant_MultiDenseVector?
        var hadOneofValue = false
        if let current = self.vector {
          hadOneofValue = true
          if case .multiDense(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vector = .multiDense(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.data.isEmpty {
      try visitor.visitPackedFloatField(value: self.data, fieldNumber: 1)
    }
    try { if let v = self._indices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._vectorsCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    switch self.vector {
    case .dense?: try {
      guard case .dense(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .sparse?: try {
      guard case .sparse(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .multiDense?: try {
      guard case .multiDense(let v)? = self.vector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorOutput, rhs: Qdrant_VectorOutput) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs._indices != rhs._indices {return false}
    if lhs._vectorsCount != rhs._vectorsCount {return false}
    if lhs.vector != rhs.vector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DenseVector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DenseVector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitPackedFloatField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DenseVector, rhs: Qdrant_DenseVector) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SparseVector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SparseVector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0\u{1}indices\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFloatField(value: &self.values) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.indices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitPackedFloatField(value: self.values, fieldNumber: 1)
    }
    if !self.indices.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.indices, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SparseVector, rhs: Qdrant_SparseVector) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.indices != rhs.indices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_MultiDenseVector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiDenseVector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vectors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.vectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_MultiDenseVector, rhs: Qdrant_MultiDenseVector) -> Bool {
    if lhs.vectors != rhs.vectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}dense\0\u{1}sparse\0\u{3}multi_dense\0\u{1}document\0\u{1}image\0\u{1}object\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_PointId?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .id(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .id(v)
        }
      }()
      case 2: try {
        var v: Qdrant_DenseVector?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .dense(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .dense(v)
        }
      }()
      case 3: try {
        var v: Qdrant_SparseVector?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .sparse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .sparse(v)
        }
      }()
      case 4: try {
        var v: Qdrant_MultiDenseVector?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .multiDense(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .multiDense(v)
        }
      }()
      case 5: try {
        var v: Qdrant_Document?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .document(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .document(v)
        }
      }()
      case 6: try {
        var v: Qdrant_Image?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .image(v)
        }
      }()
      case 7: try {
        var v: Qdrant_InferenceObject?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .object(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .object(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .id?: try {
      guard case .id(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .dense?: try {
      guard case .dense(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .sparse?: try {
      guard case .sparse(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .multiDense?: try {
      guard case .multiDense(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .document?: try {
      guard case .document(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .image?: try {
      guard case .image(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .object?: try {
      guard case .object(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorInput, rhs: Qdrant_VectorInput) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ShardKeySelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShardKeySelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}shard_keys\0\u{1}fallback\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.shardKeys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fallback) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.shardKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shardKeys, fieldNumber: 1)
    }
    try { if let v = self._fallback {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ShardKeySelector, rhs: Qdrant_ShardKeySelector) -> Bool {
    if lhs.shardKeys != rhs.shardKeys {return false}
    if lhs._fallback != rhs._fallback {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UpsertPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpsertPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{1}points\0\u{1}ordering\0\u{3}shard_key_selector\0\u{3}update_filter\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateFilter) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 3)
    }
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updateFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UpsertPoints, rhs: Qdrant_UpsertPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs.points != rhs.points {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._updateFilter != rhs._updateFilter {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeletePoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{1}points\0\u{1}ordering\0\u{3}shard_key_selector\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._points) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._points {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeletePoints, rhs: Qdrant_DeletePoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs._points != rhs._points {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GetPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}ids\0\u{4}\u{2}with_payload\0\u{3}with_vectors\0\u{3}read_consistency\0\u{3}shard_key_selector\0\u{1}timeout\0\u{c}\u{3}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._withPayload) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._withVectors) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._readConsistency) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 2)
    }
    try { if let v = self._withPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._withVectors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._readConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GetPoints, rhs: Qdrant_GetPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs._withPayload != rhs._withPayload {return false}
    if lhs._withVectors != rhs._withVectors {return false}
    if lhs._readConsistency != rhs._readConsistency {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UpdatePointVectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePointVectors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{1}points\0\u{1}ordering\0\u{3}shard_key_selector\0\u{3}update_filter\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateFilter) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 3)
    }
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updateFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UpdatePointVectors, rhs: Qdrant_UpdatePointVectors) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs.points != rhs.points {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._updateFilter != rhs._updateFilter {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointVectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointVectors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}vectors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._vectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._vectors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointVectors, rhs: Qdrant_PointVectors) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._vectors != rhs._vectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeletePointVectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePointVectors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{3}points_selector\0\u{1}vectors\0\u{1}ordering\0\u{3}shard_key_selector\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pointsSelector) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._vectors) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pointsSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._vectors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeletePointVectors, rhs: Qdrant_DeletePointVectors) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs._pointsSelector != rhs._pointsSelector {return false}
    if lhs._vectors != rhs._vectors {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SetPayloadPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetPayloadPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{1}payload\0\u{4}\u{2}points_selector\0\u{1}ordering\0\u{3}shard_key_selector\0\u{1}key\0\u{1}timeout\0\u{c}\u{4}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.payload) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pointsSelector) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.payload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.payload, fieldNumber: 3)
    }
    try { if let v = self._pointsSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SetPayloadPoints, rhs: Qdrant_SetPayloadPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs._pointsSelector != rhs._pointsSelector {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._key != rhs._key {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeletePayloadPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePayloadPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{1}keys\0\u{4}\u{2}points_selector\0\u{1}ordering\0\u{3}shard_key_selector\0\u{1}timeout\0\u{c}\u{4}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pointsSelector) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 3)
    }
    try { if let v = self._pointsSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeletePayloadPoints, rhs: Qdrant_DeletePayloadPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs._pointsSelector != rhs._pointsSelector {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ClearPayloadPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClearPayloadPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{1}points\0\u{1}ordering\0\u{3}shard_key_selector\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._points) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._points {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ClearPayloadPoints, rhs: Qdrant_ClearPayloadPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs._points != rhs._points {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CreateFieldIndexCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFieldIndexCollection"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{3}field_name\0\u{3}field_type\0\u{3}field_index_params\0\u{1}ordering\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._fieldType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._fieldIndexParams) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 3)
    }
    try { if let v = self._fieldType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fieldIndexParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CreateFieldIndexCollection, rhs: Qdrant_CreateFieldIndexCollection) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs._fieldType != rhs._fieldType {return false}
    if lhs._fieldIndexParams != rhs._fieldIndexParams {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DeleteFieldIndexCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFieldIndexCollection"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{3}field_name\0\u{1}ordering\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fieldName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.fieldName.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldName, fieldNumber: 3)
    }
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DeleteFieldIndexCollection, rhs: Qdrant_DeleteFieldIndexCollection) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs.fieldName != rhs.fieldName {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PayloadIncludeSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayloadIncludeSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fields\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PayloadIncludeSelector, rhs: Qdrant_PayloadIncludeSelector) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PayloadExcludeSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayloadExcludeSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fields\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PayloadExcludeSelector, rhs: Qdrant_PayloadExcludeSelector) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_WithPayloadSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithPayloadSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enable\0\u{1}include\0\u{1}exclude\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.selectorOptions != nil {try decoder.handleConflictingOneOf()}
          self.selectorOptions = .enable(v)
        }
      }()
      case 2: try {
        var v: Qdrant_PayloadIncludeSelector?
        var hadOneofValue = false
        if let current = self.selectorOptions {
          hadOneofValue = true
          if case .include(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.selectorOptions = .include(v)
        }
      }()
      case 3: try {
        var v: Qdrant_PayloadExcludeSelector?
        var hadOneofValue = false
        if let current = self.selectorOptions {
          hadOneofValue = true
          if case .exclude(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.selectorOptions = .exclude(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.selectorOptions {
    case .enable?: try {
      guard case .enable(let v)? = self.selectorOptions else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .include?: try {
      guard case .include(let v)? = self.selectorOptions else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .exclude?: try {
      guard case .exclude(let v)? = self.selectorOptions else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_WithPayloadSelector, rhs: Qdrant_WithPayloadSelector) -> Bool {
    if lhs.selectorOptions != rhs.selectorOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_NamedVectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedVectors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vectors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Vector>.self, value: &self.vectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vectors.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Vector>.self, value: self.vectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_NamedVectors, rhs: Qdrant_NamedVectors) -> Bool {
    if lhs.vectors != rhs.vectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_NamedVectorsOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedVectorsOutput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vectors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_VectorOutput>.self, value: &self.vectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vectors.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_VectorOutput>.self, value: self.vectors, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_NamedVectorsOutput, rhs: Qdrant_NamedVectorsOutput) -> Bool {
    if lhs.vectors != rhs.vectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Vectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vectors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vector\0\u{1}vectors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_Vector?
        var hadOneofValue = false
        if let current = self.vectorsOptions {
          hadOneofValue = true
          if case .vector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vectorsOptions = .vector(v)
        }
      }()
      case 2: try {
        var v: Qdrant_NamedVectors?
        var hadOneofValue = false
        if let current = self.vectorsOptions {
          hadOneofValue = true
          if case .vectors(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vectorsOptions = .vectors(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.vectorsOptions {
    case .vector?: try {
      guard case .vector(let v)? = self.vectorsOptions else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .vectors?: try {
      guard case .vectors(let v)? = self.vectorsOptions else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Vectors, rhs: Qdrant_Vectors) -> Bool {
    if lhs.vectorsOptions != rhs.vectorsOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorsOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorsOutput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}vector\0\u{1}vectors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_VectorOutput?
        var hadOneofValue = false
        if let current = self.vectorsOptions {
          hadOneofValue = true
          if case .vector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vectorsOptions = .vector(v)
        }
      }()
      case 2: try {
        var v: Qdrant_NamedVectorsOutput?
        var hadOneofValue = false
        if let current = self.vectorsOptions {
          hadOneofValue = true
          if case .vectors(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.vectorsOptions = .vectors(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.vectorsOptions {
    case .vector?: try {
      guard case .vector(let v)? = self.vectorsOptions else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .vectors?: try {
      guard case .vectors(let v)? = self.vectorsOptions else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorsOutput, rhs: Qdrant_VectorsOutput) -> Bool {
    if lhs.vectorsOptions != rhs.vectorsOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorsSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorsSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}names\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.names) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorsSelector, rhs: Qdrant_VectorsSelector) -> Bool {
    if lhs.names != rhs.names {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_WithVectorsSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithVectorsSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enable\0\u{1}include\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.selectorOptions != nil {try decoder.handleConflictingOneOf()}
          self.selectorOptions = .enable(v)
        }
      }()
      case 2: try {
        var v: Qdrant_VectorsSelector?
        var hadOneofValue = false
        if let current = self.selectorOptions {
          hadOneofValue = true
          if case .include(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.selectorOptions = .include(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.selectorOptions {
    case .enable?: try {
      guard case .enable(let v)? = self.selectorOptions else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .include?: try {
      guard case .include(let v)? = self.selectorOptions else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_WithVectorsSelector, rhs: Qdrant_WithVectorsSelector) -> Bool {
    if lhs.selectorOptions != rhs.selectorOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QuantizationSearchParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuantizationSearchParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ignore\0\u{1}rescore\0\u{1}oversampling\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._ignore) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._rescore) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._oversampling) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ignore {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._rescore {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oversampling {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QuantizationSearchParams, rhs: Qdrant_QuantizationSearchParams) -> Bool {
    if lhs._ignore != rhs._ignore {return false}
    if lhs._rescore != rhs._rescore {return false}
    if lhs._oversampling != rhs._oversampling {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_AcornSearchParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcornSearchParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enable\0\u{3}max_selectivity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._maxSelectivity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxSelectivity {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_AcornSearchParams, rhs: Qdrant_AcornSearchParams) -> Bool {
    if lhs._enable != rhs._enable {return false}
    if lhs._maxSelectivity != rhs._maxSelectivity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchParams"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}hnsw_ef\0\u{1}exact\0\u{1}quantization\0\u{3}indexed_only\0\u{1}acorn\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._hnswEf) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._exact) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._quantization) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._indexedOnly) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._acorn) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hnswEf {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exact {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._quantization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._indexedOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._acorn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchParams, rhs: Qdrant_SearchParams) -> Bool {
    if lhs._hnswEf != rhs._hnswEf {return false}
    if lhs._exact != rhs._exact {return false}
    if lhs._quantization != rhs._quantization {return false}
    if lhs._indexedOnly != rhs._indexedOnly {return false}
    if lhs._acorn != rhs._acorn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}vector\0\u{1}filter\0\u{1}limit\0\u{4}\u{2}with_payload\0\u{1}params\0\u{3}score_threshold\0\u{1}offset\0\u{3}vector_name\0\u{3}with_vectors\0\u{3}read_consistency\0\u{1}timeout\0\u{3}shard_key_selector\0\u{3}sparse_indices\0\u{c}\u{5}\u{1}")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _vector: [Float] = []
    var _filter: Qdrant_Filter? = nil
    var _limit: UInt64 = 0
    var _withPayload: Qdrant_WithPayloadSelector? = nil
    var _params: Qdrant_SearchParams? = nil
    var _scoreThreshold: Float? = nil
    var _offset: UInt64? = nil
    var _vectorName: String? = nil
    var _withVectors: Qdrant_WithVectorsSelector? = nil
    var _readConsistency: Qdrant_ReadConsistency? = nil
    var _timeout: UInt64? = nil
    var _shardKeySelector: Qdrant_ShardKeySelector? = nil
    var _sparseIndices: Qdrant_SparseIndices? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _vector = source._vector
      _filter = source._filter
      _limit = source._limit
      _withPayload = source._withPayload
      _params = source._params
      _scoreThreshold = source._scoreThreshold
      _offset = source._offset
      _vectorName = source._vectorName
      _withVectors = source._withVectors
      _readConsistency = source._readConsistency
      _timeout = source._timeout
      _shardKeySelector = source._shardKeySelector
      _sparseIndices = source._sparseIndices
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeRepeatedFloatField(value: &_storage._vector) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._limit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._withPayload) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._scoreThreshold) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._offset) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._vectorName) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._withVectors) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._readConsistency) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._shardKeySelector) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._sparseIndices) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      if !_storage._vector.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._vector, fieldNumber: 2)
      }
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._limit != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._limit, fieldNumber: 4)
      }
      try { if let v = _storage._withPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._scoreThreshold {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._offset {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._vectorName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._withVectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._readConsistency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._shardKeySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._sparseIndices {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchPoints, rhs: Qdrant_SearchPoints) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._vector != rhs_storage._vector {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._withPayload != rhs_storage._withPayload {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._scoreThreshold != rhs_storage._scoreThreshold {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._vectorName != rhs_storage._vectorName {return false}
        if _storage._withVectors != rhs_storage._withVectors {return false}
        if _storage._readConsistency != rhs_storage._readConsistency {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._shardKeySelector != rhs_storage._shardKeySelector {return false}
        if _storage._sparseIndices != rhs_storage._sparseIndices {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchBatchPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchBatchPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{3}search_points\0\u{3}read_consistency\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.searchPoints) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readConsistency) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    if !self.searchPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searchPoints, fieldNumber: 2)
    }
    try { if let v = self._readConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchBatchPoints, rhs: Qdrant_SearchBatchPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.searchPoints != rhs.searchPoints {return false}
    if lhs._readConsistency != rhs._readConsistency {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_WithLookup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WithLookup"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}collection\0\u{3}with_payload\0\u{3}with_vectors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collection) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._withPayload) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._withVectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collection.isEmpty {
      try visitor.visitSingularStringField(value: self.collection, fieldNumber: 1)
    }
    try { if let v = self._withPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._withVectors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_WithLookup, rhs: Qdrant_WithLookup) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs._withPayload != rhs._withPayload {return false}
    if lhs._withVectors != rhs._withVectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchPointGroups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchPointGroups"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}vector\0\u{1}filter\0\u{1}limit\0\u{3}with_payload\0\u{1}params\0\u{3}score_threshold\0\u{3}vector_name\0\u{3}with_vectors\0\u{3}group_by\0\u{3}group_size\0\u{3}read_consistency\0\u{3}with_lookup\0\u{1}timeout\0\u{3}shard_key_selector\0\u{3}sparse_indices\0")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _vector: [Float] = []
    var _filter: Qdrant_Filter? = nil
    var _limit: UInt32 = 0
    var _withPayload: Qdrant_WithPayloadSelector? = nil
    var _params: Qdrant_SearchParams? = nil
    var _scoreThreshold: Float? = nil
    var _vectorName: String? = nil
    var _withVectors: Qdrant_WithVectorsSelector? = nil
    var _groupBy: String = String()
    var _groupSize: UInt32 = 0
    var _readConsistency: Qdrant_ReadConsistency? = nil
    var _withLookup: Qdrant_WithLookup? = nil
    var _timeout: UInt64? = nil
    var _shardKeySelector: Qdrant_ShardKeySelector? = nil
    var _sparseIndices: Qdrant_SparseIndices? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _vector = source._vector
      _filter = source._filter
      _limit = source._limit
      _withPayload = source._withPayload
      _params = source._params
      _scoreThreshold = source._scoreThreshold
      _vectorName = source._vectorName
      _withVectors = source._withVectors
      _groupBy = source._groupBy
      _groupSize = source._groupSize
      _readConsistency = source._readConsistency
      _withLookup = source._withLookup
      _timeout = source._timeout
      _shardKeySelector = source._shardKeySelector
      _sparseIndices = source._sparseIndices
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeRepeatedFloatField(value: &_storage._vector) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._limit) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._withPayload) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._scoreThreshold) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._vectorName) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._withVectors) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._groupBy) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._groupSize) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._readConsistency) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._withLookup) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._shardKeySelector) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._sparseIndices) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      if !_storage._vector.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._vector, fieldNumber: 2)
      }
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._limit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._limit, fieldNumber: 4)
      }
      try { if let v = _storage._withPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._scoreThreshold {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._vectorName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._withVectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._groupBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupBy, fieldNumber: 10)
      }
      if _storage._groupSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._groupSize, fieldNumber: 11)
      }
      try { if let v = _storage._readConsistency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._withLookup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._shardKeySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._sparseIndices {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchPointGroups, rhs: Qdrant_SearchPointGroups) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._vector != rhs_storage._vector {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._withPayload != rhs_storage._withPayload {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._scoreThreshold != rhs_storage._scoreThreshold {return false}
        if _storage._vectorName != rhs_storage._vectorName {return false}
        if _storage._withVectors != rhs_storage._withVectors {return false}
        if _storage._groupBy != rhs_storage._groupBy {return false}
        if _storage._groupSize != rhs_storage._groupSize {return false}
        if _storage._readConsistency != rhs_storage._readConsistency {return false}
        if _storage._withLookup != rhs_storage._withLookup {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._shardKeySelector != rhs_storage._shardKeySelector {return false}
        if _storage._sparseIndices != rhs_storage._sparseIndices {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_StartFrom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartFrom"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}float\0\u{1}integer\0\u{1}timestamp\0\u{1}datetime\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .float(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .integer(v)
        }
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .timestamp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .timestamp(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .datetime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .float?: try {
      guard case .float(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }()
    case .integer?: try {
      guard case .integer(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .timestamp?: try {
      guard case .timestamp(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .datetime?: try {
      guard case .datetime(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_StartFrom, rhs: Qdrant_StartFrom) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_OrderBy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderBy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}direction\0\u{3}start_from\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startFrom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._startFrom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_OrderBy, rhs: Qdrant_OrderBy) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._startFrom != rhs._startFrom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ScrollPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScrollPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}filter\0\u{1}offset\0\u{1}limit\0\u{4}\u{2}with_payload\0\u{3}with_vectors\0\u{3}read_consistency\0\u{3}shard_key_selector\0\u{3}order_by\0\u{1}timeout\0\u{c}\u{5}\u{1}")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _filter: Qdrant_Filter? = nil
    var _offset: Qdrant_PointId? = nil
    var _limit: UInt32? = nil
    var _withPayload: Qdrant_WithPayloadSelector? = nil
    var _withVectors: Qdrant_WithVectorsSelector? = nil
    var _readConsistency: Qdrant_ReadConsistency? = nil
    var _shardKeySelector: Qdrant_ShardKeySelector? = nil
    var _orderBy: Qdrant_OrderBy? = nil
    var _timeout: UInt64? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _filter = source._filter
      _offset = source._offset
      _limit = source._limit
      _withPayload = source._withPayload
      _withVectors = source._withVectors
      _readConsistency = source._readConsistency
      _shardKeySelector = source._shardKeySelector
      _orderBy = source._orderBy
      _timeout = source._timeout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._offset) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._limit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._withPayload) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._withVectors) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._readConsistency) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._shardKeySelector) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._orderBy) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._offset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._limit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._withPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._withVectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._readConsistency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._shardKeySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._orderBy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ScrollPoints, rhs: Qdrant_ScrollPoints) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._withPayload != rhs_storage._withPayload {return false}
        if _storage._withVectors != rhs_storage._withVectors {return false}
        if _storage._readConsistency != rhs_storage._readConsistency {return false}
        if _storage._shardKeySelector != rhs_storage._shardKeySelector {return false}
        if _storage._orderBy != rhs_storage._orderBy {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_LookupLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookupLocation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{3}vector_name\0\u{3}shard_key_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._vectorName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._vectorName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_LookupLocation, rhs: Qdrant_LookupLocation) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._vectorName != rhs._vectorName {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RecommendPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}positive\0\u{1}negative\0\u{1}filter\0\u{1}limit\0\u{4}\u{2}with_payload\0\u{1}params\0\u{3}score_threshold\0\u{1}offset\0\u{1}using\0\u{3}with_vectors\0\u{3}lookup_from\0\u{3}read_consistency\0\u{2}\u{2}strategy\0\u{3}positive_vectors\0\u{3}negative_vectors\0\u{1}timeout\0\u{3}shard_key_selector\0\u{c}\u{6}\u{1}")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _positive: [Qdrant_PointId] = []
    var _negative: [Qdrant_PointId] = []
    var _filter: Qdrant_Filter? = nil
    var _limit: UInt64 = 0
    var _withPayload: Qdrant_WithPayloadSelector? = nil
    var _params: Qdrant_SearchParams? = nil
    var _scoreThreshold: Float? = nil
    var _offset: UInt64? = nil
    var _using: String? = nil
    var _withVectors: Qdrant_WithVectorsSelector? = nil
    var _lookupFrom: Qdrant_LookupLocation? = nil
    var _readConsistency: Qdrant_ReadConsistency? = nil
    var _strategy: Qdrant_RecommendStrategy? = nil
    var _positiveVectors: [Qdrant_Vector] = []
    var _negativeVectors: [Qdrant_Vector] = []
    var _timeout: UInt64? = nil
    var _shardKeySelector: Qdrant_ShardKeySelector? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _positive = source._positive
      _negative = source._negative
      _filter = source._filter
      _limit = source._limit
      _withPayload = source._withPayload
      _params = source._params
      _scoreThreshold = source._scoreThreshold
      _offset = source._offset
      _using = source._using
      _withVectors = source._withVectors
      _lookupFrom = source._lookupFrom
      _readConsistency = source._readConsistency
      _strategy = source._strategy
      _positiveVectors = source._positiveVectors
      _negativeVectors = source._negativeVectors
      _timeout = source._timeout
      _shardKeySelector = source._shardKeySelector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._positive) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._negative) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._limit) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._withPayload) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._scoreThreshold) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._offset) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._using) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._withVectors) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lookupFrom) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._readConsistency) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._strategy) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._positiveVectors) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._negativeVectors) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._shardKeySelector) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      if !_storage._positive.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positive, fieldNumber: 2)
      }
      if !_storage._negative.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._negative, fieldNumber: 3)
      }
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._limit != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._limit, fieldNumber: 5)
      }
      try { if let v = _storage._withPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._scoreThreshold {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._offset {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._using {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._withVectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lookupFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._readConsistency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._strategy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 16)
      } }()
      if !_storage._positiveVectors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positiveVectors, fieldNumber: 17)
      }
      if !_storage._negativeVectors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._negativeVectors, fieldNumber: 18)
      }
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._shardKeySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RecommendPoints, rhs: Qdrant_RecommendPoints) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._positive != rhs_storage._positive {return false}
        if _storage._negative != rhs_storage._negative {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._withPayload != rhs_storage._withPayload {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._scoreThreshold != rhs_storage._scoreThreshold {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._using != rhs_storage._using {return false}
        if _storage._withVectors != rhs_storage._withVectors {return false}
        if _storage._lookupFrom != rhs_storage._lookupFrom {return false}
        if _storage._readConsistency != rhs_storage._readConsistency {return false}
        if _storage._strategy != rhs_storage._strategy {return false}
        if _storage._positiveVectors != rhs_storage._positiveVectors {return false}
        if _storage._negativeVectors != rhs_storage._negativeVectors {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._shardKeySelector != rhs_storage._shardKeySelector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RecommendBatchPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendBatchPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{3}recommend_points\0\u{3}read_consistency\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.recommendPoints) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readConsistency) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    if !self.recommendPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recommendPoints, fieldNumber: 2)
    }
    try { if let v = self._readConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RecommendBatchPoints, rhs: Qdrant_RecommendBatchPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.recommendPoints != rhs.recommendPoints {return false}
    if lhs._readConsistency != rhs._readConsistency {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RecommendPointGroups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendPointGroups"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}positive\0\u{1}negative\0\u{1}filter\0\u{1}limit\0\u{3}with_payload\0\u{1}params\0\u{3}score_threshold\0\u{1}using\0\u{3}with_vectors\0\u{3}lookup_from\0\u{3}group_by\0\u{3}group_size\0\u{3}read_consistency\0\u{3}with_lookup\0\u{2}\u{2}strategy\0\u{3}positive_vectors\0\u{3}negative_vectors\0\u{1}timeout\0\u{3}shard_key_selector\0")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _positive: [Qdrant_PointId] = []
    var _negative: [Qdrant_PointId] = []
    var _filter: Qdrant_Filter? = nil
    var _limit: UInt32 = 0
    var _withPayload: Qdrant_WithPayloadSelector? = nil
    var _params: Qdrant_SearchParams? = nil
    var _scoreThreshold: Float? = nil
    var _using: String? = nil
    var _withVectors: Qdrant_WithVectorsSelector? = nil
    var _lookupFrom: Qdrant_LookupLocation? = nil
    var _groupBy: String = String()
    var _groupSize: UInt32 = 0
    var _readConsistency: Qdrant_ReadConsistency? = nil
    var _withLookup: Qdrant_WithLookup? = nil
    var _strategy: Qdrant_RecommendStrategy? = nil
    var _positiveVectors: [Qdrant_Vector] = []
    var _negativeVectors: [Qdrant_Vector] = []
    var _timeout: UInt64? = nil
    var _shardKeySelector: Qdrant_ShardKeySelector? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _positive = source._positive
      _negative = source._negative
      _filter = source._filter
      _limit = source._limit
      _withPayload = source._withPayload
      _params = source._params
      _scoreThreshold = source._scoreThreshold
      _using = source._using
      _withVectors = source._withVectors
      _lookupFrom = source._lookupFrom
      _groupBy = source._groupBy
      _groupSize = source._groupSize
      _readConsistency = source._readConsistency
      _withLookup = source._withLookup
      _strategy = source._strategy
      _positiveVectors = source._positiveVectors
      _negativeVectors = source._negativeVectors
      _timeout = source._timeout
      _shardKeySelector = source._shardKeySelector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._positive) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._negative) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._limit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._withPayload) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._scoreThreshold) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._using) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._withVectors) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lookupFrom) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._groupBy) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._groupSize) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._readConsistency) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._withLookup) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._strategy) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._positiveVectors) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._negativeVectors) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._shardKeySelector) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      if !_storage._positive.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positive, fieldNumber: 2)
      }
      if !_storage._negative.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._negative, fieldNumber: 3)
      }
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._limit != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._limit, fieldNumber: 5)
      }
      try { if let v = _storage._withPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._scoreThreshold {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._using {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._withVectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._lookupFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._groupBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupBy, fieldNumber: 12)
      }
      if _storage._groupSize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._groupSize, fieldNumber: 13)
      }
      try { if let v = _storage._readConsistency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._withLookup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._strategy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 17)
      } }()
      if !_storage._positiveVectors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._positiveVectors, fieldNumber: 18)
      }
      if !_storage._negativeVectors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._negativeVectors, fieldNumber: 19)
      }
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._shardKeySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RecommendPointGroups, rhs: Qdrant_RecommendPointGroups) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._positive != rhs_storage._positive {return false}
        if _storage._negative != rhs_storage._negative {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._withPayload != rhs_storage._withPayload {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._scoreThreshold != rhs_storage._scoreThreshold {return false}
        if _storage._using != rhs_storage._using {return false}
        if _storage._withVectors != rhs_storage._withVectors {return false}
        if _storage._lookupFrom != rhs_storage._lookupFrom {return false}
        if _storage._groupBy != rhs_storage._groupBy {return false}
        if _storage._groupSize != rhs_storage._groupSize {return false}
        if _storage._readConsistency != rhs_storage._readConsistency {return false}
        if _storage._withLookup != rhs_storage._withLookup {return false}
        if _storage._strategy != rhs_storage._strategy {return false}
        if _storage._positiveVectors != rhs_storage._positiveVectors {return false}
        if _storage._negativeVectors != rhs_storage._negativeVectors {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._shardKeySelector != rhs_storage._shardKeySelector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_TargetVector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetVector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}single\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_VectorExample?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .single(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .single(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .single(let v)? = self.target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_TargetVector, rhs: Qdrant_TargetVector) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_VectorExample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorExample"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}vector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_PointId?
        var hadOneofValue = false
        if let current = self.example {
          hadOneofValue = true
          if case .id(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.example = .id(v)
        }
      }()
      case 2: try {
        var v: Qdrant_Vector?
        var hadOneofValue = false
        if let current = self.example {
          hadOneofValue = true
          if case .vector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.example = .vector(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.example {
    case .id?: try {
      guard case .id(let v)? = self.example else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .vector?: try {
      guard case .vector(let v)? = self.example else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_VectorExample, rhs: Qdrant_VectorExample) -> Bool {
    if lhs.example != rhs.example {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ContextExamplePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContextExamplePair"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}positive\0\u{1}negative\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positive) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._negative) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._positive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._negative {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ContextExamplePair, rhs: Qdrant_ContextExamplePair) -> Bool {
    if lhs._positive != rhs._positive {return false}
    if lhs._negative != rhs._negative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DiscoverPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}target\0\u{1}context\0\u{1}filter\0\u{1}limit\0\u{3}with_payload\0\u{1}params\0\u{1}offset\0\u{1}using\0\u{3}with_vectors\0\u{3}lookup_from\0\u{3}read_consistency\0\u{1}timeout\0\u{3}shard_key_selector\0")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _target: Qdrant_TargetVector? = nil
    var _context: [Qdrant_ContextExamplePair] = []
    var _filter: Qdrant_Filter? = nil
    var _limit: UInt64 = 0
    var _withPayload: Qdrant_WithPayloadSelector? = nil
    var _params: Qdrant_SearchParams? = nil
    var _offset: UInt64? = nil
    var _using: String? = nil
    var _withVectors: Qdrant_WithVectorsSelector? = nil
    var _lookupFrom: Qdrant_LookupLocation? = nil
    var _readConsistency: Qdrant_ReadConsistency? = nil
    var _timeout: UInt64? = nil
    var _shardKeySelector: Qdrant_ShardKeySelector? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _target = source._target
      _context = source._context
      _filter = source._filter
      _limit = source._limit
      _withPayload = source._withPayload
      _params = source._params
      _offset = source._offset
      _using = source._using
      _withVectors = source._withVectors
      _lookupFrom = source._lookupFrom
      _readConsistency = source._readConsistency
      _timeout = source._timeout
      _shardKeySelector = source._shardKeySelector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._target) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._context) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._limit) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._withPayload) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._offset) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._using) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._withVectors) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lookupFrom) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._readConsistency) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._shardKeySelector) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      try { if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._context.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._context, fieldNumber: 3)
      }
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._limit != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._limit, fieldNumber: 5)
      }
      try { if let v = _storage._withPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._offset {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._using {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._withVectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._lookupFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._readConsistency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._shardKeySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DiscoverPoints, rhs: Qdrant_DiscoverPoints) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._withPayload != rhs_storage._withPayload {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._using != rhs_storage._using {return false}
        if _storage._withVectors != rhs_storage._withVectors {return false}
        if _storage._lookupFrom != rhs_storage._lookupFrom {return false}
        if _storage._readConsistency != rhs_storage._readConsistency {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._shardKeySelector != rhs_storage._shardKeySelector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DiscoverBatchPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverBatchPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{3}discover_points\0\u{3}read_consistency\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.discoverPoints) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readConsistency) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    if !self.discoverPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.discoverPoints, fieldNumber: 2)
    }
    try { if let v = self._readConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DiscoverBatchPoints, rhs: Qdrant_DiscoverBatchPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.discoverPoints != rhs.discoverPoints {return false}
    if lhs._readConsistency != rhs._readConsistency {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CountPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}filter\0\u{1}exact\0\u{3}read_consistency\0\u{3}shard_key_selector\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._exact) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._readConsistency) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._exact {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._readConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CountPoints, rhs: Qdrant_CountPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs._exact != rhs._exact {return false}
    if lhs._readConsistency != rhs._readConsistency {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RecommendInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}positive\0\u{1}negative\0\u{1}strategy\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.positive) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.negative) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._strategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.positive.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.positive, fieldNumber: 1)
    }
    if !self.negative.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.negative, fieldNumber: 2)
    }
    try { if let v = self._strategy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RecommendInput, rhs: Qdrant_RecommendInput) -> Bool {
    if lhs.positive != rhs.positive {return false}
    if lhs.negative != rhs.negative {return false}
    if lhs._strategy != rhs._strategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ContextInputPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContextInputPair"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}positive\0\u{1}negative\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._positive) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._negative) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._positive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._negative {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ContextInputPair, rhs: Qdrant_ContextInputPair) -> Bool {
    if lhs._positive != rhs._positive {return false}
    if lhs._negative != rhs._negative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DiscoverInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}target\0\u{1}context\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._context {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DiscoverInput, rhs: Qdrant_DiscoverInput) -> Bool {
    if lhs._target != rhs._target {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ContextInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContextInput"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pairs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pairs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pairs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ContextInput, rhs: Qdrant_ContextInput) -> Bool {
    if lhs.pairs != rhs.pairs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Formula: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Formula"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}expression\0\u{1}defaults\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._expression) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.defaults) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._expression {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.defaults.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.defaults, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Formula, rhs: Qdrant_Formula) -> Bool {
    if lhs._expression != rhs._expression {return false}
    if lhs.defaults != rhs.defaults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Expression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Expression"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}constant\0\u{1}variable\0\u{1}condition\0\u{3}geo_distance\0\u{1}datetime\0\u{3}datetime_key\0\u{1}mult\0\u{1}sum\0\u{1}div\0\u{1}neg\0\u{1}abs\0\u{1}sqrt\0\u{1}pow\0\u{1}exp\0\u{1}log10\0\u{1}ln\0\u{3}exp_decay\0\u{3}gauss_decay\0\u{3}lin_decay\0")

  fileprivate class _StorageClass {
    var _variant: Qdrant_Expression.OneOf_Variant?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _variant = source._variant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {
            if _storage._variant != nil {try decoder.handleConflictingOneOf()}
            _storage._variant = .constant(v)
          }
        }()
        case 2: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._variant != nil {try decoder.handleConflictingOneOf()}
            _storage._variant = .variable(v)
          }
        }()
        case 3: try {
          var v: Qdrant_Condition?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .condition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .condition(v)
          }
        }()
        case 4: try {
          var v: Qdrant_GeoDistance?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .geoDistance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .geoDistance(v)
          }
        }()
        case 5: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._variant != nil {try decoder.handleConflictingOneOf()}
            _storage._variant = .datetime(v)
          }
        }()
        case 6: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._variant != nil {try decoder.handleConflictingOneOf()}
            _storage._variant = .datetimeKey(v)
          }
        }()
        case 7: try {
          var v: Qdrant_MultExpression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .mult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .mult(v)
          }
        }()
        case 8: try {
          var v: Qdrant_SumExpression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .sum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .sum(v)
          }
        }()
        case 9: try {
          var v: Qdrant_DivExpression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .div(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .div(v)
          }
        }()
        case 10: try {
          var v: Qdrant_Expression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .neg(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .neg(v)
          }
        }()
        case 11: try {
          var v: Qdrant_Expression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .abs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .abs(v)
          }
        }()
        case 12: try {
          var v: Qdrant_Expression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .sqrt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .sqrt(v)
          }
        }()
        case 13: try {
          var v: Qdrant_PowExpression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .pow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .pow(v)
          }
        }()
        case 14: try {
          var v: Qdrant_Expression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .exp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .exp(v)
          }
        }()
        case 15: try {
          var v: Qdrant_Expression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .log10(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .log10(v)
          }
        }()
        case 16: try {
          var v: Qdrant_Expression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .ln(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .ln(v)
          }
        }()
        case 17: try {
          var v: Qdrant_DecayParamsExpression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .expDecay(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .expDecay(v)
          }
        }()
        case 18: try {
          var v: Qdrant_DecayParamsExpression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .gaussDecay(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .gaussDecay(v)
          }
        }()
        case 19: try {
          var v: Qdrant_DecayParamsExpression?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .linDecay(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .linDecay(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._variant {
      case .constant?: try {
        guard case .constant(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      }()
      case .variable?: try {
        guard case .variable(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }()
      case .condition?: try {
        guard case .condition(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .geoDistance?: try {
        guard case .geoDistance(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .datetime?: try {
        guard case .datetime(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }()
      case .datetimeKey?: try {
        guard case .datetimeKey(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }()
      case .mult?: try {
        guard case .mult(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .sum?: try {
        guard case .sum(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .div?: try {
        guard case .div(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .neg?: try {
        guard case .neg(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .abs?: try {
        guard case .abs(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .sqrt?: try {
        guard case .sqrt(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .pow?: try {
        guard case .pow(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .exp?: try {
        guard case .exp(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .log10?: try {
        guard case .log10(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .ln?: try {
        guard case .ln(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .expDecay?: try {
        guard case .expDecay(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .gaussDecay?: try {
        guard case .gaussDecay(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .linDecay?: try {
        guard case .linDecay(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Expression, rhs: Qdrant_Expression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._variant != rhs_storage._variant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GeoDistance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoDistance"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}origin\0\u{1}to\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.to.isEmpty {
      try visitor.visitSingularStringField(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GeoDistance, rhs: Qdrant_GeoDistance) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_MultExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultExpression"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mult\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mult.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mult, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_MultExpression, rhs: Qdrant_MultExpression) -> Bool {
    if lhs.mult != rhs.mult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SumExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SumExpression"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sum\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sum.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SumExpression, rhs: Qdrant_SumExpression) -> Bool {
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DivExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DivExpression"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}left\0\u{1}right\0\u{3}by_zero_default\0")

  fileprivate class _StorageClass {
    var _left: Qdrant_Expression? = nil
    var _right: Qdrant_Expression? = nil
    var _byZeroDefault: Float? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _left = source._left
      _right = source._right
      _byZeroDefault = source._byZeroDefault
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._left) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._right) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._byZeroDefault) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._left {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._right {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._byZeroDefault {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DivExpression, rhs: Qdrant_DivExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._left != rhs_storage._left {return false}
        if _storage._right != rhs_storage._right {return false}
        if _storage._byZeroDefault != rhs_storage._byZeroDefault {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PowExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PowExpression"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}base\0\u{1}exponent\0")

  fileprivate class _StorageClass {
    var _base: Qdrant_Expression? = nil
    var _exponent: Qdrant_Expression? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _base = source._base
      _exponent = source._exponent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._base) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._exponent) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._base {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._exponent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PowExpression, rhs: Qdrant_PowExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._base != rhs_storage._base {return false}
        if _storage._exponent != rhs_storage._exponent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DecayParamsExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecayParamsExpression"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}target\0\u{1}scale\0\u{1}midpoint\0")

  fileprivate class _StorageClass {
    var _x: Qdrant_Expression? = nil
    var _target: Qdrant_Expression? = nil
    var _scale: Float? = nil
    var _midpoint: Float? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _x = source._x
      _target = source._target
      _scale = source._scale
      _midpoint = source._midpoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._x) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._target) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._scale) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._midpoint) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._x {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._scale {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._midpoint {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DecayParamsExpression, rhs: Qdrant_DecayParamsExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._x != rhs_storage._x {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._scale != rhs_storage._scale {return false}
        if _storage._midpoint != rhs_storage._midpoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_NearestInputWithMmr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NearestInputWithMmr"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nearest\0\u{1}mmr\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nearest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mmr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nearest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mmr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_NearestInputWithMmr, rhs: Qdrant_NearestInputWithMmr) -> Bool {
    if lhs._nearest != rhs._nearest {return false}
    if lhs._mmr != rhs._mmr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Mmr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mmr"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}diversity\0\u{3}candidates_limit\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self._diversity) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._candidatesLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._diversity {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._candidatesLimit {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Mmr, rhs: Qdrant_Mmr) -> Bool {
    if lhs._diversity != rhs._diversity {return false}
    if lhs._candidatesLimit != rhs._candidatesLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Rrf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rrf"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}k\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._k) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._k {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Rrf, rhs: Qdrant_Rrf) -> Bool {
    if lhs._k != rhs._k {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Query"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nearest\0\u{1}recommend\0\u{1}discover\0\u{1}context\0\u{3}order_by\0\u{1}fusion\0\u{1}sample\0\u{1}formula\0\u{3}nearest_with_mmr\0\u{1}rrf\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_VectorInput?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .nearest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .nearest(v)
        }
      }()
      case 2: try {
        var v: Qdrant_RecommendInput?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .recommend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .recommend(v)
        }
      }()
      case 3: try {
        var v: Qdrant_DiscoverInput?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .discover(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .discover(v)
        }
      }()
      case 4: try {
        var v: Qdrant_ContextInput?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .context(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .context(v)
        }
      }()
      case 5: try {
        var v: Qdrant_OrderBy?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .orderBy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .orderBy(v)
        }
      }()
      case 6: try {
        var v: Qdrant_Fusion?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .fusion(v)
        }
      }()
      case 7: try {
        var v: Qdrant_Sample?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .sample(v)
        }
      }()
      case 8: try {
        var v: Qdrant_Formula?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .formula(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .formula(v)
        }
      }()
      case 9: try {
        var v: Qdrant_NearestInputWithMmr?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .nearestWithMmr(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .nearestWithMmr(v)
        }
      }()
      case 10: try {
        var v: Qdrant_Rrf?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .rrf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .rrf(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .nearest?: try {
      guard case .nearest(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .recommend?: try {
      guard case .recommend(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .discover?: try {
      guard case .discover(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .context?: try {
      guard case .context(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .orderBy?: try {
      guard case .orderBy(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .fusion?: try {
      guard case .fusion(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }()
    case .sample?: try {
      guard case .sample(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }()
    case .formula?: try {
      guard case .formula(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .nearestWithMmr?: try {
      guard case .nearestWithMmr(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .rrf?: try {
      guard case .rrf(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Query, rhs: Qdrant_Query) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PrefetchQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrefetchQuery"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}prefetch\0\u{1}query\0\u{1}using\0\u{1}filter\0\u{1}params\0\u{3}score_threshold\0\u{1}limit\0\u{3}lookup_from\0")

  fileprivate class _StorageClass {
    var _prefetch: [Qdrant_PrefetchQuery] = []
    var _query: Qdrant_Query? = nil
    var _using: String? = nil
    var _filter: Qdrant_Filter? = nil
    var _params: Qdrant_SearchParams? = nil
    var _scoreThreshold: Float? = nil
    var _limit: UInt64? = nil
    var _lookupFrom: Qdrant_LookupLocation? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _prefetch = source._prefetch
      _query = source._query
      _using = source._using
      _filter = source._filter
      _params = source._params
      _scoreThreshold = source._scoreThreshold
      _limit = source._limit
      _lookupFrom = source._lookupFrom
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._prefetch) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._using) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._scoreThreshold) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._limit) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lookupFrom) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._prefetch.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._prefetch, fieldNumber: 1)
      }
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._using {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._scoreThreshold {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._limit {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lookupFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PrefetchQuery, rhs: Qdrant_PrefetchQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._prefetch != rhs_storage._prefetch {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._using != rhs_storage._using {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._scoreThreshold != rhs_storage._scoreThreshold {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._lookupFrom != rhs_storage._lookupFrom {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QueryPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}prefetch\0\u{1}query\0\u{1}using\0\u{1}filter\0\u{1}params\0\u{3}score_threshold\0\u{1}limit\0\u{1}offset\0\u{3}with_vectors\0\u{3}with_payload\0\u{3}read_consistency\0\u{3}shard_key_selector\0\u{3}lookup_from\0\u{1}timeout\0")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _prefetch: [Qdrant_PrefetchQuery] = []
    var _query: Qdrant_Query? = nil
    var _using: String? = nil
    var _filter: Qdrant_Filter? = nil
    var _params: Qdrant_SearchParams? = nil
    var _scoreThreshold: Float? = nil
    var _limit: UInt64? = nil
    var _offset: UInt64? = nil
    var _withVectors: Qdrant_WithVectorsSelector? = nil
    var _withPayload: Qdrant_WithPayloadSelector? = nil
    var _readConsistency: Qdrant_ReadConsistency? = nil
    var _shardKeySelector: Qdrant_ShardKeySelector? = nil
    var _lookupFrom: Qdrant_LookupLocation? = nil
    var _timeout: UInt64? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _prefetch = source._prefetch
      _query = source._query
      _using = source._using
      _filter = source._filter
      _params = source._params
      _scoreThreshold = source._scoreThreshold
      _limit = source._limit
      _offset = source._offset
      _withVectors = source._withVectors
      _withPayload = source._withPayload
      _readConsistency = source._readConsistency
      _shardKeySelector = source._shardKeySelector
      _lookupFrom = source._lookupFrom
      _timeout = source._timeout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._prefetch) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._using) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._scoreThreshold) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._limit) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._offset) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._withVectors) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._withPayload) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._readConsistency) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._shardKeySelector) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._lookupFrom) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      if !_storage._prefetch.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._prefetch, fieldNumber: 2)
      }
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._using {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._scoreThreshold {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._limit {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._offset {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._withVectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._withPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._readConsistency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._shardKeySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._lookupFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QueryPoints, rhs: Qdrant_QueryPoints) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._prefetch != rhs_storage._prefetch {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._using != rhs_storage._using {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._scoreThreshold != rhs_storage._scoreThreshold {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._withVectors != rhs_storage._withVectors {return false}
        if _storage._withPayload != rhs_storage._withPayload {return false}
        if _storage._readConsistency != rhs_storage._readConsistency {return false}
        if _storage._shardKeySelector != rhs_storage._shardKeySelector {return false}
        if _storage._lookupFrom != rhs_storage._lookupFrom {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QueryBatchPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryBatchPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{3}query_points\0\u{3}read_consistency\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.queryPoints) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readConsistency) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    if !self.queryPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queryPoints, fieldNumber: 2)
    }
    try { if let v = self._readConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QueryBatchPoints, rhs: Qdrant_QueryBatchPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.queryPoints != rhs.queryPoints {return false}
    if lhs._readConsistency != rhs._readConsistency {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QueryPointGroups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryPointGroups"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}prefetch\0\u{1}query\0\u{1}using\0\u{1}filter\0\u{1}params\0\u{3}score_threshold\0\u{3}with_payload\0\u{3}with_vectors\0\u{3}lookup_from\0\u{1}limit\0\u{3}group_size\0\u{3}group_by\0\u{3}read_consistency\0\u{3}with_lookup\0\u{1}timeout\0\u{3}shard_key_selector\0")

  fileprivate class _StorageClass {
    var _collectionName: String = String()
    var _prefetch: [Qdrant_PrefetchQuery] = []
    var _query: Qdrant_Query? = nil
    var _using: String? = nil
    var _filter: Qdrant_Filter? = nil
    var _params: Qdrant_SearchParams? = nil
    var _scoreThreshold: Float? = nil
    var _withPayload: Qdrant_WithPayloadSelector? = nil
    var _withVectors: Qdrant_WithVectorsSelector? = nil
    var _lookupFrom: Qdrant_LookupLocation? = nil
    var _limit: UInt64? = nil
    var _groupSize: UInt64? = nil
    var _groupBy: String = String()
    var _readConsistency: Qdrant_ReadConsistency? = nil
    var _withLookup: Qdrant_WithLookup? = nil
    var _timeout: UInt64? = nil
    var _shardKeySelector: Qdrant_ShardKeySelector? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _collectionName = source._collectionName
      _prefetch = source._prefetch
      _query = source._query
      _using = source._using
      _filter = source._filter
      _params = source._params
      _scoreThreshold = source._scoreThreshold
      _withPayload = source._withPayload
      _withVectors = source._withVectors
      _lookupFrom = source._lookupFrom
      _limit = source._limit
      _groupSize = source._groupSize
      _groupBy = source._groupBy
      _readConsistency = source._readConsistency
      _withLookup = source._withLookup
      _timeout = source._timeout
      _shardKeySelector = source._shardKeySelector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._collectionName) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._prefetch) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._using) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._filter) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._scoreThreshold) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._withPayload) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._withVectors) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lookupFrom) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._limit) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._groupSize) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._groupBy) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._readConsistency) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._withLookup) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._timeout) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._shardKeySelector) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._collectionName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._collectionName, fieldNumber: 1)
      }
      if !_storage._prefetch.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._prefetch, fieldNumber: 2)
      }
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._using {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._filter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._scoreThreshold {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._withPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._withVectors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lookupFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._limit {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._groupSize {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
      } }()
      if !_storage._groupBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupBy, fieldNumber: 13)
      }
      try { if let v = _storage._readConsistency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._withLookup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._timeout {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._shardKeySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QueryPointGroups, rhs: Qdrant_QueryPointGroups) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._collectionName != rhs_storage._collectionName {return false}
        if _storage._prefetch != rhs_storage._prefetch {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._using != rhs_storage._using {return false}
        if _storage._filter != rhs_storage._filter {return false}
        if _storage._params != rhs_storage._params {return false}
        if _storage._scoreThreshold != rhs_storage._scoreThreshold {return false}
        if _storage._withPayload != rhs_storage._withPayload {return false}
        if _storage._withVectors != rhs_storage._withVectors {return false}
        if _storage._lookupFrom != rhs_storage._lookupFrom {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._groupSize != rhs_storage._groupSize {return false}
        if _storage._groupBy != rhs_storage._groupBy {return false}
        if _storage._readConsistency != rhs_storage._readConsistency {return false}
        if _storage._withLookup != rhs_storage._withLookup {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._shardKeySelector != rhs_storage._shardKeySelector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_FacetCounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FacetCounts"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}key\0\u{1}filter\0\u{1}limit\0\u{1}exact\0\u{1}timeout\0\u{3}read_consistency\0\u{3}shard_key_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._limit) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._exact) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._readConsistency) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._exact {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._readConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_FacetCounts, rhs: Qdrant_FacetCounts) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.key != rhs.key {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._exact != rhs._exact {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._readConsistency != rhs._readConsistency {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_FacetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FacetValue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}string_value\0\u{3}integer_value\0\u{3}bool_value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .stringValue(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .integerValue(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .boolValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .integerValue?: try {
      guard case .integerValue(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_FacetValue, rhs: Qdrant_FacetValue) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_FacetHit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FacetHit"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_FacetHit, rhs: Qdrant_FacetHit) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchMatrixPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchMatrixPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}filter\0\u{1}sample\0\u{1}limit\0\u{1}using\0\u{1}timeout\0\u{3}read_consistency\0\u{3}shard_key_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._sample) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._limit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._using) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._readConsistency) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sample {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._limit {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._using {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._readConsistency {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchMatrixPoints, rhs: Qdrant_SearchMatrixPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs._sample != rhs._sample {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._using != rhs._using {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._readConsistency != rhs._readConsistency {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchMatrixPairs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchMatrixPairs"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pairs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pairs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pairs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchMatrixPairs, rhs: Qdrant_SearchMatrixPairs) -> Bool {
    if lhs.pairs != rhs.pairs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchMatrixPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchMatrixPair"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}a\0\u{1}b\0\u{1}score\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._a) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._b) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._a {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._b {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.score.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchMatrixPair, rhs: Qdrant_SearchMatrixPair) -> Bool {
    if lhs._a != rhs._a {return false}
    if lhs._b != rhs._b {return false}
    if lhs.score != rhs.score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchMatrixOffsets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchMatrixOffsets"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}offsets_row\0\u{3}offsets_col\0\u{1}scores\0\u{1}ids\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.offsetsRow) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.offsetsCol) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.scores) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.offsetsRow.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.offsetsRow, fieldNumber: 1)
    }
    if !self.offsetsCol.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.offsetsCol, fieldNumber: 2)
    }
    if !self.scores.isEmpty {
      try visitor.visitPackedFloatField(value: self.scores, fieldNumber: 3)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchMatrixOffsets, rhs: Qdrant_SearchMatrixOffsets) -> Bool {
    if lhs.offsetsRow != rhs.offsetsRow {return false}
    if lhs.offsetsCol != rhs.offsetsCol {return false}
    if lhs.scores != rhs.scores {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointsUpdateOperation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}upsert\0\u{3}delete_deprecated\0\u{3}set_payload\0\u{3}overwrite_payload\0\u{3}delete_payload\0\u{3}clear_payload_deprecated\0\u{3}update_vectors\0\u{3}delete_vectors\0\u{3}delete_points\0\u{3}clear_payload\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_PointsUpdateOperation.PointStructList?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .upsert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .upsert(v)
        }
      }()
      case 2: try {
        var v: Qdrant_PointsSelector?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteDeprecated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteDeprecated(v)
        }
      }()
      case 3: try {
        var v: Qdrant_PointsUpdateOperation.SetPayload?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .setPayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .setPayload(v)
        }
      }()
      case 4: try {
        var v: Qdrant_PointsUpdateOperation.OverwritePayload?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .overwritePayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .overwritePayload(v)
        }
      }()
      case 5: try {
        var v: Qdrant_PointsUpdateOperation.DeletePayload?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deletePayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deletePayload(v)
        }
      }()
      case 6: try {
        var v: Qdrant_PointsSelector?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .clearPayloadDeprecated_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .clearPayloadDeprecated_p(v)
        }
      }()
      case 7: try {
        var v: Qdrant_PointsUpdateOperation.UpdateVectors?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .updateVectors(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .updateVectors(v)
        }
      }()
      case 8: try {
        var v: Qdrant_PointsUpdateOperation.DeleteVectors?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteVectors(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteVectors(v)
        }
      }()
      case 9: try {
        var v: Qdrant_PointsUpdateOperation.DeletePoints?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deletePoints(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deletePoints(v)
        }
      }()
      case 10: try {
        var v: Qdrant_PointsUpdateOperation.ClearPayload?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .clearPayload_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .clearPayload_p(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.operation {
    case .upsert?: try {
      guard case .upsert(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .deleteDeprecated?: try {
      guard case .deleteDeprecated(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .setPayload?: try {
      guard case .setPayload(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .overwritePayload?: try {
      guard case .overwritePayload(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .deletePayload?: try {
      guard case .deletePayload(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .clearPayloadDeprecated_p?: try {
      guard case .clearPayloadDeprecated_p(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .updateVectors?: try {
      guard case .updateVectors(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleteVectors?: try {
      guard case .deleteVectors(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .deletePoints?: try {
      guard case .deletePoints(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .clearPayload_p?: try {
      guard case .clearPayload_p(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation, rhs: Qdrant_PointsUpdateOperation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation.PointStructList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Qdrant_PointsUpdateOperation.protoMessageName + ".PointStructList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}points\0\u{3}shard_key_selector\0\u{3}update_filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation.PointStructList, rhs: Qdrant_PointsUpdateOperation.PointStructList) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._updateFilter != rhs._updateFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation.SetPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Qdrant_PointsUpdateOperation.protoMessageName + ".SetPayload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payload\0\u{3}points_selector\0\u{3}shard_key_selector\0\u{1}key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.payload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointsSelector) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.payload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.payload, fieldNumber: 1)
    }
    try { if let v = self._pointsSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation.SetPayload, rhs: Qdrant_PointsUpdateOperation.SetPayload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs._pointsSelector != rhs._pointsSelector {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation.OverwritePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Qdrant_PointsUpdateOperation.protoMessageName + ".OverwritePayload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payload\0\u{3}points_selector\0\u{3}shard_key_selector\0\u{1}key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.payload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointsSelector) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.payload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.payload, fieldNumber: 1)
    }
    try { if let v = self._pointsSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation.OverwritePayload, rhs: Qdrant_PointsUpdateOperation.OverwritePayload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs._pointsSelector != rhs._pointsSelector {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation.DeletePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Qdrant_PointsUpdateOperation.protoMessageName + ".DeletePayload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}keys\0\u{3}points_selector\0\u{3}shard_key_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.keys) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pointsSelector) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 1)
    }
    try { if let v = self._pointsSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation.DeletePayload, rhs: Qdrant_PointsUpdateOperation.DeletePayload) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs._pointsSelector != rhs._pointsSelector {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation.UpdateVectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Qdrant_PointsUpdateOperation.protoMessageName + ".UpdateVectors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}points\0\u{3}shard_key_selector\0\u{3}update_filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation.UpdateVectors, rhs: Qdrant_PointsUpdateOperation.UpdateVectors) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs._updateFilter != rhs._updateFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation.DeleteVectors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Qdrant_PointsUpdateOperation.protoMessageName + ".DeleteVectors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}points_selector\0\u{1}vectors\0\u{3}shard_key_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pointsSelector) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._vectors) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pointsSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._vectors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation.DeleteVectors, rhs: Qdrant_PointsUpdateOperation.DeleteVectors) -> Bool {
    if lhs._pointsSelector != rhs._pointsSelector {return false}
    if lhs._vectors != rhs._vectors {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation.DeletePoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Qdrant_PointsUpdateOperation.protoMessageName + ".DeletePoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}points\0\u{3}shard_key_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._points) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._points {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation.DeletePoints, rhs: Qdrant_PointsUpdateOperation.DeletePoints) -> Bool {
    if lhs._points != rhs._points {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsUpdateOperation.ClearPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Qdrant_PointsUpdateOperation.protoMessageName + ".ClearPayload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}points\0\u{3}shard_key_selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._points) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shardKeySelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._points {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shardKeySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsUpdateOperation.ClearPayload, rhs: Qdrant_PointsUpdateOperation.ClearPayload) -> Bool {
    if lhs._points != rhs._points {return false}
    if lhs._shardKeySelector != rhs._shardKeySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UpdateBatchPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateBatchPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}collection_name\0\u{1}wait\0\u{1}operations\0\u{1}ordering\0\u{1}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.collectionName) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._wait) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 1)
    }
    try { if let v = self._wait {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 3)
    }
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UpdateBatchPoints, rhs: Qdrant_UpdateBatchPoints) -> Bool {
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs._wait != rhs._wait {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs._ordering != rhs._ordering {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointsOperationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsOperationResponse, rhs: Qdrant_PointsOperationResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UpdateResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateResult"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}operation_id\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._operationID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operationID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if self.status != .unknownUpdateStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UpdateResult, rhs: Qdrant_UpdateResult) -> Bool {
    if lhs._operationID != rhs._operationID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_OrderValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrderValue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}int\0\u{1}float\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .int(v)
        }
      }()
      case 2: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.variant != nil {try decoder.handleConflictingOneOf()}
          self.variant = .float(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .int?: try {
      guard case .int(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .float?: try {
      guard case .float(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_OrderValue, rhs: Qdrant_OrderValue) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ScoredPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScoredPoint"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}payload\0\u{1}score\0\u{2}\u{2}version\0\u{1}vectors\0\u{3}shard_key\0\u{3}order_value\0\u{c}\u{4}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.payload) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._vectors) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._shardKey) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._orderValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.payload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.payload, fieldNumber: 2)
    }
    if self.score.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 5)
    }
    try { if let v = self._vectors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._shardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._orderValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ScoredPoint, rhs: Qdrant_ScoredPoint) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.score != rhs.score {return false}
    if lhs.version != rhs.version {return false}
    if lhs._vectors != rhs._vectors {return false}
    if lhs._shardKey != rhs._shardKey {return false}
    if lhs._orderValue != rhs._orderValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GroupId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}unsigned_value\0\u{3}integer_value\0\u{3}string_value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .unsignedValue(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .integerValue(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .stringValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .unsignedValue?: try {
      guard case .unsignedValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .integerValue?: try {
      guard case .integerValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GroupId, rhs: Qdrant_GroupId) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointGroup"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}hits\0\u{1}lookup\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lookup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 2)
    }
    try { if let v = self._lookup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointGroup, rhs: Qdrant_PointGroup) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.hits != rhs.hits {return false}
    if lhs._lookup != rhs._lookup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GroupsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupsResult"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}groups\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GroupsResult, rhs: Qdrant_GroupsResult) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchResponse, rhs: Qdrant_SearchResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QueryResponse, rhs: Qdrant_QueryResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QueryBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryBatchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QueryBatchResponse, rhs: Qdrant_QueryBatchResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_QueryGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryGroupsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_QueryGroupsResponse, rhs: Qdrant_QueryGroupsResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_BatchResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchResult"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_BatchResult, rhs: Qdrant_BatchResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchBatchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchBatchResponse, rhs: Qdrant_SearchBatchResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchGroupsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchGroupsResponse, rhs: Qdrant_SearchGroupsResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CountResponse, rhs: Qdrant_CountResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ScrollResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScrollResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_page_offset\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nextPageOffset) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nextPageOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 2)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 3)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ScrollResponse, rhs: Qdrant_ScrollResponse) -> Bool {
    if lhs._nextPageOffset != rhs._nextPageOffset {return false}
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_CountResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountResult"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_CountResult, rhs: Qdrant_CountResult) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RetrievedPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetrievedPoint"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}payload\0\u{2}\u{2}vectors\0\u{3}shard_key\0\u{3}order_value\0\u{c}\u{3}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.payload) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._vectors) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._shardKey) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._orderValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.payload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.payload, fieldNumber: 2)
    }
    try { if let v = self._vectors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._shardKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._orderValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RetrievedPoint, rhs: Qdrant_RetrievedPoint) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs._vectors != rhs._vectors {return false}
    if lhs._shardKey != rhs._shardKey {return false}
    if lhs._orderValue != rhs._orderValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GetResponse, rhs: Qdrant_GetResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RecommendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RecommendResponse, rhs: Qdrant_RecommendResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RecommendBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendBatchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RecommendBatchResponse, rhs: Qdrant_RecommendBatchResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DiscoverResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DiscoverResponse, rhs: Qdrant_DiscoverResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DiscoverBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverBatchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DiscoverBatchResponse, rhs: Qdrant_DiscoverBatchResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RecommendGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendGroupsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RecommendGroupsResponse, rhs: Qdrant_RecommendGroupsResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_UpdateBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateBatchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_UpdateBatchResponse, rhs: Qdrant_UpdateBatchResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_FacetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FacetResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hits\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hits) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.hits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hits, fieldNumber: 1)
    }
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_FacetResponse, rhs: Qdrant_FacetResponse) -> Bool {
    if lhs.hits != rhs.hits {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchMatrixPairsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchMatrixPairsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchMatrixPairsResponse, rhs: Qdrant_SearchMatrixPairsResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_SearchMatrixOffsetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchMatrixOffsetsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}time\0\u{1}usage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.time.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.time, fieldNumber: 2)
    }
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_SearchMatrixOffsetsResponse, rhs: Qdrant_SearchMatrixOffsetsResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.time != rhs.time {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointsSelector"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}points\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_PointsIdsList?
        var hadOneofValue = false
        if let current = self.pointsSelectorOneOf {
          hadOneofValue = true
          if case .points(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.pointsSelectorOneOf = .points(v)
        }
      }()
      case 2: try {
        var v: Qdrant_Filter?
        var hadOneofValue = false
        if let current = self.pointsSelectorOneOf {
          hadOneofValue = true
          if case .filter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.pointsSelectorOneOf = .filter(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.pointsSelectorOneOf {
    case .points?: try {
      guard case .points(let v)? = self.pointsSelectorOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .filter?: try {
      guard case .filter(let v)? = self.pointsSelectorOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsSelector, rhs: Qdrant_PointsSelector) -> Bool {
    if lhs.pointsSelectorOneOf != rhs.pointsSelectorOneOf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointsIdsList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointsIdsList"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ids\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointsIdsList, rhs: Qdrant_PointsIdsList) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_PointStruct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointStruct"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{2}\u{2}payload\0\u{1}vectors\0\u{c}\u{2}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: &self.payload) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._vectors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.payload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_Value>.self, value: self.payload, fieldNumber: 3)
    }
    try { if let v = self._vectors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointStruct, rhs: Qdrant_PointStruct) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs._vectors != rhs._vectors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Usage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Usage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}hardware\0\u{1}inference\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hardware) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hardware {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inference {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Usage, rhs: Qdrant_Usage) -> Bool {
    if lhs._hardware != rhs._hardware {return false}
    if lhs._inference != rhs._inference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_InferenceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InferenceUsage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}models\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_ModelUsage>.self, value: &self.models) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.models.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Qdrant_ModelUsage>.self, value: self.models, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_InferenceUsage, rhs: Qdrant_InferenceUsage) -> Bool {
    if lhs.models != rhs.models {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ModelUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelUsage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tokens\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.tokens) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tokens != 0 {
      try visitor.visitSingularUInt64Field(value: self.tokens, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ModelUsage, rhs: Qdrant_ModelUsage) -> Bool {
    if lhs.tokens != rhs.tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_HardwareUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HardwareUsage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cpu\0\u{3}payload_io_read\0\u{3}payload_io_write\0\u{3}payload_index_io_read\0\u{3}payload_index_io_write\0\u{3}vector_io_read\0\u{3}vector_io_write\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.cpu) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.payloadIoRead) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.payloadIoWrite) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.payloadIndexIoRead) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.payloadIndexIoWrite) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.vectorIoRead) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.vectorIoWrite) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpu != 0 {
      try visitor.visitSingularUInt64Field(value: self.cpu, fieldNumber: 1)
    }
    if self.payloadIoRead != 0 {
      try visitor.visitSingularUInt64Field(value: self.payloadIoRead, fieldNumber: 2)
    }
    if self.payloadIoWrite != 0 {
      try visitor.visitSingularUInt64Field(value: self.payloadIoWrite, fieldNumber: 3)
    }
    if self.payloadIndexIoRead != 0 {
      try visitor.visitSingularUInt64Field(value: self.payloadIndexIoRead, fieldNumber: 4)
    }
    if self.payloadIndexIoWrite != 0 {
      try visitor.visitSingularUInt64Field(value: self.payloadIndexIoWrite, fieldNumber: 5)
    }
    if self.vectorIoRead != 0 {
      try visitor.visitSingularUInt64Field(value: self.vectorIoRead, fieldNumber: 6)
    }
    if self.vectorIoWrite != 0 {
      try visitor.visitSingularUInt64Field(value: self.vectorIoWrite, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_HardwareUsage, rhs: Qdrant_HardwareUsage) -> Bool {
    if lhs.cpu != rhs.cpu {return false}
    if lhs.payloadIoRead != rhs.payloadIoRead {return false}
    if lhs.payloadIoWrite != rhs.payloadIoWrite {return false}
    if lhs.payloadIndexIoRead != rhs.payloadIndexIoRead {return false}
    if lhs.payloadIndexIoWrite != rhs.payloadIndexIoWrite {return false}
    if lhs.vectorIoRead != rhs.vectorIoRead {return false}
    if lhs.vectorIoWrite != rhs.vectorIoWrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
