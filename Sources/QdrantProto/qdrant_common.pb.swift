// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: qdrant_common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Qdrant_PointId: Sendable {
  public var pointIDOptions: Qdrant_PointId.OneOf_PointIDOptions? = nil

  /// Numerical ID of the point
  public var num: UInt64 {
    get {
      if case .num(let v)? = pointIDOptions {return v}
      return 0
    }
    set {pointIDOptions = .num(newValue)}
  }

  /// UUID
  public var uuid: String {
    get {
      if case .uuid(let v)? = pointIDOptions {return v}
      return String()
    }
    set {pointIDOptions = .uuid(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PointIDOptions: Equatable, Sendable {
    /// Numerical ID of the point
    case num(UInt64)
    /// UUID
    case uuid(String)

  }

  public init() {}
}

public struct Qdrant_GeoPoint: Sendable {
  public var lon: Double = 0

  public var lat: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_Filter: Sendable {
  /// At least one of those conditions should match
  public var should: [Qdrant_Condition] = []

  /// All conditions must match
  public var must: [Qdrant_Condition] = []

  /// All conditions must NOT match
  public var mustNot: [Qdrant_Condition] = []

  /// At least minimum amount of given conditions should match
  public var minShould: Qdrant_MinShould {
    get {return _minShould ?? Qdrant_MinShould()}
    set {_minShould = newValue}
  }
  public var hasMinShould: Bool {return self._minShould != nil}
  public mutating func clearMinShould() {self._minShould = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _minShould: Qdrant_MinShould? = nil
}

public struct Qdrant_MinShould: Sendable {
  public var conditions: [Qdrant_Condition] = []

  public var minCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_Condition: Sendable {
  public var conditionOneOf: Qdrant_Condition.OneOf_ConditionOneOf? = nil

  public var field: Qdrant_FieldCondition {
    get {
      if case .field(let v)? = conditionOneOf {return v}
      return Qdrant_FieldCondition()
    }
    set {conditionOneOf = .field(newValue)}
  }

  public var isEmpty: Qdrant_IsEmptyCondition {
    get {
      if case .isEmpty(let v)? = conditionOneOf {return v}
      return Qdrant_IsEmptyCondition()
    }
    set {conditionOneOf = .isEmpty(newValue)}
  }

  public var hasID_p: Qdrant_HasIdCondition {
    get {
      if case .hasID_p(let v)? = conditionOneOf {return v}
      return Qdrant_HasIdCondition()
    }
    set {conditionOneOf = .hasID_p(newValue)}
  }

  public var filter: Qdrant_Filter {
    get {
      if case .filter(let v)? = conditionOneOf {return v}
      return Qdrant_Filter()
    }
    set {conditionOneOf = .filter(newValue)}
  }

  public var isNull: Qdrant_IsNullCondition {
    get {
      if case .isNull(let v)? = conditionOneOf {return v}
      return Qdrant_IsNullCondition()
    }
    set {conditionOneOf = .isNull(newValue)}
  }

  public var nested: Qdrant_NestedCondition {
    get {
      if case .nested(let v)? = conditionOneOf {return v}
      return Qdrant_NestedCondition()
    }
    set {conditionOneOf = .nested(newValue)}
  }

  public var hasVector_p: Qdrant_HasVectorCondition {
    get {
      if case .hasVector_p(let v)? = conditionOneOf {return v}
      return Qdrant_HasVectorCondition()
    }
    set {conditionOneOf = .hasVector_p(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ConditionOneOf: Equatable, Sendable {
    case field(Qdrant_FieldCondition)
    case isEmpty(Qdrant_IsEmptyCondition)
    case hasID_p(Qdrant_HasIdCondition)
    case filter(Qdrant_Filter)
    case isNull(Qdrant_IsNullCondition)
    case nested(Qdrant_NestedCondition)
    case hasVector_p(Qdrant_HasVectorCondition)

  }

  public init() {}
}

public struct Qdrant_IsEmptyCondition: Sendable {
  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_IsNullCondition: Sendable {
  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_HasIdCondition: Sendable {
  public var hasID_p: [Qdrant_PointId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_HasVectorCondition: Sendable {
  public var hasVector_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_NestedCondition: Sendable {
  /// Path to nested object
  public var key: String = String()

  /// Filter condition
  public var filter: Qdrant_Filter {
    get {return _filter ?? Qdrant_Filter()}
    set {_filter = newValue}
  }
  public var hasFilter: Bool {return self._filter != nil}
  public mutating func clearFilter() {self._filter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filter: Qdrant_Filter? = nil
}

public struct Qdrant_FieldCondition: @unchecked Sendable {
  public var key: String {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  /// Check if point has field with a given value
  public var match: Qdrant_Match {
    get {return _storage._match ?? Qdrant_Match()}
    set {_uniqueStorage()._match = newValue}
  }
  public var hasMatch: Bool {return _storage._match != nil}
  public mutating func clearMatch() {_uniqueStorage()._match = nil}

  /// Check if points value lies in a given range
  public var range: Qdrant_Range {
    get {return _storage._range ?? Qdrant_Range()}
    set {_uniqueStorage()._range = newValue}
  }
  public var hasRange: Bool {return _storage._range != nil}
  public mutating func clearRange() {_uniqueStorage()._range = nil}

  /// Check if points geolocation lies in a given area
  public var geoBoundingBox: Qdrant_GeoBoundingBox {
    get {return _storage._geoBoundingBox ?? Qdrant_GeoBoundingBox()}
    set {_uniqueStorage()._geoBoundingBox = newValue}
  }
  public var hasGeoBoundingBox: Bool {return _storage._geoBoundingBox != nil}
  public mutating func clearGeoBoundingBox() {_uniqueStorage()._geoBoundingBox = nil}

  /// Check if geo point is within a given radius
  public var geoRadius: Qdrant_GeoRadius {
    get {return _storage._geoRadius ?? Qdrant_GeoRadius()}
    set {_uniqueStorage()._geoRadius = newValue}
  }
  public var hasGeoRadius: Bool {return _storage._geoRadius != nil}
  public mutating func clearGeoRadius() {_uniqueStorage()._geoRadius = nil}

  /// Check number of values for a specific field
  public var valuesCount: Qdrant_ValuesCount {
    get {return _storage._valuesCount ?? Qdrant_ValuesCount()}
    set {_uniqueStorage()._valuesCount = newValue}
  }
  public var hasValuesCount: Bool {return _storage._valuesCount != nil}
  public mutating func clearValuesCount() {_uniqueStorage()._valuesCount = nil}

  /// Check if geo point is within a given polygon
  public var geoPolygon: Qdrant_GeoPolygon {
    get {return _storage._geoPolygon ?? Qdrant_GeoPolygon()}
    set {_uniqueStorage()._geoPolygon = newValue}
  }
  public var hasGeoPolygon: Bool {return _storage._geoPolygon != nil}
  public mutating func clearGeoPolygon() {_uniqueStorage()._geoPolygon = nil}

  /// Check if datetime is within a given range
  public var datetimeRange: Qdrant_DatetimeRange {
    get {return _storage._datetimeRange ?? Qdrant_DatetimeRange()}
    set {_uniqueStorage()._datetimeRange = newValue}
  }
  public var hasDatetimeRange: Bool {return _storage._datetimeRange != nil}
  public mutating func clearDatetimeRange() {_uniqueStorage()._datetimeRange = nil}

  /// Check if field is empty
  public var isEmpty: Bool {
    get {return _storage._isEmpty ?? false}
    set {_uniqueStorage()._isEmpty = newValue}
  }
  public var hasIsEmpty: Bool {return _storage._isEmpty != nil}
  public mutating func clearIsEmpty() {_uniqueStorage()._isEmpty = nil}

  /// Check if field is null
  public var isNull: Bool {
    get {return _storage._isNull ?? false}
    set {_uniqueStorage()._isNull = newValue}
  }
  public var hasIsNull: Bool {return _storage._isNull != nil}
  public mutating func clearIsNull() {_uniqueStorage()._isNull = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Qdrant_Match: Sendable {
  public var matchValue: Qdrant_Match.OneOf_MatchValue? = nil

  /// Match string keyword
  public var keyword: String {
    get {
      if case .keyword(let v)? = matchValue {return v}
      return String()
    }
    set {matchValue = .keyword(newValue)}
  }

  /// Match integer
  public var integer: Int64 {
    get {
      if case .integer(let v)? = matchValue {return v}
      return 0
    }
    set {matchValue = .integer(newValue)}
  }

  /// Match boolean
  public var boolean: Bool {
    get {
      if case .boolean(let v)? = matchValue {return v}
      return false
    }
    set {matchValue = .boolean(newValue)}
  }

  /// Match text
  public var text: String {
    get {
      if case .text(let v)? = matchValue {return v}
      return String()
    }
    set {matchValue = .text(newValue)}
  }

  /// Match multiple keywords
  public var keywords: Qdrant_RepeatedStrings {
    get {
      if case .keywords(let v)? = matchValue {return v}
      return Qdrant_RepeatedStrings()
    }
    set {matchValue = .keywords(newValue)}
  }

  /// Match multiple integers
  public var integers: Qdrant_RepeatedIntegers {
    get {
      if case .integers(let v)? = matchValue {return v}
      return Qdrant_RepeatedIntegers()
    }
    set {matchValue = .integers(newValue)}
  }

  /// Match any other value except those integers
  public var exceptIntegers: Qdrant_RepeatedIntegers {
    get {
      if case .exceptIntegers(let v)? = matchValue {return v}
      return Qdrant_RepeatedIntegers()
    }
    set {matchValue = .exceptIntegers(newValue)}
  }

  /// Match any other value except those keywords
  public var exceptKeywords: Qdrant_RepeatedStrings {
    get {
      if case .exceptKeywords(let v)? = matchValue {return v}
      return Qdrant_RepeatedStrings()
    }
    set {matchValue = .exceptKeywords(newValue)}
  }

  /// Match phrase text
  public var phrase: String {
    get {
      if case .phrase(let v)? = matchValue {return v}
      return String()
    }
    set {matchValue = .phrase(newValue)}
  }

  /// Match any word in the text
  public var textAny: String {
    get {
      if case .textAny(let v)? = matchValue {return v}
      return String()
    }
    set {matchValue = .textAny(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_MatchValue: Equatable, Sendable {
    /// Match string keyword
    case keyword(String)
    /// Match integer
    case integer(Int64)
    /// Match boolean
    case boolean(Bool)
    /// Match text
    case text(String)
    /// Match multiple keywords
    case keywords(Qdrant_RepeatedStrings)
    /// Match multiple integers
    case integers(Qdrant_RepeatedIntegers)
    /// Match any other value except those integers
    case exceptIntegers(Qdrant_RepeatedIntegers)
    /// Match any other value except those keywords
    case exceptKeywords(Qdrant_RepeatedStrings)
    /// Match phrase text
    case phrase(String)
    /// Match any word in the text
    case textAny(String)

  }

  public init() {}
}

public struct Qdrant_RepeatedStrings: Sendable {
  public var strings: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_RepeatedIntegers: Sendable {
  public var integers: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Qdrant_Range: Sendable {
  public var lt: Double {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  public var hasLt: Bool {return self._lt != nil}
  public mutating func clearLt() {self._lt = nil}

  public var gt: Double {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  public var hasGt: Bool {return self._gt != nil}
  public mutating func clearGt() {self._gt = nil}

  public var gte: Double {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  public var hasGte: Bool {return self._gte != nil}
  public mutating func clearGte() {self._gte = nil}

  public var lte: Double {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  public var hasLte: Bool {return self._lte != nil}
  public mutating func clearLte() {self._lte = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lt: Double? = nil
  fileprivate var _gt: Double? = nil
  fileprivate var _gte: Double? = nil
  fileprivate var _lte: Double? = nil
}

public struct Qdrant_DatetimeRange: Sendable {
  public var lt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lt = newValue}
  }
  public var hasLt: Bool {return self._lt != nil}
  public mutating func clearLt() {self._lt = nil}

  public var gt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _gt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_gt = newValue}
  }
  public var hasGt: Bool {return self._gt != nil}
  public mutating func clearGt() {self._gt = nil}

  public var gte: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _gte ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_gte = newValue}
  }
  public var hasGte: Bool {return self._gte != nil}
  public mutating func clearGte() {self._gte = nil}

  public var lte: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lte ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lte = newValue}
  }
  public var hasLte: Bool {return self._lte != nil}
  public mutating func clearLte() {self._lte = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _gt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _gte: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lte: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Qdrant_GeoBoundingBox: Sendable {
  /// north-west corner
  public var topLeft: Qdrant_GeoPoint {
    get {return _topLeft ?? Qdrant_GeoPoint()}
    set {_topLeft = newValue}
  }
  public var hasTopLeft: Bool {return self._topLeft != nil}
  public mutating func clearTopLeft() {self._topLeft = nil}

  /// south-east corner
  public var bottomRight: Qdrant_GeoPoint {
    get {return _bottomRight ?? Qdrant_GeoPoint()}
    set {_bottomRight = newValue}
  }
  public var hasBottomRight: Bool {return self._bottomRight != nil}
  public mutating func clearBottomRight() {self._bottomRight = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _topLeft: Qdrant_GeoPoint? = nil
  fileprivate var _bottomRight: Qdrant_GeoPoint? = nil
}

public struct Qdrant_GeoRadius: Sendable {
  /// Center of the circle
  public var center: Qdrant_GeoPoint {
    get {return _center ?? Qdrant_GeoPoint()}
    set {_center = newValue}
  }
  public var hasCenter: Bool {return self._center != nil}
  public mutating func clearCenter() {self._center = nil}

  /// In meters
  public var radius: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _center: Qdrant_GeoPoint? = nil
}

public struct Qdrant_GeoLineString: Sendable {
  /// Ordered sequence of GeoPoints representing the line
  public var points: [Qdrant_GeoPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// For a valid GeoPolygon, both the exterior and interior GeoLineStrings must
/// consist of a minimum of 4 points.
/// Additionally, the first and last points of each GeoLineString must be the same.
public struct Qdrant_GeoPolygon: Sendable {
  /// The exterior line bounds the surface
  public var exterior: Qdrant_GeoLineString {
    get {return _exterior ?? Qdrant_GeoLineString()}
    set {_exterior = newValue}
  }
  public var hasExterior: Bool {return self._exterior != nil}
  public mutating func clearExterior() {self._exterior = nil}

  /// Interior lines (if present) bound holes within the surface
  public var interiors: [Qdrant_GeoLineString] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _exterior: Qdrant_GeoLineString? = nil
}

public struct Qdrant_ValuesCount: Sendable {
  public var lt: UInt64 {
    get {return _lt ?? 0}
    set {_lt = newValue}
  }
  public var hasLt: Bool {return self._lt != nil}
  public mutating func clearLt() {self._lt = nil}

  public var gt: UInt64 {
    get {return _gt ?? 0}
    set {_gt = newValue}
  }
  public var hasGt: Bool {return self._gt != nil}
  public mutating func clearGt() {self._gt = nil}

  public var gte: UInt64 {
    get {return _gte ?? 0}
    set {_gte = newValue}
  }
  public var hasGte: Bool {return self._gte != nil}
  public mutating func clearGte() {self._gte = nil}

  public var lte: UInt64 {
    get {return _lte ?? 0}
    set {_lte = newValue}
  }
  public var hasLte: Bool {return self._lte != nil}
  public mutating func clearLte() {self._lte = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lt: UInt64? = nil
  fileprivate var _gt: UInt64? = nil
  fileprivate var _gte: UInt64? = nil
  fileprivate var _lte: UInt64? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "qdrant"

extension Qdrant_PointId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}num\0\u{1}uuid\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.pointIDOptions != nil {try decoder.handleConflictingOneOf()}
          self.pointIDOptions = .num(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.pointIDOptions != nil {try decoder.handleConflictingOneOf()}
          self.pointIDOptions = .uuid(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.pointIDOptions {
    case .num?: try {
      guard case .num(let v)? = self.pointIDOptions else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .uuid?: try {
      guard case .uuid(let v)? = self.pointIDOptions else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_PointId, rhs: Qdrant_PointId) -> Bool {
    if lhs.pointIDOptions != rhs.pointIDOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GeoPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoPoint"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lon\0\u{1}lat\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lon) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.lat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lon.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lon, fieldNumber: 1)
    }
    if self.lat.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.lat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GeoPoint, rhs: Qdrant_GeoPoint) -> Bool {
    if lhs.lon != rhs.lon {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}should\0\u{1}must\0\u{3}must_not\0\u{3}min_should\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.should) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.must) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mustNot) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._minShould) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.should.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.should, fieldNumber: 1)
    }
    if !self.must.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.must, fieldNumber: 2)
    }
    if !self.mustNot.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mustNot, fieldNumber: 3)
    }
    try { if let v = self._minShould {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Filter, rhs: Qdrant_Filter) -> Bool {
    if lhs.should != rhs.should {return false}
    if lhs.must != rhs.must {return false}
    if lhs.mustNot != rhs.mustNot {return false}
    if lhs._minShould != rhs._minShould {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_MinShould: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MinShould"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conditions\0\u{3}min_count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.minCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 1)
    }
    if self.minCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.minCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_MinShould, rhs: Qdrant_MinShould) -> Bool {
    if lhs.conditions != rhs.conditions {return false}
    if lhs.minCount != rhs.minCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Condition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}field\0\u{3}is_empty\0\u{3}has_id\0\u{1}filter\0\u{3}is_null\0\u{1}nested\0\u{3}has_vector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Qdrant_FieldCondition?
        var hadOneofValue = false
        if let current = self.conditionOneOf {
          hadOneofValue = true
          if case .field(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionOneOf = .field(v)
        }
      }()
      case 2: try {
        var v: Qdrant_IsEmptyCondition?
        var hadOneofValue = false
        if let current = self.conditionOneOf {
          hadOneofValue = true
          if case .isEmpty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionOneOf = .isEmpty(v)
        }
      }()
      case 3: try {
        var v: Qdrant_HasIdCondition?
        var hadOneofValue = false
        if let current = self.conditionOneOf {
          hadOneofValue = true
          if case .hasID_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionOneOf = .hasID_p(v)
        }
      }()
      case 4: try {
        var v: Qdrant_Filter?
        var hadOneofValue = false
        if let current = self.conditionOneOf {
          hadOneofValue = true
          if case .filter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionOneOf = .filter(v)
        }
      }()
      case 5: try {
        var v: Qdrant_IsNullCondition?
        var hadOneofValue = false
        if let current = self.conditionOneOf {
          hadOneofValue = true
          if case .isNull(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionOneOf = .isNull(v)
        }
      }()
      case 6: try {
        var v: Qdrant_NestedCondition?
        var hadOneofValue = false
        if let current = self.conditionOneOf {
          hadOneofValue = true
          if case .nested(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionOneOf = .nested(v)
        }
      }()
      case 7: try {
        var v: Qdrant_HasVectorCondition?
        var hadOneofValue = false
        if let current = self.conditionOneOf {
          hadOneofValue = true
          if case .hasVector_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionOneOf = .hasVector_p(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.conditionOneOf {
    case .field?: try {
      guard case .field(let v)? = self.conditionOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .isEmpty?: try {
      guard case .isEmpty(let v)? = self.conditionOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hasID_p?: try {
      guard case .hasID_p(let v)? = self.conditionOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .filter?: try {
      guard case .filter(let v)? = self.conditionOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .isNull?: try {
      guard case .isNull(let v)? = self.conditionOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .nested?: try {
      guard case .nested(let v)? = self.conditionOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .hasVector_p?: try {
      guard case .hasVector_p(let v)? = self.conditionOneOf else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Condition, rhs: Qdrant_Condition) -> Bool {
    if lhs.conditionOneOf != rhs.conditionOneOf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_IsEmptyCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsEmptyCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_IsEmptyCondition, rhs: Qdrant_IsEmptyCondition) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_IsNullCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsNullCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_IsNullCondition, rhs: Qdrant_IsNullCondition) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_HasIdCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HasIdCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}has_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.hasID_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hasID_p.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hasID_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_HasIdCondition, rhs: Qdrant_HasIdCondition) -> Bool {
    if lhs.hasID_p != rhs.hasID_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_HasVectorCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HasVectorCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}has_vector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hasVector_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hasVector_p.isEmpty {
      try visitor.visitSingularStringField(value: self.hasVector_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_HasVectorCondition, rhs: Qdrant_HasVectorCondition) -> Bool {
    if lhs.hasVector_p != rhs.hasVector_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_NestedCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NestedCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_NestedCondition, rhs: Qdrant_NestedCondition) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_FieldCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}match\0\u{1}range\0\u{3}geo_bounding_box\0\u{3}geo_radius\0\u{3}values_count\0\u{3}geo_polygon\0\u{3}datetime_range\0\u{3}is_empty\0\u{3}is_null\0")

  fileprivate class _StorageClass {
    var _key: String = String()
    var _match: Qdrant_Match? = nil
    var _range: Qdrant_Range? = nil
    var _geoBoundingBox: Qdrant_GeoBoundingBox? = nil
    var _geoRadius: Qdrant_GeoRadius? = nil
    var _valuesCount: Qdrant_ValuesCount? = nil
    var _geoPolygon: Qdrant_GeoPolygon? = nil
    var _datetimeRange: Qdrant_DatetimeRange? = nil
    var _isEmpty: Bool? = nil
    var _isNull: Bool? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _match = source._match
      _range = source._range
      _geoBoundingBox = source._geoBoundingBox
      _geoRadius = source._geoRadius
      _valuesCount = source._valuesCount
      _geoPolygon = source._geoPolygon
      _datetimeRange = source._datetimeRange
      _isEmpty = source._isEmpty
      _isNull = source._isNull
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
            // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._match) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._range) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._geoBoundingBox) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._geoRadius) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._valuesCount) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._geoPolygon) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._datetimeRange) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isEmpty) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isNull) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._key.isEmpty {
        try visitor.visitSingularStringField(value: _storage._key, fieldNumber: 1)
      }
      try { if let v = _storage._match {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._range {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._geoBoundingBox {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._geoRadius {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._valuesCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._geoPolygon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._datetimeRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._isEmpty {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._isNull {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_FieldCondition, rhs: Qdrant_FieldCondition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._match != rhs_storage._match {return false}
        if _storage._range != rhs_storage._range {return false}
        if _storage._geoBoundingBox != rhs_storage._geoBoundingBox {return false}
        if _storage._geoRadius != rhs_storage._geoRadius {return false}
        if _storage._valuesCount != rhs_storage._valuesCount {return false}
        if _storage._geoPolygon != rhs_storage._geoPolygon {return false}
        if _storage._datetimeRange != rhs_storage._datetimeRange {return false}
        if _storage._isEmpty != rhs_storage._isEmpty {return false}
        if _storage._isNull != rhs_storage._isNull {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Match: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Match"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}keyword\0\u{1}integer\0\u{1}boolean\0\u{1}text\0\u{1}keywords\0\u{1}integers\0\u{3}except_integers\0\u{3}except_keywords\0\u{1}phrase\0\u{3}text_any\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.matchValue != nil {try decoder.handleConflictingOneOf()}
          self.matchValue = .keyword(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.matchValue != nil {try decoder.handleConflictingOneOf()}
          self.matchValue = .integer(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.matchValue != nil {try decoder.handleConflictingOneOf()}
          self.matchValue = .boolean(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.matchValue != nil {try decoder.handleConflictingOneOf()}
          self.matchValue = .text(v)
        }
      }()
      case 5: try {
        var v: Qdrant_RepeatedStrings?
        var hadOneofValue = false
        if let current = self.matchValue {
          hadOneofValue = true
          if case .keywords(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.matchValue = .keywords(v)
        }
      }()
      case 6: try {
        var v: Qdrant_RepeatedIntegers?
        var hadOneofValue = false
        if let current = self.matchValue {
          hadOneofValue = true
          if case .integers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.matchValue = .integers(v)
        }
      }()
      case 7: try {
        var v: Qdrant_RepeatedIntegers?
        var hadOneofValue = false
        if let current = self.matchValue {
          hadOneofValue = true
          if case .exceptIntegers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.matchValue = .exceptIntegers(v)
        }
      }()
      case 8: try {
        var v: Qdrant_RepeatedStrings?
        var hadOneofValue = false
        if let current = self.matchValue {
          hadOneofValue = true
          if case .exceptKeywords(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.matchValue = .exceptKeywords(v)
        }
      }()
      case 9: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.matchValue != nil {try decoder.handleConflictingOneOf()}
          self.matchValue = .phrase(v)
        }
      }()
      case 10: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.matchValue != nil {try decoder.handleConflictingOneOf()}
          self.matchValue = .textAny(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.matchValue {
    case .keyword?: try {
      guard case .keyword(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .integer?: try {
      guard case .integer(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .boolean?: try {
      guard case .boolean(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .text?: try {
      guard case .text(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .keywords?: try {
      guard case .keywords(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .integers?: try {
      guard case .integers(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .exceptIntegers?: try {
      guard case .exceptIntegers(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .exceptKeywords?: try {
      guard case .exceptKeywords(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .phrase?: try {
      guard case .phrase(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }()
    case .textAny?: try {
      guard case .textAny(let v)? = self.matchValue else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Match, rhs: Qdrant_Match) -> Bool {
    if lhs.matchValue != rhs.matchValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RepeatedStrings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RepeatedStrings"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}strings\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.strings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.strings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.strings, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RepeatedStrings, rhs: Qdrant_RepeatedStrings) -> Bool {
    if lhs.strings != rhs.strings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_RepeatedIntegers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RepeatedIntegers"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}integers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.integers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.integers.isEmpty {
      try visitor.visitPackedInt64Field(value: self.integers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_RepeatedIntegers, rhs: Qdrant_RepeatedIntegers) -> Bool {
    if lhs.integers != rhs.integers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Range"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lt\0\u{1}gt\0\u{1}gte\0\u{1}lte\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._lt) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._gt) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._gte) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._lte) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lt {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_Range, rhs: Qdrant_Range) -> Bool {
    if lhs._lt != rhs._lt {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_DatetimeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatetimeRange"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lt\0\u{1}gt\0\u{1}gte\0\u{1}lte\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gte) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lte) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_DatetimeRange, rhs: Qdrant_DatetimeRange) -> Bool {
    if lhs._lt != rhs._lt {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GeoBoundingBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoBoundingBox"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}top_left\0\u{3}bottom_right\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topLeft) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._bottomRight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topLeft {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bottomRight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GeoBoundingBox, rhs: Qdrant_GeoBoundingBox) -> Bool {
    if lhs._topLeft != rhs._topLeft {return false}
    if lhs._bottomRight != rhs._bottomRight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GeoRadius: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoRadius"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}center\0\u{1}radius\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._center) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.radius) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._center {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.radius.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.radius, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GeoRadius, rhs: Qdrant_GeoRadius) -> Bool {
    if lhs._center != rhs._center {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GeoLineString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoLineString"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}points\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GeoLineString, rhs: Qdrant_GeoLineString) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_GeoPolygon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoPolygon"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}exterior\0\u{1}interiors\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._exterior) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.interiors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exterior {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.interiors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interiors, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_GeoPolygon, rhs: Qdrant_GeoPolygon) -> Bool {
    if lhs._exterior != rhs._exterior {return false}
    if lhs.interiors != rhs.interiors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Qdrant_ValuesCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValuesCount"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lt\0\u{1}gt\0\u{1}gte\0\u{1}lte\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
        // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._lt) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._gt) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._gte) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._lte) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gte {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lte {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Qdrant_ValuesCount, rhs: Qdrant_ValuesCount) -> Bool {
    if lhs._lt != rhs._lt {return false}
    if lhs._gt != rhs._gt {return false}
    if lhs._gte != rhs._gte {return false}
    if lhs._lte != rhs._lte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
